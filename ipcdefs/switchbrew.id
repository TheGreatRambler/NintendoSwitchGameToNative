interface nn::account::IAccountServiceForAdministrator is acc:su {
	[0] GetUserCount() -> u32;
	[1] GetUserExistence(nn::account::Uid) -> b8;
	[2] ListAllUsers() -> buffer<nn::account::Uid,0xa>;
	[3] ListOpenUsers() -> buffer<nn::account::Uid,0xa>;
	[4] GetLastOpenedUser() -> nn::account::Uid;
	[5] GetProfile(nn::account::Uid) -> object<nn::account::profile::IProfile>;
	[6] GetProfileDigest(nn::account::Uid) -> nn::account::ProfileDigest;
	[50] IsUserRegistrationRequestPermitted(u64, pid) -> b8;
	[51] TrySelectUserWithoutInteraction(b8) -> nn::account::Uid;
	@version(5.0.0+)
	@undocumented
	[60] ListOpenContextStoredUsers(unknown) -> unknown;
	[100] GetUserRegistrationNotifier() -> object<nn::account::detail::INotifier>;
	[101] GetUserStateChangeNotifier() -> object<nn::account::detail::INotifier>;
	[102] GetBaasAccountManagerForSystemService(nn::account::Uid) -> object<nn::account::baas::IManagerForSystemService>;
	[103] GetBaasUserAvailabilityChangeNotifier() -> object<nn::account::detail::INotifier>;
	[104] GetProfileUpdateNotifier() -> object<nn::account::detail::INotifier>;
	@version(4.0.0+)
	[105] CheckNetworkServiceAvailabilityAsync(u64, pid, buffer<nn::account::SystemProgramIdentification,0x19>) -> object<nn::account::detail::IAsyncContext>;
	[110] StoreSaveDataThumbnail(nn::account::Uid, nn::ApplicationId, buffer<bytes,5>);
	[111] ClearSaveDataThumbnail(nn::account::Uid, nn::ApplicationId);
	[112] LoadSaveDataThumbnail(nn::account::Uid, nn::ApplicationId) -> (u32, buffer<bytes,6>);
	@undocumented
	[113] GetSaveDataThumbnailExistence(unknown) -> unknown;
	[190] GetUserLastOpenedApplication(nn::account::Uid) -> (u32, nn::ApplicationId);
	@version(5.0.0+)
	@undocumented
	[191] ActivateOpenContextHolder(unknown) -> unknown;
	[200] BeginUserRegistration() -> nn::account::Uid;
	[201] CompleteUserRegistration(nn::account::Uid);
	[202] CancelUserRegistration(nn::account::Uid);
	[203] DeleteUser(nn::account::Uid);
	[204] SetUserPosition(u32, nn::account::Uid);
	[205] GetProfileEditor(nn::account::Uid) -> object<nn::account::profile::IProfileEditor>;
	[206] CompleteUserRegistrationForcibly(nn::account::Uid);
	[210] CreateFloatingRegistrationRequest(u32, handle<copy>) -> object<nn::account::baas::IFloatingRegistrationRequest>;
	[230] AuthenticateServiceAsync() -> object<nn::account::detail::IAsyncContext>;
	[250] GetBaasAccountAdministrator(nn::account::Uid) -> object<nn::account::baas::IAdministrator>;
	[290] ProxyProcedureForGuestLoginWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::nas::IOAuthProcedureForExternalNsa>;
	[291] ProxyProcedureForFloatingRegistrationWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::nas::IOAuthProcedureForExternalNsa>;
	[299] SuspendBackgroundDaemon() -> object<nn::account::detail::ISessionObject>;
	[997] DebugInvalidateTokenCacheForUser(nn::account::Uid);
	[998] DebugSetUserStateClose(nn::account::Uid);
	[999] DebugSetUserStateOpen(nn::account::Uid);
}

interface nn::account::IAccountServiceForApplication is acc:u0 {
	[0] GetUserCount() -> u32;
	[1] GetUserExistence(nn::account::Uid) -> b8;
	[2] ListAllUsers() -> buffer<nn::account::Uid,0xa>;
	[3] ListOpenUsers() -> buffer<nn::account::Uid,0xa>;
	[4] GetLastOpenedUser() -> nn::account::Uid;
	[5] GetProfile(nn::account::Uid) -> object<nn::account::profile::IProfile>;
	[6] GetProfileDigest(nn::account::Uid) -> nn::account::ProfileDigest;
	[50] IsUserRegistrationRequestPermitted(u64, pid) -> b8;
	[51] TrySelectUserWithoutInteraction(b8) -> nn::account::Uid;
	@version(5.0.0+)
	@undocumented
	[60] ListOpenContextStoredUsers(unknown) -> unknown;
	[100] InitializeApplicationInfo(u64, pid);
	[101] GetBaasAccountManagerForApplication(nn::account::Uid) -> object<nn::account::baas::IManagerForApplication>;
	[102] AuthenticateApplicationAsync() -> object<nn::account::detail::IAsyncContext>;
	@version(4.0.0+)
	[103] CheckNetworkServiceAvailabilityAsync() -> object<nn::account::detail::IAsyncContext>;
	[110] StoreSaveDataThumbnail(nn::account::Uid, buffer<bytes,5>);
	[111] ClearSaveDataThumbnail(nn::account::Uid);
	[120] CreateGuestLoginRequest(u32, handle<copy>) -> object<nn::account::baas::IGuestLoginRequest>;
	@version(5.0.0+)
	@undocumented
	[130] LoadOpenContext(unknown) -> unknown;
}

interface nn::account::IAccountServiceForSystemService is acc:u1 {
	[0] GetUserCount() -> u32;
	[1] GetUserExistence(nn::account::Uid) -> b8;
	[2] ListAllUsers() -> buffer<nn::account::Uid,0xa>;
	[3] ListOpenUsers() -> buffer<nn::account::Uid,0xa>;
	[4] GetLastOpenedUser() -> nn::account::Uid;
	[5] GetProfile(nn::account::Uid) -> object<nn::account::profile::IProfile>;
	[6] GetProfileDigest(nn::account::Uid) -> nn::account::ProfileDigest;
	[50] IsUserRegistrationRequestPermitted(u64, pid) -> b8;
	[51] TrySelectUserWithoutInteraction(b8) -> nn::account::Uid;
	@version(5.0.0+)
	@undocumented
	[60] ListOpenContextStoredUsers(unknown) -> unknown;
	[100] GetUserRegistrationNotifier() -> object<nn::account::detail::INotifier>;
	[101] GetUserStateChangeNotifier() -> object<nn::account::detail::INotifier>;
	[102] GetBaasAccountManagerForSystemService(nn::account::Uid) -> object<nn::account::baas::IManagerForSystemService>;
	[103] GetBaasUserAvailabilityChangeNotifier() -> object<nn::account::detail::INotifier>;
	[104] GetProfileUpdateNotifier() -> object<nn::account::detail::INotifier>;
	@version(4.0.0+)
	[105] CheckNetworkServiceAvailabilityAsync(u64, pid, buffer<nn::account::SystemProgramIdentification,0x19>) -> object<nn::account::detail::IAsyncContext>;
	[110] StoreSaveDataThumbnail(nn::account::Uid, nn::ApplicationId, buffer<bytes,5>);
	[111] ClearSaveDataThumbnail(nn::account::Uid, nn::ApplicationId);
	[112] LoadSaveDataThumbnail(nn::account::Uid, nn::ApplicationId) -> (u32, buffer<bytes,6>);
	@version(5.0.0+)
	@undocumented
	[113] GetSaveDataThumbnailExistence(unknown) -> unknown;
	[190] GetUserLastOpenedApplication(nn::account::Uid) -> (u32, nn::ApplicationId);
	@version(5.0.0+)
	@undocumented
	[191] ActivateOpenContextHolder(unknown) -> unknown;
	[997] DebugInvalidateTokenCacheForUser(nn::account::Uid);
	[998] DebugSetUserStateClose(nn::account::Uid);
	[999] DebugSetUserStateOpen(nn::account::Uid);
}

interface nn::account::IBaasAccessTokenAccessor is acc:aa {
	[0] EnsureCacheAsync(nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
	[1] LoadCache(nn::account::Uid) -> (u32, buffer<bytes,6>);
	[2] GetDeviceAccountId(nn::account::Uid) -> u64;
	[50] RegisterNotificationTokenAsync(nn::npns::NotificationToken, nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
	[51] UnregisterNotificationTokenAsync(nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
}

interface nn::account::baas::IAdministrator {
	[0] CheckAvailability();
	[1] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[2] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[3] LoadIdTokenCache() -> (u32, buffer<bytes,6>);
	[100] SetSystemProgramIdentification(u64, pid, buffer<nn::account::SystemProgramIdentification,0x19>);
	@version(4.0.0+)
	[110] GetServiceEntryRequirementCache(nn::ApplicationId) -> u32;
	@version(4.0.0+)
	[111] InvalidateServiceEntryRequirementCache(nn::ApplicationId);
	@version(4.0.0+)
	[112] InvalidateTokenCache(nn::ApplicationId);
	[120] GetNintendoAccountId() -> nn::account::NintendoAccountId;
	[130] GetNintendoAccountUserResourceCache() -> (nn::account::NintendoAccountId, buffer<nn::account::nas::NasUserBase,0x1a>, buffer<bytes,6>);
	[131] RefreshNintendoAccountUserResourceCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[132] RefreshNintendoAccountUserResourceCacheAsyncIfSecondsElapsed(u32) -> (b8, object<nn::account::detail::IAsyncContext>);
	@version(5.0.0+)
	@undocumented
	[140] GetNetworkServiceLicenseCache(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[141] RefreshNetworkServiceLicenseCacheAsync(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[142] RefreshNetworkServiceLicenseCacheAsyncIfSecondsElapsed(unknown) -> unknown;
	[150] CreateAuthorizationRequest(u32, handle<copy>, buffer<nn::account::nas::NasClientInfo,0x19>, buffer<nn::account::NintendoAccountAuthorizationRequestParameters,0x19>) -> object<nn::account::nas::IAuthorizationRequest>;
	[200] IsRegistered() -> b8;
	[201] RegisterAsync() -> object<nn::account::detail::IAsyncContext>;
	[202] UnregisterAsync() -> object<nn::account::detail::IAsyncContext>;
	[203] DeleteRegistrationInfoLocally();
	[220] SynchronizeProfileAsync() -> object<nn::account::detail::IAsyncContext>;
	[221] UploadProfileAsync() -> object<nn::account::detail::IAsyncContext>;
	[222] SynchronizeProfileAsyncIfSecondsElapsed(u32) -> (b8, object<nn::account::detail::IAsyncContext>);
	[250] IsLinkedWithNintendoAccount() -> b8;
	[251] CreateProcedureToLinkWithNintendoAccount() -> object<nn::account::nas::IOAuthProcedureForNintendoAccountLinkage>;
	[252] ResumeProcedureToLinkWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::nas::IOAuthProcedureForNintendoAccountLinkage>;
	[255] CreateProcedureToUpdateLinkageStateOfNintendoAccount() -> object<nn::account::http::IOAuthProcedure>;
	[256] ResumeProcedureToUpdateLinkageStateOfNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::http::IOAuthProcedure>;
	[260] CreateProcedureToLinkNnidWithNintendoAccount() -> object<nn::account::http::IOAuthProcedure>;
	[261] ResumeProcedureToLinkNnidWithNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::http::IOAuthProcedure>;
	[280] ProxyProcedureToAcquireApplicationAuthorizationForNintendoAccount(nn::account::detail::Uuid) -> object<nn::account::http::IOAuthProcedure>;
	[997] DebugUnlinkNintendoAccountAsync() -> object<nn::account::detail::IAsyncContext>;
	[998] DebugSetAvailabilityErrorDetail(u32);
}

interface nn::account::baas::IFloatingRegistrationRequest {
	[0] GetSessionId() -> nn::account::detail::Uuid;
	[12] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[13] GetLinkedNintendoAccountId() -> nn::account::NintendoAccountId;
	[14] GetNickname() -> buffer<u8,0xa>;
	[15] GetProfileImage() -> (u32, buffer<bytes,6>);
	[21] LoadIdTokenCache() -> (u32, buffer<bytes,6>);
	@version(1.0.0-3.0.2)
	[100] RegisterAsync() -> nn::account::Uid;
	@version(4.0.0+)
	[100] RegisterUser() -> nn::account::Uid;
	@version(1.0.0-3.0.2)
	[101] RegisterWithUidAsync(nn::account::Uid);
	@version(4.0.0+)
	[101] RegisterUserWithUid(nn::account::Uid);
	@version(4.0.0+)
	[102] RegisterNetworkServiceAccountAsync() -> object<nn::account::detail::IAsyncContext>;
	@version(4.0.0+)
	[103] RegisterNetworkServiceAccountWithUidAsync(nn::account::Uid) -> object<nn::account::detail::IAsyncContext>;
	[110] SetSystemProgramIdentification(u64, pid, buffer<nn::account::SystemProgramIdentification,0x19>);
	[111] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
}

interface nn::account::baas::IGuestLoginRequest {
	[0] GetSessionId() -> nn::account::detail::Uuid;
	[12] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[13] GetLinkedNintendoAccountId() -> nn::account::NintendoAccountId;
	[14] GetNickname() -> buffer<u8,0xa>;
	[15] GetProfileImage() -> (u32, buffer<bytes,6>);
	[21] LoadIdTokenCache() -> (u32, buffer<bytes,6>);
}

interface nn::account::baas::IManagerForApplication {
	[0] CheckAvailability();
	[1] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[2] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[3] LoadIdTokenCache() -> (u32, buffer<bytes,6>);
	[130] GetNintendoAccountUserResourceCacheForApplication() -> (nn::account::NintendoAccountId, buffer<nn::account::nas::NasUserBaseForApplication,0x1a>, buffer<bytes,6>);
	[150] CreateAuthorizationRequest(u32, handle<copy>, buffer<nn::account::NintendoAccountAuthorizationRequestParameters,0x19>) -> object<nn::account::nas::IAuthorizationRequest>;
	@version(5.0.0+)
	@undocumented
	[160] StoreOpenContext(unknown) -> unknown;
}

interface nn::account::baas::IManagerForSystemService {
	[0] CheckAvailability();
	[1] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[2] EnsureIdTokenCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[3] LoadIdTokenCache() -> (u32, buffer<bytes,6>);
	[100] SetSystemProgramIdentification(u64, pid, buffer<nn::account::SystemProgramIdentification,0x19>);
	@version(4.0.0+)
	[110] GetServiceEntryRequirementCache(nn::ApplicationId) -> u32;
	@version(4.0.0+)
	[111] InvalidateServiceEntryRequirementCache(nn::ApplicationId);
	@version(4.0.0+)
	[112] InvalidateTokenCache(nn::ApplicationId);
	[120] GetNintendoAccountId() -> nn::account::NintendoAccountId;
	[130] GetNintendoAccountUserResourceCache() -> (nn::account::NintendoAccountId, buffer<nn::account::nas::NasUserBase,0x1a>, buffer<bytes,6>);
	[131] RefreshNintendoAccountUserResourceCacheAsync() -> object<nn::account::detail::IAsyncContext>;
	[132] RefreshNintendoAccountUserResourceCacheAsyncIfSecondsElapsed(u32) -> (b8, object<nn::account::detail::IAsyncContext>);
	@version(5.0.0+)
	@undocumented
	[140] GetNetworkServiceLicenseCache(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[141] RefreshNetworkServiceLicenseCacheAsync(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[142] RefreshNetworkServiceLicenseCacheAsyncIfSecondsElapsed(unknown) -> unknown;
	[150] CreateAuthorizationRequest(u32, handle<copy>, buffer<nn::account::nas::NasClientInfo,0x19>, buffer<nn::account::NintendoAccountAuthorizationRequestParameters,0x19>) -> object<nn::account::nas::IAuthorizationRequest>;
}

interface nn::account::detail::IAsyncContext {
	[0] GetSystemEvent() -> handle<copy>;
	[1] Cancel();
	[2] HasDone() -> b8;
	[3] GetResult();
}

interface nn::account::detail::INotifier {
	[0] GetSystemEvent() -> handle<copy>;
}

interface nn::account::detail::ISessionObject {
	[999] Dummy();
}

interface nn::account::http::IOAuthProcedure {
	[0] PrepareAsync() -> object<nn::account::detail::IAsyncContext>;
	[1] GetRequest() -> (buffer<nn::account::RequestUrl,0x1a>, buffer<nn::account::CallbackUri,0x1a>);
	[2] ApplyResponse(buffer<u8,9>);
	[3] ApplyResponseAsync(buffer<u8,9>) -> object<nn::account::detail::IAsyncContext>;
	[10] Suspend() -> nn::account::detail::Uuid;
}

interface nn::account::nas::IAuthorizationRequest {
	[0] GetSessionId() -> nn::account::detail::Uuid;
	[10] InvokeWithoutInteractionAsync() -> object<nn::account::detail::IAsyncContext>;
	[19] IsAuthorized() -> b8;
	[20] GetAuthorizationCode() -> (u32, buffer<bytes,6>);
	[21] GetIdToken() -> (u32, buffer<bytes,6>);
	[22] GetState() -> buffer<nn::account::nas::State,0x1a>;
}

interface nn::account::nas::IOAuthProcedureForExternalNsa {
	[0] PrepareAsync() -> object<nn::account::detail::IAsyncContext>;
	[1] GetRequest() -> (buffer<nn::account::RequestUrl,0x1a>, buffer<nn::account::CallbackUri,0x1a>);
	[2] ApplyResponse(buffer<u8,9>);
	[3] ApplyResponseAsync(buffer<u8,9>) -> object<nn::account::detail::IAsyncContext>;
	[10] Suspend() -> nn::account::detail::Uuid;
	[100] GetAccountId() -> nn::account::NetworkServiceAccountId;
	[101] GetLinkedNintendoAccountId() -> nn::account::NintendoAccountId;
	[102] GetNickname() -> buffer<u8,0xa>;
	[103] GetProfileImage() -> (u32, buffer<bytes,6>);
}

interface nn::account::nas::IOAuthProcedureForNintendoAccountLinkage {
	[0] PrepareAsync() -> object<nn::account::detail::IAsyncContext>;
	[1] GetRequest() -> (buffer<nn::account::RequestUrl,0x1a>, buffer<nn::account::CallbackUri,0x1a>);
	[2] ApplyResponse(buffer<u8,9>);
	[3] ApplyResponseAsync(buffer<u8,9>) -> object<nn::account::detail::IAsyncContext>;
	[10] Suspend() -> nn::account::detail::Uuid;
	[100] GetRequestWithTheme(u32) -> (buffer<nn::account::RequestUrl,0x1a>, buffer<nn::account::CallbackUri,0x1a>);
	[101] IsNetworkServiceAccountReplaced() -> b8;
	[199] GetUrlForIntroductionOfExtraMembership() -> buffer<nn::account::RequestUrl,0x1a>;
}

interface nn::account::profile::IProfile {
	# Takes an output type-0x1A buffer for
	# [\#UserData](http://switchbrew.org/index.php?title=Account%20services#UserData "wikilink"),
	# returns an output
	# [\#ProfileBase](http://switchbrew.org/index.php?title=Account%20services#ProfileBase "wikilink").
	# 
	[0] Get() -> (nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,0x1a>);
	# No input, returns an output
	# [\#ProfileBase](http://switchbrew.org/index.php?title=Account%20services#ProfileBase "wikilink").
	# 
	[1] GetBase() -> nn::account::profile::ProfileBase;
	# No input, returns an output u32 for the size of the image buffer.
	# 
	[10] GetImageSize() -> u32;
	# Takes an output type-0x6 buffer, returns the same output u32 as
	# [\#GetImageSize](#nn::account::profile::IProfile\(10\) "wikilink").
	# 
	# The output buffer contains the JPEG profile image icon. This is valid
	# for both Miis and character icons.
	# 
	[11] LoadImage() -> (u32, buffer<bytes,6>);
}

interface nn::account::profile::IProfileEditor {
	# Takes an output type-0x1A buffer for
	# [\#UserData](http://switchbrew.org/index.php?title=Account%20services#UserData "wikilink"),
	# returns an output
	# [\#ProfileBase](http://switchbrew.org/index.php?title=Account%20services#ProfileBase "wikilink").
	# 
	[0] Get() -> (nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,0x1a>);
	# No input, returns an output
	# [\#ProfileBase](http://switchbrew.org/index.php?title=Account%20services#ProfileBase "wikilink").
	# 
	[1] GetBase() -> nn::account::profile::ProfileBase;
	# No input, returns an output u32 for the size of the image buffer.
	# 
	[10] GetImageSize() -> u32;
	# Takes an output type-0x6 buffer, returns the same output u32 as
	# [\#GetImageSize](#nn::account::profile::IProfile\(10\) "wikilink").
	# 
	# The output buffer contains the JPEG profile image icon. This is valid
	# for both Miis and character icons.
	# 
	[11] LoadImage() -> (u32, buffer<bytes,6>);
	# Takes a
	# [\#ProfileBase](http://switchbrew.org/index.php?title=Account%20services#ProfileBase "wikilink")
	# and an input type-0x19 buffer for
	# [\#UserData](http://switchbrew.org/index.php?title=Account%20services#UserData "wikilink").
	# 
	[100] Store(nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,0x19>);
	# Takes a
	# [\#ProfileBase](http://switchbrew.org/index.php?title=Account%20services#ProfileBase "wikilink"),
	# an input type-0x19 buffer for
	# [\#UserData](http://switchbrew.org/index.php?title=Account%20services#UserData "wikilink"),
	# and an input type-0x5 buffer.
	# 
	[101] StoreWithImage(nn::account::profile::ProfileBase, buffer<nn::account::profile::UserData,0x19>, buffer<bytes,5>);
}

interface nn::ahid::IServerSession is ahid:cd {
	@undocumented
	[0] Unknown0(unknown<4>);
	@undocumented
	[1] Unknown1(unknown<4>);
	@undocumented
	[2] Unknown2(unknown<4>) -> object<nn::ahid::ICtrlSession>;
	@undocumented
	[3] Unknown3(unknown<4>) -> object<nn::ahid::IReadSession>;
}

interface nn::ahid::hdr::ISession is ahid:hdr {
	@undocumented
	[0] Unknown0() -> unknown<4>;
	@undocumented
	[1] Unknown1(unknown<4>, buffer<unknown,5>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[2] Unknown2(unknown<4>) -> buffer<unknown,6>;
	@undocumented
	[3] Unknown3(buffer<unknown,5>) -> unknown<4>;
	@undocumented
	[4] Unknown4(unknown<4>);
}

interface nn::am::service::IAllSystemAppletProxiesService is appletAE {
	[100] OpenSystemAppletProxy(u64, pid, handle<copy>) -> object<nn::am::service::ISystemAppletProxy>;
	@version(1.0.0-2.3.0)
	[200] OpenLibraryAppletProxy(u64, pid, handle<copy>) -> object<nn::am::service::ILibraryAppletProxy>;
	@version(3.0.0+)
	[200] OpenLibraryAppletProxyOld(u64, pid, handle<copy>) -> object<nn::am::service::ILibraryAppletProxy>;
	# Returns an
	# [\#ILibraryAppletProxy](http://switchbrew.org/index.php?title=AM%20services#ILibraryAppletProxy "wikilink").
	# 
	# Takes a
	# [reserved](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink")
	# input u64(official user-processes use hard-coded value 0), a PID,a
	# process copy-handle(cur-proc handle alias), and an 0x80-byte type-0x15
	# input buffer **AppletAttribute**.
	# 
	# Official user-processes use the same retry loop with this as the other
	# Open\*Proxy commands.
	# 
	@version(3.0.0+)
	[201] OpenLibraryAppletProxy(u64, pid, handle<copy>, buffer<nn::am::AppletAttribute,0x15>) -> object<nn::am::service::ILibraryAppletProxy>;
	[300] OpenOverlayAppletProxy(u64, pid, handle<copy>) -> object<nn::am::service::IOverlayAppletProxy>;
	[350] OpenSystemApplicationProxy(u64, pid, handle<copy>) -> object<nn::am::service::IApplicationProxy>;
	[400] CreateSelfLibraryAppletCreatorForDevelop(u64, pid) -> object<nn::am::service::ILibraryAppletCreator>;
}

interface nn::am::service::IApplicationProxyService is appletOE {
	# Returns an
	# [\#IApplicationProxy](http://switchbrew.org/index.php?title=AM%20services#IApplicationProxy "wikilink").
	# See
	# [\#appletAE](http://switchbrew.org/index.php?title=AM%20services#appletAE "wikilink").
	# 
	# Takes a
	# [reserved](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink")
	# input u64(official user-processes use hard-coded value 0), a PID, and a
	# process copy-handle(cur-proc handle alias).
	# 
	# On failure, official user-processes will retry using this command in a
	# loop while the retval is 0x19280, with svcSleepThread(10000000) being
	# called first.
	# 
	[0] OpenApplicationProxy(u64, pid, handle<copy>) -> object<nn::am::service::IApplicationProxy>;
}

interface nn::aocsrv::detail::IAddOnContentManager is aoc:u {
	[0] CountAddOnContentByApplicationId(nn::ncm::ApplicationId) -> u32;
	[1] ListAddOnContentByApplicationId(u32, u32, nn::ncm::ApplicationId) -> (u32, buffer<u32,6>);
	[2] CountAddOnContent(u64, pid) -> u32;
	[3] ListAddOnContent(u32, u32, u64, pid) -> (u32, buffer<u32,6>);
	[4] GetAddOnContentBaseIdByApplicationId(nn::ncm::ApplicationId) -> u64;
	[5] GetAddOnContentBaseId(u64, pid) -> u64;
	[6] PrepareAddOnContentByApplicationId(u32, nn::ncm::ApplicationId);
	[7] PrepareAddOnContent(u32, u64, pid);
	@version(4.0.0+)
	[8] GetAddOnContentListChangedEvent() -> handle<copy>;
}

interface nn::apm::IManager is apm {
	[0] OpenSession() -> object<nn::apm::ISession>;
	[1] GetPerformanceMode() -> nn::apm::PerformanceMode;
}

interface nn::apm::IManagerPrivileged is apm:p {
	[0] OpenSession() -> object<nn::apm::ISession>;
}

interface nn::apm::ISession {
	[0] SetPerformanceConfiguration(nn::apm::PerformanceMode, nn::apm::PerformanceConfiguration);
	[1] GetPerformanceConfiguration(nn::apm::PerformanceMode) -> nn::apm::PerformanceConfiguration;
}

interface nn::apm::ISystemManager is apm:sys {
	[0] RequestPerformanceMode(nn::apm::PerformanceMode);
	[1] GetPerformanceEvent(nn::apm::EventTarget) -> handle<copy>;
	[2] GetThrottlingState() -> nn::apm::ThrottlingState;
	[3] GetLastThrottlingState() -> nn::apm::ThrottlingState;
	[4] ClearLastThrottlingState();
	@version(5.0.0+)
	@undocumented
	[5] LoadAndApplySettings(unknown) -> unknown;
}

interface nn::arp::detail::IReader is arp:r {
	@undocumented
	[0] GetApplicationLaunchProperty(unknown<8>) -> unknown<0x10>;
	@undocumented
	[1] GetApplicationLaunchPropertyWithApplicationId(unknown<8>) -> unknown<0x10>;
	@undocumented
	[2] GetApplicationControlProperty(unknown<8>) -> buffer<unknown,0x16>;
	@undocumented
	[3] GetApplicationControlPropertyWithApplicationId(unknown<8>) -> buffer<unknown,0x16>;
}

interface nn::arp::detail::IRegistrar {
	@undocumented
	[0] Issue(unknown<8>);
	@undocumented
	[1] SetApplicationLaunchProperty(unknown<0x10>);
	@undocumented
	[2] SetApplicationControlProperty(buffer<unknown,0x15>);
}

interface nn::arp::detail::IWriter is arp:w {
	@undocumented
	[0] AcquireRegistrar() -> object<nn::arp::detail::IRegistrar>;
	@undocumented
	[1] DeleteProperties(unknown<8>);
}

interface nn::audio::detail::IAudioDebugManager is auddebug {
	[0] Unknown0(u32, u64, handle<copy>);
	[1] Unknown1();
	[2] Unknown2();
	[3] Unknown3();
}

interface nn::audio::detail::IAudioDevice {
	[0] ListAudioDeviceName() -> (u32, buffer<unknown,6>);
	[1] SetAudioDeviceOutputVolume(u32, buffer<unknown,5>);
	[2] GetAudioDeviceOutputVolume(buffer<unknown,5>) -> u32;
	[3] GetActiveAudioDeviceName() -> buffer<unknown,6>;
	[4] QueryAudioDeviceSystemEvent() -> handle<copy>;
	[5] GetActiveChannelCount() -> u32;
	@version(3.0.0+)
	[6] ListAudioDeviceNameAuto() -> (u32, buffer<unknown,0x22>);
	@version(3.0.0+)
	[7] SetAudioDeviceOutputVolumeAuto(u32, buffer<unknown,0x21>);
	@version(3.0.0+)
	[8] GetAudioDeviceOutputVolumeAuto(buffer<unknown,0x21>) -> u32;
	@version(3.0.0+)
	[10] GetActiveAudioDeviceNameAuto() -> buffer<unknown,0x22>;
	@version(3.0.0+)
	[11] QueryAudioDeviceInputEvent() -> handle<copy>;
	@version(3.0.0+)
	[12] QueryAudioDeviceOutputEvent() -> handle<copy>;
}

interface nn::audio::detail::IAudioIn {
	# Returns an u32 **AudioInState** (0x00=Started, 0x01=Stopped).
	# 
	[0] GetAudioInState() -> u32;
	[1] StartAudioIn();
	[2] StopAudioIn();
	[3] AppendAudioInBuffer(u64, buffer<unknown,5>);
	[4] RegisterBufferEvent() -> handle<copy>;
	[5] GetReleasedAudioInBuffer() -> (u32, buffer<unknown,6>);
	[6] ContainsAudioInBuffer(u64) -> u8;
	@version(3.0.0+)
	[7] AppendAudioInBufferWithUserEvent(u64, handle<copy>, buffer<unknown,5>);
	@version(3.0.0+)
	[8] AppendAudioInBufferAuto(u64, buffer<unknown,0x21>);
	@version(3.0.0+)
	[9] GetReleasedAudioInBufferAuto() -> (u32, buffer<unknown,0x22>);
	@version(3.0.0+)
	[10] AppendAudioInBufferWithUserEventAuto(u64, handle<copy>, buffer<unknown,0x21>);
	@version(4.0.0+)
	[11] GetAudioInBufferCount() -> u32;
	@version(4.0.0+)
	[12] SetAudioInDeviceGain(u32);
	@version(4.0.0+)
	[13] GetAudioInDeviceGain() -> u32;
}

interface nn::audio::detail::IAudioInManager is audin:u {
	[0] ListAudioIns() -> (u32, buffer<unknown,6>);
	[1] OpenAudioIn(bytes<8,4>, u64, pid, handle<copy>, buffer<unknown,5>) -> (bytes<0x10,4>, buffer<unknown,6>, object<nn::audio::detail::IAudioIn>);
	@version(3.0.0+)
	[2] Unknown2() -> (u32, buffer<unknown,0x22>);
	@version(3.0.0+)
	[3] OpenAudioInAuto(bytes<8,4>, u64, pid, handle<copy>, buffer<unknown,0x21>) -> (bytes<0x10,4>, buffer<unknown,0x22>, object<nn::audio::detail::IAudioIn>);
	@version(3.0.0+)
	[4] ListAudioInsAuto() -> (u32, buffer<unknown,0x22>);
}

interface nn::audio::detail::IAudioInManagerForApplet is audin:a {
	[0] RequestSuspendAudioIns(u64, u64);
	[1] RequestResumeAudioIns(u64, u64);
	[2] GetAudioInsProcessMasterVolume(u64) -> u32;
	[3] SetAudioInsProcessMasterVolume(u32, u64, u64);
}

interface nn::audio::detail::IAudioOut {
	# Returns an u32 **AudioOutState** (0x00=Started, 0x01=Stopped).
	# 
	[0] GetAudioOutState() -> u32;
	# Starts audio playback using data from appended buffers.
	# 
	[1] StartAudioOut();
	# Stops audio playback. This waits for audio playback to finish before
	# returning.
	# 
	[2] StopAudioOut();
	# Takes a type-5 input buffer for sample data and a u64 which acts as a
	# tag for the supplied buffer (official apps use the buffer's address).
	# 
	# The format of the input buffer is as
	# follows:
	# 
	# | Offset | Size | Description                                           |
	# | ------ | ---- | ----------------------------------------------------- |
	# | 0x00   | 8    | Pointer to next buffer (unused)                       |
	# | 0x08   | 8    | Pointer to sample buffer                              |
	# | 0x10   | 8    | Capacity of sample buffer                             |
	# | 0x18   | 8    | Size of data in the sample buffer                     |
	# | 0x20   | 8    | Offset of data in the sample buffer (unused/ignored?) |
	# 
	[3] AppendAudioOutBuffer(u64, buffer<unknown,5>);
	# Returns an event handle that is signalled when a buffer is released.
	# 
	[4] RegisterBufferEvent() -> handle<copy>;
	# Takes a type-6 output buffer which will be filled with the identifiers
	# from
	# [\#AppendAudioOutBuffer](#nn::audio::detail::IAudioOut\(3\) "wikilink")
	# of audio buffers that have been released. Returns an u32
	# **ReleasedBuffersCount**.
	# 
	[5] GetReleasedAudioOutBuffer() -> (u32, buffer<unknown,6>);
	# Takes an u64 **tag** for the desired buffer. Returns 1 if the buffer was
	# appended and not yet released.
	# 
	[6] ContainsAudioOutBuffer(u64) -> u8;
	# Same as
	# [\#AppendAudioOutBuffer](#nn::audio::detail::IAudioOut\(3\) "wikilink")
	# but takes a type-0x21 buffer instead.
	# 
	@version(3.0.0+)
	[7] AppendAudioOutBufferAuto(u64, buffer<unknown,0x21>);
	# Same as
	# [\#GetReleasedAudioOutBuffer](#nn::audio::detail::IAudioOut\(5\) "wikilink")
	# but takes a type-0x22 buffer instead.
	# 
	@version(3.0.0+)
	[8] GetReleasedAudioOutBufferAuto() -> (u32, buffer<unknown,0x22>);
	@version(4.0.0+)
	[9] GetAudioOutBufferCount() -> u32;
	@version(4.0.0+)
	[10] GetAudioOutPlayedSampleCount() -> u64;
	@version(4.0.0+)
	[11] FlushAudioOutBuffers() -> u8;
}

interface nn::audio::detail::IAudioOutManager is audout:u {
	# Takes a type-6 output buffer. Populates the output buffer with the
	# available audio output devices' names and returns an u32 with the number
	# of device names written.
	# 
	[0] ListAudioOuts() -> (u32, buffer<unknown,6>);
	# Takes a type-5 input buffer (**DeviceNameIn**), a type-6 output buffer
	# (**DeviceNameOut**), two u32s **SampleRate** (must be 48000) and
	# **ChannelCount** (only the higher u16 is used), one u64 **ClientPID**, a
	# PID and a copy-handle. Returns an
	# [\#IAudioOut](#nn::audio::detail::IAudioOut "wikilink") object and four
	# u32s: the sample rate, channel count, [PCM
	# format](http://switchbrew.org/index.php?title=Audio%20services#PCM_format "wikilink"),
	# and the initial AudioOutState.
	# 
	[1] OpenAudioOut(bytes<8,4>, u64, pid, handle<copy>, buffer<unknown,5>) -> (bytes<0x10,4>, buffer<unknown,6>, object<nn::audio::detail::IAudioOut>);
	# Same as
	# [\#ListAudioOuts](#nn::audio::detail::IAudioOutManager\(0\) "wikilink"),
	# but takes a type-0x22 output buffer instead.
	# 
	@version(3.0.0+)
	[2] ListAudioOutsAuto() -> (u32, buffer<unknown,0x22>);
	# Same as
	# [\#OpenAudioOut](#nn::audio::detail::IAudioOutManager\(1\) "wikilink"),
	# but takes a type-0x21 input buffer instead.
	# 
	@version(3.0.0+)
	[3] OpenAudioOutAuto(bytes<8,4>, u64, pid, handle<copy>, buffer<unknown,0x21>) -> (bytes<0x10,4>, buffer<unknown,0x22>, object<nn::audio::detail::IAudioOut>);
}

interface nn::audio::detail::IAudioOutManagerForApplet is audout:a {
	[0] RequestSuspendAudioOuts(u64, u64);
	[1] RequestResumeAudioOuts(u64, u64);
	[2] GetAudioOutsProcessMasterVolume(u64) -> u32;
	[3] SetAudioOutsProcessMasterVolume(u32, u64, u64);
	@version(4.0.0+)
	[4] GetAudioOutsProcessRecordVolume(u64) -> u32;
	@version(4.0.0+)
	[5] SetAudioOutsProcessRecordVolume(u32, u64, u64);
}

interface nn::audio::detail::IAudioOutManagerForDebugger is audin:d, audout:d, audren:d, audrec:d {
	# Takes an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services#AppletResourceUserId "wikilink").
	# 
	[0] RequestSuspendForDebug(u64);
	# Takes an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services#AppletResourceUserId "wikilink").
	# 
	[1] RequestResumeForDebug(u64);
}

interface nn::audio::detail::IAudioRenderer {
	# Returns the Sample Rate. (u32)
	# 
	[0] GetAudioRendererSampleRate() -> u32;
	# Returns the Sample Count. (u32)
	# 
	[1] GetAudioRendererSampleCount() -> u32;
	# Returns the number of Mix Buffers. (u32)
	# 
	[2] GetAudioRendererMixBufferCount() -> u32;
	# Returns an AudioRenderState, 0x00=Started 0x01=Stopped (u32)
	# 
	[3] GetAudioRendererState() -> u32;
	[4] RequestUpdateAudioRenderer(buffer<unknown,5>) -> (buffer<unknown,6>, buffer<unknown,6>);
	[5] StartAudioRenderer();
	[6] StopAudioRenderer();
	[7] QuerySystemEvent() -> handle<copy>;
	# Takes a upper limit of the rendering time in percent. (u32)
	# 
	[8] SetAudioRendererRenderingTimeLimit(u32);
	# Returns the upper limit of the rendering time in percent. (u32)
	# 
	[9] GetAudioRendererRenderingTimeLimit() -> u32;
	@version(3.0.0+)
	[10] RequestUpdateAudioRendererAuto(buffer<unknown,0x21>) -> (buffer<unknown,0x22>, buffer<unknown,0x22>);
	@version(3.0.0+)
	[11] ExecuteAudioRendererRendering();
}

interface nn::audio::detail::IAudioRendererManager is audren:u {
	[0] OpenAudioRenderer(bytes<0x34,4>, u64, u64, pid, handle<copy>, handle<copy>) -> object<nn::audio::detail::IAudioRenderer>;
	[1] GetAudioRendererWorkBufferSize(bytes<0x34,4>) -> u64;
	[2] GetAudioDeviceService(u64) -> object<nn::audio::detail::IAudioDevice>;
	@version(3.0.0+)
	[3] OpenAudioRendererAuto(bytes<0x34,4>, u64, u64, u64, pid, handle<copy>) -> object<nn::audio::detail::IAudioRenderer>;
	@version(4.0.0+)
	[4] GetAudioDeviceServiceWithRevisionInfo(u32, u64) -> object<nn::audio::detail::IAudioDevice>;
}

interface nn::audio::detail::IAudioRendererManagerForApplet is audren:a {
	[0] RequestSuspendAudioRenderers(u64, u64);
	[1] RequestResumeAudioRenderers(u64, u64);
	[2] GetAudioRenderersProcessMasterVolume(u64) -> u32;
	[3] SetAudioRenderersProcessMasterVolume(u32, u64, u64);
	[4] RegisterAppletResourceUserId(u64);
	[5] UnregisterAppletResourceUserId(u64);
	@version(4.0.0+)
	[6] GetAudioRenderersProcessRecordVolume(u64) -> u32;
	@version(4.0.0+)
	[7] SetAudioRenderersProcessRecordVolume(u32, u64, u64);
}

interface nn::audio::detail::ICodecController is codecctl {
	# Takes no input.
	# 
	[0] InitializeCodecController();
	# Takes no input.
	# 
	[1] FinalizeCodecController();
	# Takes no input.
	# 
	[2] SleepCodecController();
	# Takes no input.
	# 
	[3] WakeCodecController();
	# Takes an u32 **Volume**.
	# 
	[4] SetCodecVolume(u32);
	# Returns an u32 **VolumeMax**.
	# 
	[5] GetCodecVolumeMax() -> u32;
	# Returns an u32 **VolumeMin**.
	# 
	[6] GetCodecVolumeMin() -> u32;
	# Takes an u32 **Target**.
	# 
	[7] SetCodecActiveTarget(u32);
	# Returns an u32 **Target**.
	# 
	[8] GetCodecActiveTarget() -> u32;
	# Returns an event handle.
	# 
	[9] BindCodecHeadphoneMicJackInterrupt() -> handle<copy>;
	# Returns a bool.
	# 
	[10] IsCodecHeadphoneMicJackInserted() -> u8;
	# Takes no input.
	# 
	[11] ClearCodecHeadphoneMicJackInterrupt();
	# Returns a bool.
	# 
	[12] IsCodecDeviceRequested() -> u8;
}

interface nn::audio::detail::IFinalOutputRecorder {
	[0] GetFinalOutputRecorderState() -> u32;
	[1] StartFinalOutputRecorder();
	[2] StopFinalOutputRecorder();
	[3] AppendFinalOutputRecorderBuffer(u64, buffer<unknown,5>);
	[4] RegisterBufferEvent() -> handle<copy>;
	[5] GetReleasedFinalOutputRecorderBuffer() -> (u32, u64, buffer<unknown,6>);
	[6] ContainsFinalOutputRecorderBuffer(u64) -> u8;
	[7] Unknown7(u64) -> u64;
	@version(3.0.0+)
	[8] AppendFinalOutputRecorderBufferAuto(u64, buffer<unknown,0x21>);
	@version(3.0.0+)
	[9] GetReleasedFinalOutputRecorderBufferAuto() -> (u32, u64, buffer<unknown,0x22>);
}

interface nn::audio::detail::IFinalOutputRecorderManager is audrec:u {
	[0] OpenFinalOutputRecorder(bytes<8,4>, u64, handle<copy>) -> (bytes<0x10,4>, object<nn::audio::detail::IFinalOutputRecorder>);
}

interface nn::audio::detail::IFinalOutputRecorderManagerForApplet is audrec:a {
	[0] RequestSuspendFinalOutputRecorders(u64, u64);
	[1] RequestResumeFinalOutputRecorders(u64, u64);
}

interface nn::audioctrl::detail::IAudioController is audctl {
	@undocumented
	[0] GetTargetVolume(unknown<4>) -> unknown<4>;
	@undocumented
	[1] SetTargetVolume(unknown<8>);
	@undocumented
	[2] GetTargetVolumeMin() -> unknown<4>;
	@undocumented
	[3] GetTargetVolumeMax() -> unknown<4>;
	@undocumented
	[4] IsTargetMute(unknown<4>) -> unknown<1>;
	@undocumented
	[5] SetTargetMute(unknown<8>);
	@undocumented
	[6] IsTargetConnected(unknown<4>) -> unknown<1>;
	@undocumented
	[7] SetDefaultTarget(unknown<0x18>);
	@undocumented
	[8] GetDefaultTarget() -> unknown<4>;
	@undocumented
	[9] GetAudioOutputMode(unknown<4>) -> unknown<4>;
	@undocumented
	[10] SetAudioOutputMode(unknown<8>);
	@undocumented
	[11] SetForceMutePolicy(unknown<4>);
	@undocumented
	[12] GetForceMutePolicy() -> unknown<4>;
	@undocumented
	[13] GetOutputModeSetting(unknown<4>) -> unknown<4>;
	@undocumented
	[14] SetOutputModeSetting(unknown<8>);
	@undocumented
	[15] SetOutputTarget(unknown<4>);
	@undocumented
	[16] SetInputTargetForceEnabled(unknown<1>);
	@version(3.0.0+)
	@undocumented
	[17] SetHeadphoneOutputLevelMode(unknown<4>);
	@version(3.0.0+)
	@undocumented
	[18] GetHeadphoneOutputLevelMode() -> unknown<4>;
	@version(3.0.0+)
	@undocumented
	[19] AcquireAudioVolumeUpdateEventForPlayReport() -> handle<copy>;
	@version(3.0.0+)
	@undocumented
	[20] AcquireAudioOutputDeviceUpdateEventForPlayReport() -> handle<copy>;
	@version(3.0.0+)
	@undocumented
	[21] GetAudioOutputTargetForPlayReport() -> unknown<4>;
	@version(3.0.0+)
	@undocumented
	[22] NotifyHeadphoneVolumeWarningDisplayedEvent();
	@version(4.0.0+)
	@undocumented
	[23] SetSystemOutputMasterVolume(unknown<4>);
	@version(4.0.0+)
	@undocumented
	[24] GetSystemOutputMasterVolume() -> unknown<4>;
	@version(4.0.0+)
	@undocumented
	[25] GetAudioVolumeDataForPlayReport() -> unknown<7>;
	@version(4.0.0+)
	@undocumented
	[26] UpdateHeadphoneSettings(unknown<1>);
}

interface nn::bcat::detail::ipc::IBcatService {
	[10100] RequestSyncDeliveryCache() -> object<nn::bcat::detail::ipc::IDeliveryCacheProgressService>;
	@version(5.0.0+)
	@undocumented
	[10101] RequestSyncDeliveryCacheWithDirectoryName(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[10200] CancelSyncDeliveryCacheRequest(unknown) -> unknown;
	[20100] RequestSyncDeliveryCacheWithApplicationId(u32, nn::ApplicationId) -> object<nn::bcat::detail::ipc::IDeliveryCacheProgressService>;
	@version(5.0.0+)
	@undocumented
	[20101] RequestSyncDeliveryCacheWithApplicationIdAndDirectoryName(unknown) -> unknown;
	[30100] SetPassphrase(nn::ApplicationId, buffer<u8,9>);
	[30200] RegisterBackgroundDeliveryTask(u32, nn::ApplicationId);
	[30201] UnregisterBackgroundDeliveryTask(nn::ApplicationId);
	[30202] BlockDeliveryTask(nn::ApplicationId);
	[30203] UnblockDeliveryTask(nn::ApplicationId);
	[90100] EnumerateBackgroundDeliveryTask() -> (u32, buffer<nn::bcat::TaskInfo,6>);
	[90200] GetDeliveryList(nn::ApplicationId) -> (u64, buffer<bytes,6>);
	[90201] ClearDeliveryCacheStorage(nn::ApplicationId);
	[90300] GetPushNotificationLog() -> (u32, buffer<nn::bcat::PushNotificationLog,6>);
}

interface nn::bcat::detail::ipc::IDeliveryCacheDirectoryService {
	[0] Open(nn::bcat::DirectoryName);
	[1] Read() -> (u32, buffer<nn::bcat::DeliveryCacheDirectoryEntry,6>);
	[2] GetCount() -> u32;
}

interface nn::bcat::detail::ipc::IDeliveryCacheFileService {
	[0] Open(nn::bcat::DirectoryName, nn::bcat::FileName);
	[1] Read(u64) -> (u64, buffer<bytes,6>);
	[2] GetSize() -> u64;
	[3] GetDigest() -> nn::bcat::Digest;
}

interface nn::bcat::detail::ipc::IDeliveryCacheProgressService {
	[0] GetEvent() -> handle<copy>;
	[1] GetImpl() -> buffer<nn::bcat::detail::DeliveryCacheProgressImpl,0x1a>;
}

interface nn::bcat::detail::ipc::IDeliveryCacheStorageService {
	[0] CreateFileService() -> object<nn::bcat::detail::ipc::IDeliveryCacheFileService>;
	[1] CreateDirectoryService() -> object<nn::bcat::detail::ipc::IDeliveryCacheDirectoryService>;
	[10] EnumerateDeliveryCacheDirectory() -> (u32, buffer<nn::bcat::DirectoryName,6>);
}

interface nn::bcat::detail::ipc::IServiceCreator is bcat:a, bcat:u, bcat:m, bcat:s {
	[0] CreateBcatService(u64, pid) -> object<nn::bcat::detail::ipc::IBcatService>;
	[1] CreateDeliveryCacheStorageService(u64, pid) -> object<nn::bcat::detail::ipc::IDeliveryCacheStorageService>;
	[2] CreateDeliveryCacheStorageServiceWithApplicationId(nn::ApplicationId) -> object<nn::bcat::detail::ipc::IDeliveryCacheStorageService>;
}

interface nn::bluetooth::IBluetoothDriver is btdrv {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Init() -> handle<copy>;
	@undocumented
	[2] Enable();
	@undocumented
	[3] Disable();
	@undocumented
	[4] CleanupAndShutdown();
	@undocumented
	[5] GetAdapterProperties() -> buffer<unknown,0x1a>;
	@undocumented
	[6] GetAdapterProperty(unknown<4>) -> buffer<unknown,0xa>;
	@undocumented
	[7] SetAdapterProperty(unknown<4>, buffer<unknown,9>);
	@undocumented
	[8] StartDiscovery();
	@undocumented
	[9] CancelDiscovery();
	@undocumented
	[10] CreateBond(unknown<6>, buffer<unknown,0x19>);
	@undocumented
	[11] RemoveBond(unknown<6>);
	@undocumented
	[12] CancelBond(unknown<6>);
	@undocumented
	[13] PinReply(unknown<0x18>);
	@undocumented
	[14] SspReply(unknown<0xc>);
	@undocumented
	[15] Unknown15() -> (unknown<4>, buffer<unknown,0xa>);
	@undocumented
	[16] InitInterfaces(unknown<2>) -> handle<copy>;
	@undocumented
	[17] HidHostInterface_Connect(unknown<6>);
	@undocumented
	[18] HidHostInterface_Disconnect(unknown<6>);
	@undocumented
	[19] HidHostInterface_SendData(unknown<6>, buffer<unknown,0x19>);
	@undocumented
	[20] HidHostInterface_SendData2(unknown<6>, buffer<unknown,9>);
	@undocumented
	[21] HidHostInterface_SetReport(unknown<0xc>, buffer<unknown,0x19>);
	@undocumented
	[22] HidHostInterface_GetReport(unknown<0xc>);
	@undocumented
	[23] HidHostInterface_WakeController(unknown<6>);
	@undocumented
	[24] HidHostInterface_AddPairedDevice(buffer<unknown,0x19>);
	@undocumented
	[25] HidHostInterface_GetPairedDevice(unknown<6>) -> buffer<unknown,0x1a>;
	@undocumented
	[26] HidHostInterface_CleanupAndShutdown();
	@undocumented
	[27] Unknown27() -> (unknown<4>, buffer<unknown,0xa>);
	@undocumented
	[28] ExtInterface_SetTSI(unknown<7>);
	@undocumented
	[29] ExtInterface_SetBurstMode(unknown<7>);
	@undocumented
	[30] ExtInterface_SetZeroRetran(unknown<6>, buffer<unknown,9>);
	@undocumented
	[31] ExtInterface_SetMcMode(unknown<1>);
	@undocumented
	[32] ExtInterface_StartLlrMode();
	@undocumented
	[33] ExtInterface_ExitLlrMode();
	@undocumented
	[34] ExtInterface_SetRadio(unknown<1>);
	@undocumented
	[35] ExtInterface_SetVisibility(unknown<2>);
	@undocumented
	[36] Unknown36(unknown<1>);
	@undocumented
	[37] Unknown37() -> handle<copy>;
	@undocumented
	[38] HidHostInterface_GetLatestPlr() -> (unknown<4>, buffer<unknown,0xa>);
	@undocumented
	[39] ExtInterface_GetPendingConnections() -> buffer<unknown,0x16>;
	@undocumented
	[40] HidHostInterface_GetChannelMap();
	@undocumented
	[41] SetIsBluetoothBoostEnabled() -> buffer<unknown,0x16>;
	@undocumented
	[42] GetIsBluetoothBoostEnabled(unknown<1>);
	@undocumented
	[43] SetIsBluetoothAfhEnabled() -> unknown<1>;
	@undocumented
	[44] GetIsBluetoothAfhEnabled(unknown<1>);
}

interface nn::bpc::IBoardPowerControlManager is bpc {
	@undocumented
	[0] ShutdownSystem();
	@undocumented
	[1] RebootSystem();
	@undocumented
	[2] GetWakeupReason() -> unknown<4>;
	@undocumented
	[3] GetShutdownReason() -> unknown<4>;
	@undocumented
	[4] GetAcOk() -> unknown<1>;
	@undocumented
	[5] GetBoardPowerControlEvent(unknown<4>) -> handle<copy>;
	@undocumented
	[6] GetSleepButtonState() -> unknown<4>;
	@undocumented
	[7] GetPowerEvent(unknown<4>) -> handle<copy>;
	@undocumented
	[8] Unknown8(unknown<8>) -> unknown<4>;
	@undocumented
	[9] Unknown9(unknown<4>);
	@undocumented
	[10] Unknown10() -> unknown<0xc>;
}

interface nn::bpc::IRtcManager is bpc:r {
	@undocumented
	[0] GetExternalRtcValue() -> unknown<8>;
	@undocumented
	[1] SetExternalRtcValue(unknown<8>);
	@undocumented
	[2] ReadExternalRtcResetFlag() -> unknown<1>;
	@undocumented
	[3] ClearExternalRtcResetFlag();
}

interface nn::bsdsocket::cfg::ServerInterface is bsdcfg {
	@undocumented
	[0] SetIfUp(unknown<0x2c>, buffer<unknown,5>);
	@undocumented
	[1] SetIfUpWithEvent(unknown<0x2c>, buffer<unknown,5>) -> handle<copy>;
	@undocumented
	[2] CancelIf(buffer<unknown,5>);
	@undocumented
	[3] SetIfDown(unknown<4>, buffer<unknown,5>);
	@undocumented
	[4] GetIfState(buffer<unknown,5>) -> buffer<unknown,6>;
	@undocumented
	[5] DhcpRenew(buffer<unknown,5>);
	@undocumented
	[6] AddStaticArpEntry(unknown<4>, buffer<unknown,5>);
	@undocumented
	[7] RemoveArpEntry(unknown<4>);
	@undocumented
	[8] LookupArpEntry(unknown<4>) -> buffer<unknown,6>;
	@undocumented
	[9] LookupArpEntry2(buffer<unknown,5>) -> buffer<unknown,6>;
	@undocumented
	[10] ClearArpEntries();
	@undocumented
	[11] ClearArpEntries2(buffer<unknown,5>);
	@undocumented
	[12] PrintArpEntries();
}

interface nn::btm::IBtm is btm {
	@undocumented
	[0] Unknown0() -> unknown<4>;
	@undocumented
	[1] Unknown1() -> unknown<0x2a>;
	@undocumented
	[2] RegisterSystemEventForConnectedDeviceConditionImpl() -> (unknown<1>, handle<copy>);
	@undocumented
	[3] Unknown3() -> buffer<unknown,0x1a>;
	@undocumented
	[4] Unknown4(unknown<7>);
	@undocumented
	[5] Unknown5(buffer<unknown,0x19>);
	@undocumented
	[6] Unknown6(unknown<4>);
	@undocumented
	[7] Unknown7(unknown<4>);
	@undocumented
	[8] RegisterSystemEventForRegisteredDeviceInfoImpl() -> (unknown<1>, handle<copy>);
	@undocumented
	[9] Unknown9() -> buffer<unknown,0x1a>;
	@undocumented
	[10] Unknown10(unknown<0x60>);
	@undocumented
	[11] Unknown11(unknown<6>);
	@undocumented
	[12] Unknown12(unknown<6>);
	@undocumented
	[13] Unknown13(unknown<6>);
	@undocumented
	[14] EnableRadioImpl();
	@undocumented
	[15] DisableRadioImpl();
	@undocumented
	[16] Unknown16(unknown<6>);
	@undocumented
	[17] Unknown17(unknown<6>, buffer<unknown,0x19>);
	@version(2.0.0+)
	@undocumented
	[18] Unknown18() -> (unknown<1>, handle<copy>);
	@version(4.0.0+)
	@undocumented
	[19] Unknown19() -> (unknown<1>, handle<copy>);
	@version(4.0.0+)
	@undocumented
	[20] Unknown20() -> unknown<1>;
	@version(4.0.0+)
	@undocumented
	[21] Unknown21(unknown<1>);
}

interface nn::btm::IBtmDebug is btm:dbg {
	@undocumented
	[0] RegisterSystemEventForDiscoveryImpl() -> (unknown<1>, handle<copy>);
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3() -> buffer<unknown,0x1a>;
	@undocumented
	[4] Unknown4(unknown<6>);
	@undocumented
	[5] Unknown5(unknown<6>);
	@undocumented
	[6] Unknown6(unknown<0xc>);
	@undocumented
	[7] Unknown7(unknown<4>);
	@undocumented
	[8] Unknown8(unknown<6>);
}

interface nn::btm::IBtmSystem is btm:sys {
	@undocumented
	[0] GetCoreImpl() -> object<nn::btm::IBtmSystemCore>;
}

interface nn::btm::IBtmSystemCore {
	@undocumented
	[0] StartGamepadPairingImpl();
	@undocumented
	[1] CancelGamepadPairingImpl();
	@undocumented
	[2] ClearGamepadPairingDatabaseImpl();
	@undocumented
	[3] GetPairedGamepadCountImpl() -> unknown<1>;
	@undocumented
	[4] EnableRadioImpl();
	@undocumented
	[5] DisableRadioImpl();
	@undocumented
	[6] GetRadioOnOffImpl() -> unknown<1>;
	@version(2.0.0+)
	@undocumented
	[7] AcquireRadioEventImpl() -> (unknown<1>, handle<copy>);
	@version(2.0.0+)
	@undocumented
	[8] AcquireGamepadPairingEventImpl() -> (unknown<1>, handle<copy>);
	@version(2.0.0+)
	@undocumented
	[9] IsGamepadPairingStartedImpl() -> unknown<1>;
}

interface nn::capsrv::sf::IAlbumAccessorApplicationSession {
	@undocumented
	[2001] OpenAlbumMovieReadStream(unknown) -> unknown;
	@undocumented
	[2002] CloseAlbumMovieReadStream(unknown) -> unknown;
	@undocumented
	[2003] GetAlbumMovieReadStreamMovieDataSize(unknown) -> unknown;
	@undocumented
	[2004] ReadMovieDataFromAlbumMovieReadStream(unknown) -> unknown;
	@undocumented
	[2005] GetAlbumMovieReadStreamBrokenReason(unknown) -> unknown;
}

interface nn::capsrv::sf::IAlbumAccessorService is caps:a {
	@undocumented
	[0] Unknown0(unknown<1>) -> unknown<8>;
	@undocumented
	[1] Unknown1(unknown<1>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[2] Unknown2(unknown<0x18>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[3] Unknown3(unknown<0x18>);
	@undocumented
	[4] Unknown4(unknown<0x20>);
	@undocumented
	[5] Unknown5(unknown<1>) -> unknown<1>;
	@undocumented
	[6] Unknown6(unknown<1>) -> unknown<0x30>;
	@undocumented
	[7] Unknown7(unknown<0x18>) -> unknown<8>;
	@undocumented
	[8] Unknown8(unknown<0x18>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[9] Unknown9(unknown<0x18>) -> (unknown<0x10>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[10] Unknown10(unknown<0x18>) -> (unknown<0x10>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[11] Unknown11(unknown<0x28>) -> unknown<0x20>;
	@undocumented
	[12] Unknown12(unknown<0x38>) -> (unknown<0x10>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[13] Unknown13(unknown<0x38>) -> (unknown<0x10>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[14] Unknown14(unknown<0x38>) -> (unknown<0x50>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[301] Unknown301() -> (unknown<0x20>, buffer<unknown,6>);
	@undocumented
	[401] Unknown401() -> unknown<1>;
	@undocumented
	[501] Unknown501(unknown<2>) -> unknown<8>;
	@undocumented
	[1001] Unknown1001(unknown<0x38>) -> (unknown<0x50>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[1002] Unknown1002(unknown<0x38>) -> (buffer<unknown,0x16>, buffer<unknown,0x46>, buffer<unknown,6>);
	@undocumented
	[8001] Unknown8001(unknown<1>);
	@undocumented
	[8002] Unknown8002(unknown<1>);
	@undocumented
	[8011] Unknown8011(unknown<1>);
	@undocumented
	[8012] Unknown8012(unknown<1>) -> unknown<0x10>;
	@undocumented
	[8021] Unknown8021(unknown<0x28>, pid) -> unknown<0x20>;
	@undocumented
	[10011] Unknown10011(unknown<1>);
}

interface nn::capsrv::sf::IAlbumApplicationService is caps:u {
	@undocumented
	[102] GetAlbumFileListByAruid(unknown) -> unknown;
	@undocumented
	[103] DeleteAlbumFileByAruid(unknown) -> unknown;
	@undocumented
	[104] GetAlbumFileSizeByAruid(unknown) -> unknown;
	@undocumented
	[110] LoadAlbumScreenShotImageByAruid(unknown) -> unknown;
	@undocumented
	[120] LoadAlbumScreenShotThumbnailImageByAruid(unknown) -> unknown;
	@undocumented
	[60002] OpenAccessorSessionForApplication(unknown) -> unknown;
}

interface nn::capsrv::sf::IAlbumControlService is caps:c {
	@undocumented
	[2001] Unknown2001(unknown<1>);
	@undocumented
	[2002] Unknown2002(unknown<1>);
	@undocumented
	[2011] Unknown2011(unknown<0x10>);
	@undocumented
	[2012] Unknown2012(unknown<0x10>);
	@undocumented
	[2013] Unknown2013(unknown<8>) -> unknown<8>;
	@undocumented
	[2014] Unknown2014(unknown<8>);
	@undocumented
	[2101] Unknown2101(unknown<0x10>) -> unknown<0x18>;
	@undocumented
	[2102] Unknown2102(unknown<0x28>) -> unknown<0x20>;
	@undocumented
	[2201] Unknown2201(unknown<0x18>, buffer<unknown,0x45>);
	@undocumented
	[2301] Unknown2301(unknown<0x18>, buffer<unknown,0x45>);
}

interface nn::capsrv::sf::IScreenShotApplicationService is caps:su {
	[201] SaveScreenShot(u32, u32, nn::applet::AppletResourceUserId, pid, buffer<bytes,0x45>) -> nn::capsrv::ApplicationAlbumEntry;
	[203] SaveScreenShotEx0(nn::capsrv::detail::ScreenShotAttributeEx0, u32, nn::applet::AppletResourceUserId, pid, buffer<bytes,0x45>) -> nn::capsrv::ApplicationAlbumEntry;
}

interface nn::capsrv::sf::IScreenShotControlService is caps:sc {
	@undocumented
	[1] Unknown1(unknown<0x28>) -> buffer<unknown,0x46>;
	@undocumented
	[2] Unknown2(unknown<0x30>) -> buffer<unknown,0x46>;
	@undocumented
	[1001] Unknown1001(unknown<0x10>);
	@undocumented
	[1002] Unknown1002(unknown<0x18>);
	@undocumented
	[1003] Unknown1003(unknown<0x58>);
	@undocumented
	[1011] Unknown1011(unknown<8>);
	@undocumented
	[1012] Unknown1012(unknown<8>);
	@undocumented
	[1201] Unknown1201(unknown<0x10>) -> unknown<0x18>;
	@undocumented
	[1202] Unknown1202();
	@undocumented
	[1203] Unknown1203(unknown<8>) -> (unknown<8>, buffer<unknown,6>);
}

interface nn::capsrv::sf::IScreenShotService is caps:ss {
	@undocumented
	[201] Unknown201(unknown<0x10>, pid, buffer<unknown,0x45>) -> unknown<0x20>;
	@undocumented
	[202] Unknown202(unknown<0x38>, buffer<unknown,0x45>, buffer<unknown,0x45>) -> unknown<0x20>;
	@undocumented
	[203] Unknown203(unknown<0x50>, pid, buffer<unknown,0x45>) -> unknown<0x20>;
	@undocumented
	[204] Unknown204(unknown<0x78>, buffer<unknown,0x45>, buffer<unknown,0x45>) -> unknown<0x20>;
}

interface nn::cec::ICecManager is cec-mgr {
	@undocumented
	[0] Unknown0() -> (unknown<8>, handle<copy>);
	@undocumented
	[1] Unknown1(unknown<4>) -> unknown<4>;
	@undocumented
	[2] Unknown2(unknown<4>);
	@undocumented
	[3] Unknown3(unknown<0x18>) -> unknown<4>;
	@undocumented
	[4] Unknown4(unknown<4>) -> unknown<0x18>;
	@undocumented
	[5] Unknown5() -> unknown<0x20>;
	@undocumented
	[6] Unknown6() -> unknown<8>;
}

interface nn::codec::detail::IHardwareOpusDecoder {
	# Takes a type-5 input buffer (**OpusDataIn**) and a type-6 output buffer
	# (**PcmDataOut**). Decodes the Opus source data to PCM and returns two
	# u32s **DecodedSampleCount** and **DecodedDataSize**.
	# 
	[0] DecodeInterleaved(buffer<unknown,5>) -> (u32, u32, buffer<unknown,6>);
	# Takes a type-5 input buffer (**DecoderContextIn**). Sends the unknown
	# context data to the hardware decoder.
	# 
	[1] SetContext(buffer<unknown,5>);
	@version(3.0.0+)
	[2] Unknown2(buffer<unknown,5>) -> (u32, u32, buffer<unknown,6>);
	@version(3.0.0+)
	[3] Unknown3(buffer<unknown,5>);
	@version(4.0.0+)
	[4] Unknown4(buffer<unknown,5>) -> (u32, u32, u64, buffer<unknown,0x46>);
	@version(4.0.0+)
	[5] Unknown5(buffer<unknown,5>) -> (u32, u32, u64, buffer<unknown,0x46>);
}

interface nn::codec::detail::IHardwareOpusDecoderManager is hwopus {
	# Takes two u32s **SampleRate** and **ChannelCount** packed as an u64, an
	# u32 **WorkBufferSize** and a TransferMemory handle for **WorkBuffer**.
	# Returns an
	# [\#IHardwareOpusDecoder](#nn::codec::detail::IHardwareOpusDecoder "wikilink")
	# object. The TransferMemory is created by the user-process with
	# permissions=0.
	# 
	[0] Initialize(bytes<8,4>, u32, handle<copy>) -> object<nn::codec::detail::IHardwareOpusDecoder>;
	# Takes two u32s **SampleRate** and **ChannelCount** packed as an u64.
	# Returns the required size for the decoder's work buffer.
	# 
	[1] GetWorkBufferSize(bytes<8,4>) -> u32;
	@version(3.0.0+)
	[2] InitializeMultiStream(u32, handle<copy>, buffer<unknown<0x110>,0x19>) -> object<nn::codec::detail::IHardwareOpusDecoder>;
	@version(3.0.0+)
	[3] GetWorkBufferSizeMultiStream(buffer<unknown<0x110>,0x19>) -> u32;
}

interface nn::dmnt::IInterface is dmnt:- {
	@undocumented
	[0] BreakDebugProcess(unknown) -> unknown;
	@undocumented
	[1] TerminateDebugProcess(unknown) -> unknown;
	@undocumented
	[2] CloseHandle(unknown) -> unknown;
	@undocumented
	[3] LoadImage(unknown) -> unknown;
	@undocumented
	[4] GetProcessId(unknown) -> unknown;
	@undocumented
	[5] GetProcessHandle(unknown) -> unknown;
	@undocumented
	[6] WaitSynchronization(unknown) -> unknown;
	@undocumented
	[7] GetDebugEvent(unknown) -> unknown;
	@undocumented
	[8] GetProcessModuleInfo(unknown) -> unknown;
	@undocumented
	[9] GetProcessList(unknown) -> unknown;
	@undocumented
	[10] GetThreadList(unknown) -> unknown;
	@undocumented
	[11] GetDebugThreadContext(unknown) -> unknown;
	@undocumented
	[12] ContinueDebugEvent(unknown) -> unknown;
	@undocumented
	[13] ReadDebugProcessMemory(unknown) -> unknown;
	@undocumented
	[14] WriteDebugProcessMemory(unknown) -> unknown;
	@undocumented
	[15] SetDebugThreadContext(unknown) -> unknown;
	@undocumented
	[16] GetDebugThreadParam(unknown) -> unknown;
	@undocumented
	[17] InitializeThreadInfo(unknown) -> unknown;
	@undocumented
	[18] SetHardwareBreakPoint(unknown) -> unknown;
	@undocumented
	[19] QueryDebugProcessMemory(unknown) -> unknown;
	@undocumented
	[20] GetProcessMemoryDetails(unknown) -> unknown;
	@undocumented
	[21] AttachByProgramId(unknown) -> unknown;
	@undocumented
	[22] AttachOnLaunch(unknown) -> unknown;
	@undocumented
	[23] GetDebugMonitorProcessId(unknown) -> unknown;
	@undocumented
	[25] GetJitDebugProcessList(unknown) -> unknown;
	@undocumented
	[26] CreateCoreDump(unknown) -> unknown;
	@undocumented
	[27] GetAllDebugThreadInfo(unknown) -> unknown;
	@undocumented
	[29] TargetIO_FileOpen(unknown) -> unknown;
	@undocumented
	[30] TargetIO_FileClose(unknown) -> unknown;
	@undocumented
	[31] TargetIO_FileRead(unknown) -> unknown;
	@undocumented
	[32] TargetIO_FileWrite(unknown) -> unknown;
	@undocumented
	[33] TargetIO_FileSetAttributes(unknown) -> unknown;
	@undocumented
	[34] TargetIO_FileGetInformation(unknown) -> unknown;
	@undocumented
	[35] TargetIO_FileSetTime(unknown) -> unknown;
	@undocumented
	[36] TargetIO_FileSetSize(unknown) -> unknown;
	@undocumented
	[37] TargetIO_FileDelete(unknown) -> unknown;
	@undocumented
	[38] TargetIO_FileMove(unknown) -> unknown;
	@undocumented
	[39] TargetIO_DirectoryCreate(unknown) -> unknown;
	@undocumented
	[40] TargetIO_DirectoryDelete(unknown) -> unknown;
	@undocumented
	[41] TargetIO_DirectoryRename(unknown) -> unknown;
	@undocumented
	[42] TargetIO_DirectoryGetCount(unknown) -> unknown;
	@undocumented
	[43] TargetIO_DirectoryOpen(unknown) -> unknown;
	@undocumented
	[44] TargetIO_DirectoryGetNext(unknown) -> unknown;
	@undocumented
	[45] TargetIO_DirectoryClose(unknown) -> unknown;
	@undocumented
	[46] TargetIO_GetFreeSpace(unknown) -> unknown;
	@undocumented
	[47] TargetIO_GetVolumeInformation(unknown) -> unknown;
	@undocumented
	[48] InitiateCoreDump(unknown) -> unknown;
	@undocumented
	[49] ContinueCoreDump(unknown) -> unknown;
	@undocumented
	[50] AddTTYToCoreDump(unknown) -> unknown;
	@undocumented
	[51] AddImageToCoreDump(unknown) -> unknown;
	@undocumented
	[52] CloseCoreDump(unknown) -> unknown;
}

interface nn::erpt::sf::IContext is erpt:c {
	@undocumented
	[0] SubmitContext(buffer<unknown,5>, buffer<unknown,5>);
	@undocumented
	[1] CreateReport(unknown<4>, buffer<unknown,5>, buffer<unknown,5>, buffer<unknown,5>);
	@version(3.0.0+)
	@undocumented
	[2] Unknown2(unknown<0x18>);
	@version(3.0.0+)
	@undocumented
	[3] Unknown3();
	@version(3.0.0+)
	@undocumented
	[4] Unknown4();
	@version(3.0.0+)
	@undocumented
	[5] Unknown5();
	@version(5.0.0+)
	@undocumented
	[6] Unknown6(unknown) -> unknown;
}

interface nn::erpt::sf::IManager {
	@undocumented
	[0] GetReportList(unknown<4>) -> buffer<unknown,6>;
	@undocumented
	[1] GetEvent() -> handle<copy>;
	@version(4.0.0+)
	@undocumented
	[2] Unknown2();
	@version(5.0.0+)
	@undocumented
	[3] Unknown3(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[4] Unknown4(unknown) -> unknown;
}

interface nn::erpt::sf::IReport {
	@undocumented
	[0] Open(unknown<0x14>);
	@undocumented
	[1] Read() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[2] SetFlags(unknown<4>);
	@undocumented
	[3] GetFlags() -> unknown<4>;
	@undocumented
	[4] Close();
	@undocumented
	[5] GetSize() -> unknown<8>;
}

interface nn::erpt::sf::ISession is erpt:r {
	@undocumented
	[0] OpenReport() -> object<nn::erpt::sf::IReport>;
	@undocumented
	[1] OpenManager() -> object<nn::erpt::sf::IManager>;
}

interface nn::es::IETicketService is es {
	@undocumented
	[1] ImportTicket(buffer<unknown,5>, buffer<unknown,5>);
	@undocumented
	[2] ImportTicketCertificateSet(buffer<unknown,5>);
	@undocumented
	[3] DeleteTicket(buffer<unknown,5>);
	@undocumented
	[4] DeletePersonalizedTicket(unknown<4>);
	@undocumented
	[5] DeleteAllCommonTicket();
	@undocumented
	[6] DeleteAllPersonalizedTicket();
	@undocumented
	[7] DeleteAllPersonalizedTicketEx(buffer<unknown,5>);
	@version(2.0.0-5.1.0)
	@undocumented
	[8] GetTitleKey(unknown<0x14>) -> buffer<unknown,0x16>;
	@undocumented
	[9] CountCommonTicket() -> unknown<4>;
	@undocumented
	[10] CountPersonalizedTicket() -> unknown<4>;
	@undocumented
	[11] ListCommonTicket() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[12] ListPersonalizedTicket() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[13] ListMissingPersonalizedTicket(buffer<unknown,5>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[14] GetCommonTicketSize(unknown<0x10>) -> unknown<8>;
	@version(2.0.0-5.1.0)
	@undocumented
	[15] GetPersonalizedTicketSize(unknown<0x10>) -> unknown<8>;
	@undocumented
	[16] GetCommonTicketData(unknown<0x10>) -> (unknown<8>, buffer<unknown,6>);
	@version(2.0.0-5.1.0)
	@undocumented
	[17] GetPersonalizedTicketData(unknown<0x10>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[18] OwnTicket(buffer<unknown,5>) -> buffer<unknown,6>;
	@undocumented
	[19] GetTicketInfo(buffer<unknown,5>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[20] ListLightTicketInfo(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@version(2.0.0+)
	@undocumented
	[21] SignData(buffer<unknown,5>) -> (buffer<unknown,0x16>, buffer<unknown,0x16>);
	@version(4.0.0+)
	@undocumented
	[22] GetCommonTicketAndCertificateSize(unknown<0x10>) -> unknown<0x10>;
	@version(4.0.0+)
	@undocumented
	[23] GetCommonTicketAndCertificateData(unknown<0x10>) -> (unknown<0x10>, buffer<unknown,6>, buffer<unknown,6>);
	@version(4.0.0+)
	@undocumented
	[24] ImportPrepurchaseRecord(buffer<unknown,0x15>);
	@version(4.0.0+)
	@undocumented
	[25] DeletePrepurchaseRecord(buffer<unknown,0x15>);
	@version(4.0.0+)
	@undocumented
	[26] DeleteAllPrepurchaseRecord();
	@version(4.0.0+)
	@undocumented
	[27] CountPrepurchaseRecord() -> unknown<4>;
	@version(4.0.0+)
	@undocumented
	[28] ListPrepurchaseRecord() -> (unknown<4>, buffer<unknown,6>);
	@version(4.0.0+)
	@undocumented
	[29] ListPrepurchaseRecordInfo(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@version(5.0.0+)
	@undocumented
	[30] Unknown30(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[31] Unknown31(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[32] Unknown32(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[33] Unknown33(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[34] Unknown34(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[35] Unknown35(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[36] Unknown36(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[501] Unknown501(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[502] Unknown502(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[503] GetTitleKey(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[504] Unknown504(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[508] Unknown508(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[509] Unknown509(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[510] Unknown510(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1001] Unknown1001(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1002] Unknown1002(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1003] Unknown1003(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1004] Unknown1004(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1005] Unknown1005(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1006] Unknown1006(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1007] Unknown1007(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1009] Unknown1009(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1010] Unknown1010(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1011] Unknown1011(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1012] Unknown1012(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1013] Unknown1013(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1014] Unknown1014(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1015] Unknown1015(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1016] Unknown1016(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1501] Unknown1501(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1502] Unknown1502(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1503] Unknown1503(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1504] Unknown1504(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1505] Unknown1505(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2000] Unknown2000(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2501] Unknown2501(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2502] Unknown2502(unknown) -> unknown;
}

interface nn::eth::sf::IEthInterface is ethc:c {
	@undocumented
	[0] Initialize(buffer<unknown,5>) -> handle<copy>;
	@undocumented
	[1] Cancel();
	@undocumented
	[2] GetResult();
	@undocumented
	[3] GetMediaList() -> buffer<unknown,6>;
	@undocumented
	[4] SetMediaType(unknown<4>);
	@undocumented
	[5] GetMediaType() -> unknown<0xc>;
}

interface nn::eth::sf::IEthInterfaceGroup is ethc:i {
	@undocumented
	[0] GetReadableHandle() -> handle<copy>;
	@undocumented
	[1] Cancel();
	@undocumented
	[2] GetResult();
	@undocumented
	[3] GetInterfaceList() -> buffer<unknown,6>;
	@undocumented
	[4] GetInterfaceCount() -> unknown<4>;
}

interface nn::eupld::sf::IControl is eupld:c {
	@undocumented
	[0] SetUrl(buffer<unknown,5>);
	@undocumented
	[1] ImportCrt(buffer<unknown,5>);
	@undocumented
	[2] ImportPki(buffer<unknown,5>, buffer<unknown,5>);
	@undocumented
	[3] SetAutoUpload(unknown<8>);
}

interface nn::eupld::sf::IRequest is eupld:r {
	@undocumented
	[0] Initialize() -> handle<copy>;
	@undocumented
	[1] UploadAll();
	@undocumented
	[2] UploadSelected(buffer<unknown,5>);
	@undocumented
	[3] GetUploadStatus() -> buffer<unknown,6>;
	@undocumented
	[4] CancelUpload();
	@undocumented
	[5] GetResult();
}

interface nn::fan::detail::IManager is fan {
	@undocumented
	[0] Unknown0(unknown<4>) -> object<nn::fan::detail::IController>;
	@undocumented
	[1] Unknown1(unknown) -> unknown;
	@undocumented
	[2] Unknown2(unknown) -> unknown;
	@undocumented
	[3] Unknown3(unknown) -> unknown;
	@undocumented
	[4] Unknown4(unknown) -> unknown;
	@undocumented
	[5] Unknown5(unknown) -> unknown;
	@undocumented
	[6] Unknown6(unknown) -> unknown;
	@undocumented
	[7] Unknown7(unknown) -> unknown;
}

interface nn::fatalsrv::IPrivateService is fatal:p {
	@undocumented
	[0] GetFatalEvent() -> handle<copy>;
}

interface nn::fatalsrv::IService is fatal:u {
	@undocumented
	[0] ThrowFatal(unknown<0x10>, pid);
	@undocumented
	[1] ThrowFatalWithPolicy(unknown<0x10>, pid);
	# Takes an input u64 errorcode and an unknown u64(TID maybe?). It also
	# takes a type-0x15 error buffer and a pid-descriptor. The error buffer
	# contains a stack trace. The stack trace address count is stored at
	# errorbuffer+0x240 and the addresses are stored at errorbuffer+0x130+i\*8
	# where i = 0-\>address count
	# 
	@undocumented
	[2] ThrowFatalWithCpuContext(unknown<0x10>, pid, buffer<unknown,0x15>);
}

interface nn::fgm::sf::IDebugger is fgm:dbg {
	[0] Initialize(u64, handle<copy>) -> handle<copy>;
	[1] Read() -> (u32, u32, u32, buffer<bytes,6>);
	[2] Cancel();
}

interface nn::fgm::sf::IRequest {
	[0] Initialize(nn::fgm::Module, u64, pid) -> handle<copy>;
	[1] Set(u32, u32);
	[2] Get() -> u32;
	[3] Cancel();
}

interface nn::fgm::sf::ISession is fgm, fgm:0, fgm:9 {
	[0] Initialize() -> object<nn::fgm::sf::IRequest>;
}

interface nn::friends::detail::ipc::IFriendService {
	[0] GetCompletionEvent() -> handle<copy>;
	[1] Cancel();
	[10100] GetFriendListIds(u32, nn::account::Uid, nn::friends::detail::ipc::SizedFriendFilter, u64, pid) -> (u32, buffer<nn::account::NetworkServiceAccountId,0xa>);
	[10101] GetFriendList(u32, nn::account::Uid, nn::friends::detail::ipc::SizedFriendFilter, u64, pid) -> (u32, buffer<nn::friends::detail::FriendImpl,6>);
	[10102] UpdateFriendInfo(nn::account::Uid, u64, pid, buffer<nn::account::NetworkServiceAccountId,9>) -> buffer<nn::friends::detail::FriendImpl,6>;
	[10110] GetFriendProfileImage(nn::account::Uid, nn::account::NetworkServiceAccountId) -> (u32, buffer<bytes,6>);
	[10200] SendFriendRequestForApplication(nn::account::Uid, nn::account::NetworkServiceAccountId, u64, pid, buffer<nn::friends::InAppScreenName,0x19>, buffer<nn::friends::InAppScreenName,0x19>);
	[10211] AddFacedFriendRequestForApplication(nn::friends::FacedFriendRequestRegistrationKey, nn::account::Nickname, nn::account::Uid, u64, pid, buffer<nn::friends::InAppScreenName,0x19>, buffer<nn::friends::InAppScreenName,0x19>, buffer<bytes,5>);
	[10400] GetBlockedUserListIds(u32, nn::account::Uid) -> (u32, buffer<nn::account::NetworkServiceAccountId,0xa>);
	[10500] GetProfileList(nn::account::Uid, buffer<nn::account::NetworkServiceAccountId,9>) -> buffer<nn::friends::detail::ProfileImpl,6>;
	[10600] DeclareOpenOnlinePlaySession(nn::account::Uid);
	[10601] DeclareCloseOnlinePlaySession(nn::account::Uid);
	[10610] UpdateUserPresence(nn::account::Uid, u64, pid, buffer<nn::friends::detail::UserPresenceImpl,0x19>);
	[10700] GetPlayHistoryRegistrationKey(b8, nn::account::Uid) -> buffer<nn::friends::PlayHistoryRegistrationKey,0x1a>;
	[10701] GetPlayHistoryRegistrationKeyWithNetworkServiceAccountId(b8, nn::account::NetworkServiceAccountId) -> buffer<nn::friends::PlayHistoryRegistrationKey,0x1a>;
	[10702] AddPlayHistory(nn::account::Uid, u64, pid, buffer<nn::friends::PlayHistoryRegistrationKey,0x19>, buffer<nn::friends::InAppScreenName,0x19>, buffer<nn::friends::InAppScreenName,0x19>);
	[11000] GetProfileImageUrl(nn::friends::Url, u32) -> nn::friends::Url;
	[20100] GetFriendCount(nn::account::Uid, nn::friends::detail::ipc::SizedFriendFilter, u64, pid) -> u32;
	[20101] GetNewlyFriendCount(nn::account::Uid) -> u32;
	[20102] GetFriendDetailedInfo(nn::account::Uid, nn::account::NetworkServiceAccountId) -> buffer<nn::friends::detail::FriendDetailedInfoImpl,0x1a>;
	[20103] SyncFriendList(nn::account::Uid);
	[20104] RequestSyncFriendList(nn::account::Uid);
	[20110] LoadFriendSetting(nn::account::Uid, nn::account::NetworkServiceAccountId) -> buffer<nn::friends::detail::FriendSettingImpl,0x1a>;
	[20200] GetReceivedFriendRequestCount(nn::account::Uid) -> (u32, u32);
	[20201] GetFriendRequestList(u32, u32, nn::account::Uid) -> (u32, buffer<nn::friends::detail::FriendRequestImpl,6>);
	[20300] GetFriendCandidateList(u32, nn::account::Uid) -> (u32, buffer<nn::friends::detail::FriendCandidateImpl,6>);
	[20301] GetNintendoNetworkIdInfo(u32, nn::account::Uid) -> (u32, buffer<nn::friends::NintendoNetworkIdUserInfo,0x1a>, buffer<nn::friends::detail::NintendoNetworkIdFriendImpl,6>);
	@version(5.0.0+)
	@undocumented
	[20302] GetSnsAccountLinkage(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[20303] GetSnsAccountProfile(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[20304] GetSnsAccountFriendList(unknown) -> unknown;
	[20400] GetBlockedUserList(u32, nn::account::Uid) -> (u32, buffer<nn::friends::detail::BlockedUserImpl,6>);
	[20401] SyncBlockedUserList(nn::account::Uid);
	[20500] GetProfileExtraList(nn::account::Uid, buffer<nn::account::NetworkServiceAccountId,9>) -> buffer<nn::friends::detail::ProfileExtraImpl,6>;
	[20501] GetRelationship(nn::account::Uid, nn::account::NetworkServiceAccountId) -> nn::friends::Relationship;
	[20600] GetUserPresenceView(nn::account::Uid) -> buffer<nn::friends::detail::UserPresenceViewImpl,0x1a>;
	[20700] GetPlayHistoryList(u32, nn::account::Uid) -> (u32, buffer<nn::friends::detail::PlayHistoryImpl,6>);
	[20701] GetPlayHistoryStatistics(nn::account::Uid) -> nn::friends::PlayHistoryStatistics;
	[20800] LoadUserSetting(nn::account::Uid) -> buffer<nn::friends::detail::UserSettingImpl,0x1a>;
	[20801] SyncUserSetting(nn::account::Uid);
	[20900] RequestListSummaryOverlayNotification();
	[21000] GetExternalApplicationCatalog(nn::settings::LanguageCode, nn::friends::ExternalApplicationCatalogId) -> buffer<nn::friends::ExternalApplicationCatalog,0x1a>;
	[30100] DropFriendNewlyFlags(nn::account::Uid);
	[30101] DeleteFriend(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30110] DropFriendNewlyFlag(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30120] ChangeFriendFavoriteFlag(b8, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30121] ChangeFriendOnlineNotificationFlag(b8, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30200] SendFriendRequest(u32, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30201] SendFriendRequestWithApplicationInfo(u32, nn::account::Uid, nn::account::NetworkServiceAccountId, nn::friends::ApplicationInfo, buffer<nn::friends::InAppScreenName,0x19>, buffer<nn::friends::InAppScreenName,0x19>);
	[30202] CancelFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30203] AcceptFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30204] RejectFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30205] ReadFriendRequest(nn::account::Uid, nn::friends::RequestId);
	[30210] GetFacedFriendRequestRegistrationKey(nn::account::Uid) -> nn::friends::FacedFriendRequestRegistrationKey;
	[30211] AddFacedFriendRequest(nn::friends::FacedFriendRequestRegistrationKey, nn::account::Nickname, nn::account::Uid, buffer<bytes,5>);
	[30212] CancelFacedFriendRequest(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30213] GetFacedFriendRequestProfileImage(nn::account::Uid, nn::account::NetworkServiceAccountId) -> (u32, buffer<bytes,6>);
	[30214] GetFacedFriendRequestProfileImageFromPath(buffer<u8,9>) -> (u32, buffer<bytes,6>);
	[30215] SendFriendRequestWithExternalApplicationCatalogId(u32, nn::account::Uid, nn::account::NetworkServiceAccountId, nn::friends::ExternalApplicationCatalogId, buffer<nn::friends::InAppScreenName,0x19>, buffer<nn::friends::InAppScreenName,0x19>);
	[30216] ResendFacedFriendRequest(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30217] SendFriendRequestWithNintendoNetworkIdInfo(nn::friends::MiiName, nn::friends::MiiImageUrlParam, nn::friends::MiiName, nn::friends::MiiImageUrlParam, u32, nn::account::Uid, nn::account::NetworkServiceAccountId);
	@version(5.0.0+)
	@undocumented
	[30300] GetSnsAccountLinkPageUrl(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[30301] UnlinkSnsAccount(unknown) -> unknown;
	[30400] BlockUser(u32, nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30401] BlockUserWithApplicationInfo(u32, nn::account::Uid, nn::account::NetworkServiceAccountId, nn::friends::ApplicationInfo, buffer<nn::friends::InAppScreenName,0x19>);
	[30402] UnblockUser(nn::account::Uid, nn::account::NetworkServiceAccountId);
	[30500] GetProfileExtraFromFriendCode(nn::friends::FriendCode, nn::account::Uid) -> buffer<nn::friends::detail::ProfileExtraImpl,0x1a>;
	[30700] DeletePlayHistory(nn::account::Uid);
	[30810] ChangePresencePermission(u32, nn::account::Uid);
	[30811] ChangeFriendRequestReception(b8, nn::account::Uid);
	[30812] ChangePlayLogPermission(u32, nn::account::Uid);
	[30820] IssueFriendCode(nn::account::Uid);
	[30830] ClearPlayLog(nn::account::Uid);
	[49900] DeleteNetworkServiceAccountCache(nn::account::Uid);
}

interface nn::friends::detail::ipc::INotificationService {
	[0] GetEvent() -> handle<copy>;
	[1] Clear();
	[2] Pop() -> nn::friends::detail::ipc::SizedNotificationInfo;
}

interface nn::friends::detail::ipc::IServiceCreator is friend:u, friend:v, friend:m, friend:s, friend:a {
	[0] CreateFriendService() -> object<nn::friends::detail::ipc::IFriendService>;
	[1] CreateNotificationService(nn::account::Uid) -> object<nn::friends::detail::ipc::INotificationService>;
	@version(4.0.0+)
	[2] CreateDaemonSuspendSessionService() -> object<nn::friends::detail::ipc::IDaemonSuspendSessionService>;
}

interface nn::fssrv::sf::IDeviceOperator {
	[0] IsSdCardInserted() -> u8;
	[1] GetSdCardSpeedMode() -> u64;
	@version(2.0.0+)
	[2] GetSdCardCid(u64) -> buffer<unknown,6>;
	@version(2.0.0+)
	[3] GetSdCardUserAreaSize() -> u64;
	@version(2.0.0+)
	[4] GetSdCardProtectedAreaSize() -> u64;
	@version(2.0.0+)
	[5] GetAndClearSdCardErrorInfo(u64) -> (bytes<0x10,4>, u64, buffer<unknown,6>);
	[100] GetMmcCid(u64) -> buffer<unknown,6>;
	[101] GetMmcSpeedMode() -> u64;
	[110] EraseMmc(u32);
	[111] GetMmcPartitionSize(u32) -> u64;
	@version(2.0.0+)
	[112] GetMmcPatrolCount() -> u32;
	@version(2.0.0+)
	[113] GetAndClearMmcErrorInfo(u64) -> (bytes<0x10,4>, u64, buffer<unknown,6>);
	@version(2.0.0+)
	[114] GetMmcExtendedCsd(u64) -> buffer<unknown,6>;
	@version(4.0.0+)
	[115] SuspendMmcPatrol();
	@version(4.0.0+)
	[116] ResumeMmcPatrol();
	[200] IsGameCardInserted() -> u8;
	[201] EraseGameCard(u32, u64);
	[202] GetGameCardHandle() -> u32;
	# Returns a titleID and the title-version for it.
	# 
	#   - Output u32 with ARMS-gamecard: title-version v131162. This is the
	#     title-version for
	#     [2.1.0](http://switchbrew.org/index.php?title=2.1.0 "wikilink"),
	#     which is the sysupdate included with this gamecard. Launch-day
	#     gamecards return title-version v450.
	#   - Output u64 with ARMS-gamecard: titleID 0100000000000816.
	# 
	# [NS](http://switchbrew.org/index.php?title=NS_Services "wikilink")
	# appears to only use this with
	# [Content\_Manager\_services\#GetTitleIdInfo](http://switchbrew.org/index.php?title=Content_Manager_services#GetTitleIdInfo "wikilink")
	# and
	# [Content\_Manager\_services\#GetUpdateTitleList](http://switchbrew.org/index.php?title=Content_Manager_services#GetUpdateTitleList "wikilink")
	# with storageid=nandsys, for checking whether a sysupdate is required.
	# 
	[203] GetGameCardUpdatePartitionInfo(u32) -> (u32, u64);
	[204] FinalizeGameCardDriver();
	[205] GetGameCardAttribute(u32) -> u8;
	[206] GetGameCardDeviceCertificate(u32, u64) -> buffer<unknown,6>;
	[207] GetGameCardAsicInfo(u64, u64, buffer<unknown,5>) -> buffer<unknown,6>;
	[208] GetGameCardIdSet(u64) -> buffer<unknown,6>;
	[209] WriteToGameCard(u64, u64) -> buffer<unknown,6>;
	[210] SetVerifyWriteEnalbleFlag(u8);
	[211] GetGameCardImageHash(u32, u64) -> buffer<unknown,6>;
	@version(2.0.0+)
	[212] GetGameCardErrorInfo(u64, u64, buffer<unknown,5>) -> buffer<unknown,6>;
	@version(2.0.0+)
	[213] EraseAndWriteParamDirectly(u64, buffer<unknown,5>);
	@version(2.0.0+)
	[214] ReadParamDirectly(u64) -> buffer<unknown,6>;
	@version(2.0.0+)
	[215] ForceEraseGameCard();
	@version(2.0.0+)
	[216] GetGameCardErrorInfo2() -> bytes<0x10,2>;
	@version(2.1.0+)
	[217] GetGameCardErrorReportInfo() -> bytes<0x40,4>;
	@version(3.0.0+)
	[218] GetGameCardDeviceId(u64) -> buffer<unknown,6>;
	[300] SetSpeedEmulationMode(u32);
	[301] GetSpeedEmulationMode() -> u32;
	@version(5.0.0+)
	@undocumented
	[400] SuspendSdmmcControl(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[401] ResumeSdmmcControl(unknown) -> unknown;
}

interface nn::fssrv::sf::IDirectory {
	# Takes a type-0x6 output buffer. Returns an output u64(?) for the total
	# number of read entries, this is 0 when no more entries are available.
	# 
	# The output buffer contains the read array of
	# [\#DirectoryEntry](http://switchbrew.org/index.php?title=Filesystem%20services#DirectoryEntry "wikilink").
	# This doesn't include entries for "." and "..".
	# 
	[0] Read() -> (u64, buffer<unknown,6>);
	# Returns an u64 for the total number of readable entries.
	# 
	[1] GetEntryCount() -> u64;
}

interface nn::fssrv::sf::IEventNotifier {
	[0] GetEventHandle() -> handle<copy>;
}

interface nn::fssrv::sf::IFile {
	[0] Read(u32, u64, u64) -> (u64, buffer<unknown,0x46>);
	[1] Write(u32, u64, u64, buffer<unknown,0x45>);
	[2] Flush();
	[3] SetSize(u64);
	[4] GetSize() -> u64;
	@version(4.0.0+)
	[5] OperateRange(u32, u64, u64) -> bytes<0x40,4>;
}

interface nn::fssrv::sf::IFileSystem {
	[0] CreateFile(u32, u64, buffer<unknown<0x301>,0x19>);
	[1] DeleteFile(buffer<unknown<0x301>,0x19>);
	[2] CreateDirectory(buffer<unknown<0x301>,0x19>);
	[3] DeleteDirectory(buffer<unknown<0x301>,0x19>);
	[4] DeleteDirectoryRecursively(buffer<unknown<0x301>,0x19>);
	[5] RenameFile(buffer<unknown<0x301>,0x19>, buffer<unknown<0x301>,0x19>);
	[6] RenameDirectory(buffer<unknown<0x301>,0x19>, buffer<unknown<0x301>,0x19>);
	# Takes a type-0x9 input buffer for the path and returns
	# [\#DirectoryEntryType](http://switchbrew.org/index.php?title=Filesystem%20services#DirectoryEntryType "wikilink")
	# as an output u32.
	# 
	[7] GetEntryType(buffer<unknown<0x301>,0x19>) -> u32;
	# Takes a type-0x19 input buffer for the path, and an u32 **mode**.
	# **mode** controls how the file is opened, based on which bits are set:
	# 
	#   - When bit 0 is set, the file is Readable: you can use the Read
	#     operation.
	#   - When bit 1 is set, the file is Writable: you can use the Write
	#     operation.
	#   - When bit 2 is set, the file is Appendable: unless this bit is set,
	#     you will not be able to write beyond the end of a file (such writes
	#     will result in an error 0x307202)
	# 
	[8] OpenFile(u32, buffer<unknown<0x301>,0x19>) -> object<nn::fssrv::sf::IFile>;
	# Takes a type-0x9 input buffer for the path and an u64 **filter\_flags**.
	# **filter\_flags** controls what type of entries are read by the
	# [\#IDirectory](#nn::fssrv::sf::IDirectory "wikilink"): bitmask 0x1 =
	# directories, bitmask 0x2 = files.
	# 
	[9] OpenDirectory(u32, buffer<unknown<0x301>,0x19>) -> object<nn::fssrv::sf::IDirectory>;
	# Like
	# [3DS](http://switchbrew.org/index.php?title=https://3dbrew.org/wiki/FS:ControlArchive),
	# this has to be used after writing to savedata for the changes to take
	# affect.
	# 
	[10] Commit();
	# Takes a type-0x9 input buffer for the path and returns an output
	# byte-size u64 for the total free space with this FS.
	# 
	[11] GetFreeSpaceSize(buffer<unknown<0x301>,0x19>) -> u64;
	# Takes a type-0x9 input buffer for the path and returns an output
	# byte-size u64 for the total space available with this FS(free+used).
	# 
	[12] GetTotalSpaceSize(buffer<unknown<0x301>,0x19>) -> u64;
	# Takes a type-0x9 input buffer for the path and clears the contents of
	# the directory specified in the path.
	# 
	@version(3.0.0+)
	[13] CleanDirectoryRecursively(buffer<unknown<0x301>,0x19>);
	@version(3.0.0+)
	[14] GetFileTimeStampRaw(buffer<unknown<0x301>,0x19>) -> bytes<0x20,8>;
	@version(4.0.0+)
	[15] QueryEntry(u32, buffer<unknown<0x301>,0x19>, buffer<unknown,0x45>) -> buffer<unknown,0x46>;
}

interface nn::fssrv::sf::IFileSystemProxy is fsp-srv {
	# Takes a type-0x19 input buffer (ContentPath) and a
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# as parameters. Returns an
	# [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# \[2.0.0+\] This function was removed.
	# 
	@version(1.0.0)
	[0] OpenFileSystem(unknown<4>, buffer<unknown,0x19>) -> object<nn::fssrv::sf::IFileSystem>;
	# Takes a pid-descriptor.
	# 
	[1] SetCurrentProcess(u64, pid);
	[2] OpenDataFileSystemByCurrentProcess() -> object<nn::fssrv::sf::IFileSystem>;
	# Takes an input
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# and an u64 title-id. Returns an
	# [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Web-applet loads the
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# (which must be **ContentManual**) from u32\_table\[inparam\].
	# 
	# Note: web-applet strings refer to both this cmd and
	# [\#OpenFileSystemWithId](#nn::fssrv::sf::IFileSystemProxy\(8\) "wikilink")
	# as "MountContent", but official nn\_sf\_sync symbols use "OpenXX" names.
	# 
	@version(2.0.0+)
	[7] OpenFileSystemWithPatch(u32, u64) -> object<nn::fssrv::sf::IFileSystem>;
	# Takes a type-0x19 input buffer, an
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# and an u64 title-id. Returns an
	# [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# The [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink") must be
	# **ContentMeta** if the NCA type is 0 (control).
	# 
	# The input buffer is the output string path from
	# [GetApplicationContentPath](http://switchbrew.org/index.php?title=NS_Services#GetApplicationContentPath "wikilink").
	# 
	# May return errors when attempting to access NCA-paths for an
	# update-title with a gamecard, when the gamecard isn't inserted. May
	# return error 0x7D402 in some cases with update-titles. Non-val2 in32
	# values with NCA-type1 are unusable, even for normal titles.
	# 
	# The official "MountApplicationPackage" func uses this with in64=0 and
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# **ApplicationPackage**.
	# 
	# After the
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# specific permissions are checked, it then gets the func retval for
	# permissions-type 0x25 and func0.
	# 
	# When
	# [\#FileSystemType](http://switchbrew.org/index.php?title=Filesystem%20services#FileSystemType "wikilink")
	# is **ContentMeta**, it uses in64=0xffffffffffffffff internally,
	# otherwise it checks if in64 is set to 0xffffffffffffffff then throws an
	# error if so. When the in64 used internally is not 0xffffffffffffffff,
	# it's compared with the NCA titleID, then an error is thrown on mismatch.
	# 
	@version(2.0.0+)
	[8] OpenFileSystemWithId(u32, u64, buffer<unknown<0x301>,0x19>) -> object<nn::fssrv::sf::IFileSystem>;
	@version(3.0.0+)
	[9] OpenDataFileSystemByApplicationId(u64) -> object<nn::fssrv::sf::IFileSystem>;
	# Takes a type-0x19 input buffer string and a u32 [Bis
	# partitionID](http://switchbrew.org/index.php?title=Flash_Filesystem "wikilink").
	# Official user-process code sets instr\[0\] = 0 normally. Returns an
	# [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Only partitionIDs for FAT partitions are usable with this, otherwise
	# error 0x2EE202 is returned. Seems to be about the same as
	# [\#OpenBisStorage](#nn::fssrv::sf::IFileSystemProxy\(12\) "wikilink")
	# except this mounts the partition filesystem instead of allowing direct
	# access to the partition sectors.
	# 
	[11] OpenBisFileSystem(u32, buffer<unknown<0x301>,0x19>) -> object<nn::fssrv::sf::IFileSystem>;
	# Takes a u32 partition ID, returns 0x2EE202 for partitions which do not
	# exist, 0x320002 for partitions which cannot be opened and a valid
	# [\#IStorage](#nn::fssrv::sf::IStorage "wikilink") handle otherwise.
	# 
	[12] OpenBisStorage(u32) -> object<nn::fssrv::sf::IStorage>;
	[13] InvalidateBisCache();
	[17] OpenHostFileSystem(buffer<unknown<0x301>,0x19>) -> object<nn::fssrv::sf::IFileSystem>;
	[18] OpenSdCardFileSystem() -> object<nn::fssrv::sf::IFileSystem>;
	@version(2.0.0+)
	[19] FormatSdCardFileSystem();
	# Takes an input u64.
	# 
	[21] DeleteSaveDataFileSystem(u64);
	# Takes a 0x40-byte Save-struct entry, a 0x40-byte SaveCreate-struct
	# entry, and a 0x10-byte input struct.
	# 
	# Only the first 0x5-bytes in the 0x10-byte struct are initialized:
	# all-zero when automatically creating savedata during savecommon mount by
	# official user-processes. In the dedicated save-creation code in official
	# user-processes: +0 u32 = 0x40060, +4 u8 = 1.
	# 
	# Creates regular savedata.
	# 
	[22] CreateSaveDataFileSystem(bytes<0x40,8>, bytes<0x40,8>, bytes<0x10,4>);
	# Takes a 0x40-byte Save-struct entry and a 0x40-byte SaveCreate-struct
	# entry.
	# 
	# Creates savedata in the SYSTEM
	# [NAND](http://switchbrew.org/index.php?title=Flash_Filesystem "wikilink")
	# partition.
	# 
	[23] CreateSaveDataFileSystemBySystemSaveDataId(bytes<0x40,8>, bytes<0x40,8>);
	[24] RegisterSaveDataFileSystemAtomicDeletion(buffer<unknown,5>);
	@version(2.0.0+)
	[25] DeleteSaveDataFileSystemBySaveDataSpaceId(u8, u64);
	@version(2.0.0+)
	[26] FormatSdCardDryRun();
	@version(2.0.0+)
	[27] IsExFatSupported() -> u8;
	@version(4.0.0+)
	[28] DeleteSaveDataFileSystemBySaveDataAttribute(u8, bytes<0x40,8>);
	# Takes two input u32s (gamecard handle, partition ID), and returns an
	# [\#IStorage](#nn::fssrv::sf::IStorage "wikilink") for the
	# [partition](http://switchbrew.org/index.php?title=Gamecard_Format "wikilink").
	# 
	[30] OpenGameCardStorage(u32, u32) -> object<nn::fssrv::sf::IStorage>;
	# Takes two input u32s, with the second u32 located at +4 in rawdata after
	# the first u32. Returns an
	# [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Mounts a [gamecard
	# partition](http://switchbrew.org/index.php?title=Gamecard_Partition "wikilink").
	# 
	[31] OpenGameCardFileSystem(u32, u32) -> object<nn::fssrv::sf::IFileSystem>;
	@version(3.0.0+)
	[32] ExtendSaveDataFileSystem(u8, u64, u64, u64);
	@version(5.0.0+)
	@undocumented
	[33] DeleteCacheStorage(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[34] GetCacheStorageSize(unknown) -> unknown;
	# Takes an input u8
	# [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem%20services#SaveDataSpaceId "wikilink")
	# and a 0x40-byte Save-struct entry. Official user-process code is only
	# known to use value 1 for the u8.
	# 
	# Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Permissions aren't checked until the specified save is successfully
	# found.
	# 
	# Only one process (specifically only one
	# [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink") session) can
	# mount a given savedata at any given time (this includes SystemSaveData).
	# 
	[51] OpenSaveDataFileSystem(u8, bytes<0x40,8>) -> object<nn::fssrv::sf::IFileSystem>;
	# Takes an input u8
	# [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem%20services#SaveDataSpaceId "wikilink")
	# and a 0x40-byte Save-struct entry. Web-applet only uses value0 for the
	# input u8.
	# 
	# Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink").
	# 
	# Mounts savedata in the SYSTEM
	# [NAND](http://switchbrew.org/index.php?title=Flash_Filesystem "wikilink")
	# partition.
	# 
	[52] OpenSaveDataFileSystemBySystemSaveDataId(u8, bytes<0x40,8>) -> object<nn::fssrv::sf::IFileSystem>;
	@version(2.0.0+)
	[53] OpenReadOnlySaveDataFileSystem(u8, bytes<0x40,8>) -> object<nn::fssrv::sf::IFileSystem>;
	@version(3.0.0+)
	[57] ReadSaveDataFileSystemExtraDataBySaveDataSpaceId(u8, u64) -> buffer<unknown,6>;
	[58] ReadSaveDataFileSystemExtraData(u64) -> buffer<unknown,6>;
	@version(2.0.0+)
	[59] WriteSaveDataFileSystemExtraData(u8, u64, buffer<unknown,5>);
	# No input, returns an output
	# [\#ISaveDataInfoReader](#nn::fssrv::sf::ISaveDataInfoReader "wikilink").
	# 
	[60] OpenSaveDataInfoReader() -> object<nn::fssrv::sf::ISaveDataInfoReader>;
	# Takes an input u8
	# [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem%20services#SaveDataSpaceId "wikilink"),
	# returns an output
	# [\#ISaveDataInfoReader](#nn::fssrv::sf::ISaveDataInfoReader "wikilink").
	# 
	[61] OpenSaveDataInfoReaderBySaveDataSpaceId(u8) -> object<nn::fssrv::sf::ISaveDataInfoReader>;
	@version(5.0.0+)
	@undocumented
	[62] OpenCacheStorageList(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[64] OpenSaveDataInternalStorageFileSystem(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[65] UpdateSaveDataMacForDebug(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[66] WriteSaveDataFileSystemExtraData2(unknown) -> unknown;
	[80] OpenSaveDataMetaFile(u8, u32, bytes<0x40,8>) -> object<nn::fssrv::sf::IFile>;
	@version(4.0.0+)
	[81] OpenSaveDataTransferManager() -> object<nn::fssrv::sf::ISaveDataTransferManager>;
	@version(5.0.0+)
	@undocumented
	[82] OpenSaveDataTransferManagerVersion2(unknown) -> unknown;
	[100] OpenImageDirectoryFileSystem(u32) -> object<nn::fssrv::sf::IFileSystem>;
	# Takes a
	# [\#ContentStorageId](http://switchbrew.org/index.php?title=Filesystem%20services#ContentStorageId "wikilink").
	# Invalid values return 0x2EE202.
	# 
	# Returns an [\#IFileSystem](#nn::fssrv::sf::IFileSystem "wikilink") with
	# NCA files. The read data from these files is identical to the data read
	# by
	# [Content\_Manager\_services\#ReadEntryRaw](http://switchbrew.org/index.php?title=Content_Manager_services#ReadEntryRaw "wikilink").
	# 
	[110] OpenContentStorageFileSystem(u32) -> object<nn::fssrv::sf::IFileSystem>;
	[200] OpenDataStorageByCurrentProcess() -> object<nn::fssrv::sf::IStorage>;
	@version(3.0.0+)
	[201] OpenDataStorageByProgramId(u64) -> object<nn::fssrv::sf::IStorage>;
	# Takes a
	# [\#StorageId](http://switchbrew.org/index.php?title=Filesystem%20services#StorageId "wikilink")
	# and a TitleID.
	# 
	# Returns a [domain object
	# ID](http://switchbrew.org/index.php?title=IPC_Marshalling#Domain_message "wikilink")
	# implementing the [\#IStorage](#nn::fssrv::sf::IStorage "wikilink")
	# interface for data archives.
	# 
	[202] OpenDataStorageByDataId(u8, u64) -> object<nn::fssrv::sf::IStorage>;
	[203] OpenPatchDataStorageByCurrentProcess() -> object<nn::fssrv::sf::IStorage>;
	# This command returns a session to a port implementing the
	# [\#IDeviceOperator](#nn::fssrv::sf::IDeviceOperator "wikilink")
	# interface.
	# 
	[400] OpenDeviceOperator() -> object<nn::fssrv::sf::IDeviceOperator>;
	# This command returns a session to a port implementing the
	# [\#IEventNotifier](#nn::fssrv::sf::IEventNotifier "wikilink") interface.
	# 
	[500] OpenSdCardDetectionEventNotifier() -> object<nn::fssrv::sf::IEventNotifier>;
	# This command returns a session to a port implementing the
	# [\#IEventNotifier](#nn::fssrv::sf::IEventNotifier "wikilink") interface.
	# 
	[501] OpenGameCardDetectionEventNotifier() -> object<nn::fssrv::sf::IEventNotifier>;
	@version(5.0.0+)
	@undocumented
	[510] OpenSystemDataUpdateEventNotifier(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[511] NotifySystemDataUpdateEvent(unknown) -> unknown;
	@version(1.0.0-3.0.2)
	[600] SetCurrentPosixTime(u64);
	[601] QuerySaveDataTotalSize(u64, u64) -> u64;
	# Takes an unknown input u64 and a type-0x6 output buffer.
	# 
	# The input u64 high-byte must be non-zero, otherwise an
	# [error](http://switchbrew.org/index.php?title=Error_codes "wikilink") is
	# returned(0xE02).
	# 
	[602] VerifySaveDataFileSystem(u64) -> buffer<unknown,6>;
	[603] CorruptSaveDataFileSystem(u64);
	[604] CreatePaddingFile(u64);
	[605] DeleteAllPaddingFiles();
	@version(2.0.0+)
	[606] GetRightsId(u8, u64) -> bytes<0x10,8>;
	@version(2.0.0+)
	[607] RegisterExternalKey(bytes<0x10,8>, bytes<0x10,1>);
	@version(2.0.0+)
	[608] UnregisterAllExternalKey();
	@version(2.0.0+)
	[609] GetRightsIdByPath(buffer<unknown<0x301>,0x19>) -> bytes<0x10,8>;
	@version(3.0.0+)
	[610] GetRightsIdAndKeyGenerationByPath(buffer<unknown<0x301>,0x19>) -> (u8, bytes<0x10,8>);
	@version(4.0.0+)
	[611] SetCurrentPosixTimeWithTimeDifference(u32, u64);
	@version(4.0.0+)
	[612] GetFreeSpaceSizeForSaveData(u8) -> u64;
	@version(4.0.0+)
	[613] VerifySaveDataFileSystemBySaveDataSpaceId(u8, u64) -> buffer<unknown,6>;
	@version(4.0.0+)
	[614] CorruptSaveDataFileSystemBySaveDataSpaceId(u8, u64);
	@version(5.0.0+)
	@undocumented
	[615] QuerySaveDataInternalStorageTotalSize(unknown) -> unknown;
	# Takes in the 0x10 byte SD card encryption seed, and loads it into
	# FS-module
	# state.
	# 
	# [NS](http://switchbrew.org/index.php?title=NS_Services "wikilink")-module
	# reads the 0x10 bytes from SdCard:/Nintendo/Contents/private, and
	# compares them to the first 0x10 bytes of the ns\_appman:/private (in
	# [system
	# savedata](http://switchbrew.org/index.php?title=Flash_Filesystem#System_Savegames "wikilink")
	# 0x8000000000000043). If they match, NS calls this command using bytes
	# 0x10-0x20 from ns\_appman:/private. The rest of this file (0x1F0 bytes
	# total) is (usually/always?) all-zero.
	# 
	@version(2.0.0+)
	[620] SetSdCardEncryptionSeed(bytes<0x10,1>);
	@version(4.0.0+)
	[630] SetSdCardAccessibility(u8);
	@version(4.0.0+)
	[631] IsSdCardAccessible() -> u8;
	@version(4.0.0+)
	[640] IsSignedSystemPartitionOnSdCardValid() -> u8;
	@version(5.0.0+)
	@undocumented
	[700] OpenAccessFailureResolver(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[701] GetAccessFailureDetectionEvent(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[702] IsAccessFailureDetected(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[710] ResolveAccessFailure(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[720] AbandonAccessFailure(unknown) -> unknown;
	@version(2.0.0+)
	[800] GetAndClearFileSystemProxyErrorInfo() -> bytes<0x80,4>;
	[1000] SetBisRootForHost(u32, buffer<unknown<0x301>,0x19>);
	[1001] SetSaveDataSize(u64, u64);
	[1002] SetSaveDataRootPath(buffer<unknown<0x301>,0x19>);
	[1003] DisableAutoSaveDataCreation();
	# Takes an input u32.
	# 
	[1004] SetGlobalAccessLogMode(u32);
	# Returns an output u32.
	# 
	# GlobalAccessLogMode is normally 0.
	# 
	[1005] GetGlobalAccessLogMode() -> u32;
	# Takes a type-0x5 input buffer.
	# 
	# The input buffer is the string to output to the log. User-processes
	# normally include a newline at the end.
	# 
	# User-processes only use this when the value previously loaded from
	# [\#GetGlobalAccessLogMode](#nn::fssrv::sf::IFileSystemProxy\(1005\) "wikilink")
	# has bit1 set.
	# 
	# When bit1 in GlobalAccessLogMode is clear, FS-module will just return 0
	# for OutputAccessLogToSdCard. However even with that set the log doesn't
	# show up SD, unknown why.
	# 
	# The input buffer is written to the "$FsAccessLog:/FsAccessLog.txt" file,
	# where "$FsAccessLog" is the SD-card mount-name. It's written to the
	# current end of the file(appended).
	# 
	[1006] OutputAccessLogToSdCard(buffer<unknown,5>);
	@version(4.0.0+)
	[1007] RegisterUpdatePartition();
	@version(4.0.0+)
	[1008] OpenRegisteredUpdatePartition() -> object<nn::fssrv::sf::IFileSystem>;
	@version(4.0.0+)
	[1009] GetAndClearMemoryReportInfo() -> bytes<0x80,8>;
	@version(5.1.0+)
	@undocumented
	[1010] Unknown1010(unknown) -> unknown;
	@version(4.0.0+)
	[1100] OverrideSaveDataTransferTokenSignVerificationKey(buffer<unknown,5>);
}

interface nn::fssrv::sf::IFileSystemProxyForLoader is fsp-ldr {
	[0] OpenCodeFileSystem(u64, buffer<unknown<0x301>,0x19>) -> object<nn::fssrv::sf::IFileSystem>;
	[1] IsArchivedProgram(u64) -> u8;
	@version(4.0.0+)
	[2] SetCurrentProcess(u64, pid);
}

interface nn::fssrv::sf::IProgramRegistry is fsp-pr {
	# Takes a storageID, a pid, a titleID, a 0x1C type-A buffer for the [ FS
	# Access
	# Header](http://switchbrew.org/index.php?title=NPDM#FS_Access_Header "wikilink"),
	# and a 0x2C type-A buffer for the [ FS Access
	# Control](http://switchbrew.org/index.php?title=NPDM#FS_Access_Control "wikilink")
	# 
	# Final FS permissions are stored as (ACI0\_perms & ACID\_perms). Will
	# panic(svcBreak) when buffer sizes from ipc-rawdata are invalid.
	# 
	[0] RegisterProgram(u8, u64, u64, u64, u64, buffer<unknown,5>, buffer<unknown,5>);
	# Takes a pid. Removes registered FS permissions for that PID.
	# 
	[1] UnregisterProgram(u64);
	@version(4.0.0+)
	[2] SetCurrentProcess(u64, pid);
	# Seems to sets a global flag to inputval & 1.
	# 
	# When the flag is zero, it will set ret=0 instead of ret={error} when
	# verifying the fixed-key
	# [NPDM](http://switchbrew.org/index.php?title=NPDM "wikilink") ACID
	# signature fails. This also skips verifying the [NCA
	# Header](http://switchbrew.org/index.php?title=NCA_Format "wikilink")
	# signature using the ACID key. Note that if verifying the fixed-key ACID
	# signature is successful, and verifying the ACID-key NCA header signature
	# fails, it will throw an error and abort.
	# 
	[256] SetEnabledProgramVerification(u8);
}

interface nn::fssrv::sf::ISaveDataInfoReader {
	# Takes a type-0x6 output buffer. Returns an output u64 for total output
	# entries. This buffer contains an array of
	# [\#SaveDataInfo](http://switchbrew.org/index.php?title=Filesystem%20services#SaveDataInfo "wikilink").
	# 
	# This is used to get
	# [\#SaveDataInfo](http://switchbrew.org/index.php?title=Filesystem%20services#SaveDataInfo "wikilink")
	# for all savedata on the system (or all savedata for the current
	# [\#SaveDataSpaceId](http://switchbrew.org/index.php?title=Filesystem%20services#SaveDataSpaceId "wikilink")).
	# When used multiple times, it will resume reading where it left off,
	# until no more entries are available (in that case the out u64 is value
	# 0).
	# 
	[0] ReadSaveDataInfo() -> (u64, buffer<unknown,6>);
}

interface nn::fssrv::sf::IStorage {
	[0] Read(u64, u64) -> buffer<unknown,0x46>;
	[1] Write(u64, u64, buffer<unknown,0x45>);
	[2] Flush();
	[3] SetSize(u64);
	[4] GetSize() -> u64;
	@version(4.0.0+)
	[5] OperateRange(u32, u64, u64) -> bytes<0x40,4>;
}

interface nn::gpio::IManager is gpio {
	# Takes a raw
	# [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus%20services#GpioPadDescriptor "wikilink")
	# and returns a [\#IPadSession](#nn::gpio::IPadSession "wikilink") session
	# for it.
	# 
	[0] OpenSessionForDev(u32) -> object<nn::gpio::IPadSession>;
	# Same thing as [\#OpenSessionForDev](#nn::gpio::IManager\(0\) "wikilink")
	# except it takes a **GpioPadName** which is then converted to a
	# [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus%20services#GpioPadDescriptor "wikilink").
	# Returns an [\#IPadSession](#nn::gpio::IPadSession "wikilink") session.
	# 
	[1] OpenSession(u32) -> object<nn::gpio::IPadSession>;
	# Same as [\#OpenSession](#nn::gpio::IManager\(1\) "wikilink") but panics
	# on failure.
	# 
	[2] OpenSessionForTest(u32) -> object<nn::gpio::IPadSession>;
	[3] IsWakeEventActive(u32) -> u8;
	[4] GetWakeEventActiveFlagSet() -> bytes<0x10,8>;
	[5] SetWakeEventActiveFlagSetForDebug(u8, u32);
	[6] SetWakePinDebugMode(u32);
	# Same as [\#OpenSession](#nn::gpio::IManager\(1\) "wikilink") but takes a
	# **DeviceCode** instead of a **GpioPadName**.
	# 
	@version(5.0.0+)
	@undocumented
	[7] OpenSession2(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[8] IsWakeEventActive2(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[9] SetWakeEventActiveFlagSetForDebug2(unknown) -> unknown;
}

interface nn::gpio::IPadSession {
	[0] SetDirection(u32);
	[1] GetDirection() -> u32;
	[2] SetInterruptMode(u32);
	[3] GetInterruptMode() -> u32;
	[4] SetInterruptEnable(u8);
	[5] GetInterruptEnable() -> u8;
	[6] GetInterruptStatus() -> u32;
	[7] ClearInterruptStatus();
	[8] SetValue(u32);
	[9] GetValue() -> u32;
	[10] BindInterrupt() -> handle<copy>;
	[11] UnbindInterrupt();
	[12] SetDebounceEnabled(u8);
	[13] GetDebounceEnabled() -> u8;
	[14] SetDebounceTime(u32);
	[15] GetDebounceTime() -> u32;
	@version(4.0.0+)
	[16] SetValueForSleepState(u32);
}

interface nn::grcsrv::IContinuousRecorder {
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[10] Unknown10() -> handle<copy>;
	@undocumented
	[11] Unknown11();
	@undocumented
	[12] Unknown12();
	@undocumented
	[13] Unknown13(unknown<8>);
}

interface nn::grcsrv::IGameMovieTrimmer {
	[1] BeginTrim(u32, u32, nn::grcsrv::GameMovieId);
	[2] EndTrim() -> nn::grcsrv::GameMovieId;
	[10] GetNotTrimmingEvent() -> handle<copy>;
	[20] SetThumbnailRgba(u32, u32, buffer<bytes,0x45>);
}

interface nn::grcsrv::IGrcService is grc:c {
	@undocumented
	[1] OpenContinuousRecorder(unknown<0x28>, handle<copy>) -> object<nn::grcsrv::IContinuousRecorder>;
	@undocumented
	[2] OpenGameMovieTrimmer(unknown<8>, handle<copy>) -> object<nn::grcsrv::IGameMovieTrimmer>;
}

interface nn::hid::IActiveVibrationDeviceList {
	# Takes an input
	# [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID%20services#VibrationDeviceHandle "wikilink").
	# No output.
	# 
	[0] ActivateVibrationDevice(nn::hid::VibrationDeviceHandle);
}

interface nn::hid::IHidDebugServer is hid:dbg {
	[0] DeactivateDebugPad();
	[1] SetDebugPadAutoPilotState(nn::hid::debug::DebugPadAutoPilotState);
	[2] UnsetDebugPadAutoPilotState();
	[10] DeactivateTouchScreen();
	[11] SetTouchScreenAutoPilotState(buffer<nn::hid::TouchState,5>);
	[12] UnsetTouchScreenAutoPilotState();
	[20] DeactivateMouse();
	[21] SetMouseAutoPilotState(nn::hid::debug::MouseAutoPilotState);
	[22] UnsetMouseAutoPilotState();
	[30] DeactivateKeyboard();
	[31] SetKeyboardAutoPilotState(nn::hid::debug::KeyboardAutoPilotState);
	[32] UnsetKeyboardAutoPilotState();
	[50] DeactivateXpad(nn::hid::BasicXpadId);
	[51] SetXpadAutoPilotState(nn::hid::BasicXpadId, nn::hid::debug::BasicXpadAutoPilotState);
	[52] UnsetXpadAutoPilotState(nn::hid::BasicXpadId);
	[60] DeactivateJoyXpad(nn::hid::JoyXpadId);
	[91] DeactivateGesture();
	[110] DeactivateHomeButton();
	[111] SetHomeButtonAutoPilotState(nn::hid::debug::HomeButtonAutoPilotState);
	[112] UnsetHomeButtonAutoPilotState();
	[120] DeactivateSleepButton();
	[121] SetSleepButtonAutoPilotState(nn::hid::debug::SleepButtonAutoPilotState);
	[122] UnsetSleepButtonAutoPilotState();
	[123] DeactivateInputDetector();
	[130] DeactivateCaptureButton();
	[131] SetCaptureButtonAutoPilotState(nn::hid::debug::CaptureButtonAutoPilotState);
	[132] UnsetCaptureButtonAutoPilotState();
	[133] SetShiftAccelerometerCalibrationValue(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[134] GetShiftAccelerometerCalibrationValue(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[135] SetShiftGyroscopeCalibrationValue(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[136] GetShiftGyroscopeCalibrationValue(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[140] DeactivateConsoleSixAxisSensor();
	@version(5.0.0+)
	@undocumented
	[141] GetConsoleSixAxisSensorSamplingFrequency(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[142] DeactivateSevenSixAxisSensor(unknown) -> unknown;
	[201] ActivateFirmwareUpdate();
	[202] DeactivateFirmwareUpdate();
	[203] StartFirmwareUpdate(nn::hid::system::UniquePadId);
	[204] GetFirmwareUpdateStage() -> (u64, u64);
	[205] GetFirmwareVersion(u32, nn::util::BitFlagSet<0x20,nn::hid::system::DeviceType>) -> nn::hid::system::FirmwareVersion;
	[206] GetDestinationFirmwareVersion(u32, nn::util::BitFlagSet<0x20,nn::hid::system::DeviceType>) -> nn::hid::system::FirmwareVersion;
	[207] DiscardFirmwareInfoCacheForRevert();
	[208] StartFirmwareUpdateForRevert(nn::hid::system::UniquePadId);
	[209] GetAvailableFirmwareVersionForRevert(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareVersion;
	@version(4.0.0+)
	[210] IsFirmwareUpdatingDevice(nn::hid::system::UniquePadId) -> b8;
	[221] UpdateControllerColor(nn::util::Unorm8x4, nn::util::Unorm8x4, nn::hid::system::UniquePadId);
	@version(4.0.0+)
	[222] ConnectUsbPadsAsync();
	@version(4.0.0+)
	[223] DisconnectUsbPadsAsync();
	@version(5.0.0+)
	@undocumented
	[224] UpdateDesignInfo(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[225] GetUniquePadDriverState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[226] GetSixAxisSensorDriverStates(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[301] GetAbstractedPadHandles(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[302] GetAbstractedPadState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[303] GetAbstractedPadsState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[321] SetAutoPilotVirtualPadState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[322] UnsetAutoPilotVirtualPadState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[323] UnsetAllAutoPilotVirtualPadState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[350] AddRegisteredDevice(unknown) -> unknown;
}

interface nn::hid::IHidServer is hid {
	# Takes a PID and an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns an
	# [\#IAppletResource](http://switchbrew.org/index.php?title=HID%20services#IAppletResource "wikilink").
	# 
	[0] CreateAppletResource(nn::applet::AppletResourceUserId, pid) -> object<nn::hid::IAppletResource>;
	[1] ActivateDebugPad(nn::applet::AppletResourceUserId, pid);
	[11] ActivateTouchScreen(nn::applet::AppletResourceUserId, pid);
	[21] ActivateMouse(nn::applet::AppletResourceUserId, pid);
	[31] ActivateKeyboard(nn::applet::AppletResourceUserId, pid);
	[40] AcquireXpadIdEventHandle(u64) -> handle<copy>;
	[41] ReleaseXpadIdEventHandle(u64);
	[51] ActivateXpad(nn::hid::BasicXpadId, nn::applet::AppletResourceUserId, pid);
	[55] GetXpadIds() -> (u64, buffer<nn::hid::BasicXpadId,0xa>);
	[56] ActivateJoyXpad(nn::hid::JoyXpadId);
	[58] GetJoyXpadLifoHandle(nn::hid::JoyXpadId) -> handle<copy>;
	[59] GetJoyXpadIds() -> (u64, buffer<nn::hid::JoyXpadId,0xa>);
	[60] ActivateSixAxisSensor(nn::hid::BasicXpadId);
	[61] DeactivateSixAxisSensor(nn::hid::BasicXpadId);
	[62] GetSixAxisSensorLifoHandle(nn::hid::BasicXpadId) -> handle<copy>;
	[63] ActivateJoySixAxisSensor(nn::hid::JoyXpadId);
	[64] DeactivateJoySixAxisSensor(nn::hid::JoyXpadId);
	[65] GetJoySixAxisSensorLifoHandle(nn::hid::JoyXpadId) -> handle<copy>;
	[66] StartSixAxisSensor(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[67] StopSixAxisSensor(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[68] IsSixAxisSensorFusionEnabled(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> b8;
	[69] EnableSixAxisSensorFusion(b8, nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[70] SetSixAxisSensorFusionParameters(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[71] GetSixAxisSensorFusionParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[72] ResetSixAxisSensorFusionParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[73] SetAccelerometerParameters(nn::hid::SixAxisSensorHandle, f32, f32, nn::applet::AppletResourceUserId, pid);
	[74] GetAccelerometerParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> (f32, f32);
	[75] ResetAccelerometerParameters(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[76] SetAccelerometerPlayMode(nn::hid::SixAxisSensorHandle, u32, nn::applet::AppletResourceUserId, pid);
	[77] GetAccelerometerPlayMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> u32;
	[78] ResetAccelerometerPlayMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[79] SetGyroscopeZeroDriftMode(nn::hid::SixAxisSensorHandle, u32, nn::applet::AppletResourceUserId, pid);
	[80] GetGyroscopeZeroDriftMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> u32;
	[81] ResetGyroscopeZeroDriftMode(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[82] IsSixAxisSensorAtRest(nn::hid::SixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> b8;
	[91] ActivateGesture(u32, nn::applet::AppletResourceUserId, pid);
	[100] SetSupportedNpadStyleSet(nn::util::BitFlagSet<0x20,nn::hid::NpadStyleTag>, nn::applet::AppletResourceUserId, pid);
	[101] GetSupportedNpadStyleSet(nn::applet::AppletResourceUserId, pid) -> nn::util::BitFlagSet<0x20,nn::hid::NpadStyleTag>;
	[102] SetSupportedNpadIdType(nn::applet::AppletResourceUserId, pid, buffer<u32,9>);
	[103] ActivateNpad(nn::applet::AppletResourceUserId, pid);
	[104] DeactivateNpad(nn::applet::AppletResourceUserId, pid);
	[106] AcquireNpadStyleSetUpdateEventHandle(u32, nn::applet::AppletResourceUserId, u64, pid) -> handle<copy>;
	[107] DisconnectNpad(u32, nn::applet::AppletResourceUserId, pid);
	[108] GetPlayerLedPattern(u32) -> u64;
	@version(5.0.0+)
	@undocumented
	[109] ActivateNpadWithRevision(unknown) -> unknown;
	[120] SetNpadJoyHoldType(nn::applet::AppletResourceUserId, u64, pid);
	[121] GetNpadJoyHoldType(nn::applet::AppletResourceUserId, pid) -> u64;
	# Takes a PID-descriptor, an u32, and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[122] SetNpadJoyAssignmentModeSingleByDefault(u32, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an u32,
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"),
	# and s64 **NpadJoyDeviceType**. No output.
	# 
	[123] SetNpadJoyAssignmentModeSingle(u32, nn::applet::AppletResourceUserId, u64, pid);
	# Takes a PID-descriptor, an u32, and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[124] SetNpadJoyAssignmentModeDual(u32, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, two u32s, and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[125] MergeSingleJoyAsDualJoy(u32, u32, nn::applet::AppletResourceUserId, pid);
	[126] StartLrAssignmentMode(nn::applet::AppletResourceUserId, pid);
	[127] StopLrAssignmentMode(nn::applet::AppletResourceUserId, pid);
	[128] SetNpadHandheldActivationMode(nn::applet::AppletResourceUserId, u64, pid);
	# Takes a PID and an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns an output u64. Official user-processes panic if the output u64
	# is not 0-2.
	# 
	[129] GetNpadHandheldActivationMode(nn::applet::AppletResourceUserId, pid) -> u64;
	[130] SwapNpadAssignment(u32, u32, nn::applet::AppletResourceUserId, pid);
	[131] IsUnintendedHomeButtonInputProtectionEnabled(u32, nn::applet::AppletResourceUserId, pid) -> b8;
	[132] EnableUnintendedHomeButtonInputProtection(b8, u32, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	@undocumented
	[133] SetNpadJoyAssignmentModeSingleWithDestination(unknown) -> unknown;
	# Takes a
	# [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID%20services#VibrationDeviceHandle "wikilink").
	# Returns an output
	# [\#VibrationDeviceInfo](http://switchbrew.org/index.php?title=HID%20services#VibrationDeviceInfo "wikilink").
	# 
	[200] GetVibrationDeviceInfo(nn::hid::VibrationDeviceHandle) -> nn::hid::VibrationDeviceInfoForIpc;
	# Takes a PID-descriptor, a
	# [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID%20services#VibrationDeviceHandle "wikilink"),
	# a
	# [\#VibrationValue](http://switchbrew.org/index.php?title=HID%20services#VibrationValue "wikilink")
	# immediately after that, and an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[201] SendVibrationValue(nn::hid::VibrationDeviceHandle, nn::hid::VibrationValue, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, a
	# [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID%20services#VibrationDeviceHandle "wikilink"),
	# and an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns an output
	# [\#VibrationValue](http://switchbrew.org/index.php?title=HID%20services#VibrationValue "wikilink").
	# 
	[202] GetActualVibrationValue(nn::hid::VibrationDeviceHandle, nn::applet::AppletResourceUserId, pid) -> nn::hid::VibrationValue;
	# No input. Returns an
	# [\#IActiveVibrationDeviceList](#nn::hid::IActiveVibrationDeviceList "wikilink").
	# 
	[203] CreateActiveVibrationDeviceList() -> object<nn::hid::IActiveVibrationDeviceList>;
	# Takes an input u8 bool. No output.
	# 
	# This affects the config displayed by System Settings.
	# 
	[204] PermitVibration(b8);
	# No input. Returns an output u8 bool.
	# 
	[205] IsVibrationPermitted() -> b8;
	# Takes an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"),
	# and two type-0x9 input buffers containing an array of:
	# [\#VibrationDeviceHandle](http://switchbrew.org/index.php?title=HID%20services#VibrationDeviceHandle "wikilink")
	# for first buffer, and
	# [\#VibrationValue](http://switchbrew.org/index.php?title=HID%20services#VibrationValue "wikilink")
	# for the second buffer.
	# 
	# Official sw uses the same entry-count for each array.
	# 
	[206] SendVibrationValues(nn::applet::AppletResourceUserId, buffer<nn::hid::VibrationDeviceHandle,9>, buffer<nn::hid::VibrationValue,9>);
	@version(4.0.0+)
	[207] SendVibrationGcErmCommand(nn::hid::VibrationDeviceHandle, nn::applet::AppletResourceUserId, nn::hid::VibrationGcErmCommand, pid);
	@version(4.0.0+)
	[208] GetActualVibrationGcErmCommand(nn::hid::VibrationDeviceHandle, nn::applet::AppletResourceUserId, pid) -> nn::hid::VibrationGcErmCommand;
	@version(4.0.0+)
	[209] BeginPermitVibrationSession(nn::applet::AppletResourceUserId);
	@version(4.0.0+)
	[210] EndPermitVibrationSession();
	[300] ActivateConsoleSixAxisSensor(nn::applet::AppletResourceUserId, pid);
	[301] StartConsoleSixAxisSensor(nn::hid::ConsoleSixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	[302] StopConsoleSixAxisSensor(nn::hid::ConsoleSixAxisSensorHandle, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	@undocumented
	[303] ActivateSevenSixAxisSensor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[304] StartSevenSixAxisSensor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[305] StopSevenSixAxisSensor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[306] InitializeSevenSixAxisSensor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[307] FinalizeSevenSixAxisSensor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[308] SetSevenSixAxisSensorFusionStrength(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[309] GetSevenSixAxisSensorFusionStrength(unknown) -> unknown;
	[400] IsUsbFullKeyControllerEnabled() -> b8;
	[401] EnableUsbFullKeyController(b8);
	[402] IsUsbFullKeyControllerConnected(u32) -> b8;
	@version(4.0.0+)
	[403] HasBattery(u32) -> b8;
	@version(4.0.0+)
	[404] HasLeftRightBattery(u32) -> (b8, b8);
	@version(4.0.0+)
	[405] GetNpadInterfaceType(u32) -> u8;
	@version(4.0.0+)
	[406] GetNpadLeftRightInterfaceType(u32) -> (u8, u8);
	@version(5.0.0+)
	@undocumented
	[500] GetPalmaConnectionHandle(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[501] InitializePalma(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[502] AcquirePalmaOperationCompleteEvent(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[503] GetPalmaOperationInfo(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[504] PlayPalmaActivity(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[505] SetPalmaFrModeType(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[506] ReadPalmaStep(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[507] EnablePalmaStep(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[508] SuspendPalmaStep(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[509] ResetPalmaStep(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[510] ReadPalmaApplicationSection(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[511] WritePalmaApplicationSection(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[512] ReadPalmaUniqueCode(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[513] SetPalmaUniqueCodeInvalid(unknown) -> unknown;
	@version(5.1.0+)
	@undocumented
	[520] Unknown520(unknown) -> unknown;
	@version(5.1.0+)
	@undocumented
	[521] Unknown521(unknown) -> unknown;
	[1000] SetNpadCommunicationMode(nn::applet::AppletResourceUserId, u64, pid);
	[1001] GetNpadCommunicationMode() -> u64;
}

interface nn::hid::IHidSystemServer is hid:sys {
	[31] SendKeyboardLockKeyEvent(nn::util::BitFlagSet<0x20,nn::hid::system::KeyboardLockKeyEvent>);
	[101] AcquireHomeButtonEventHandle(nn::applet::AppletResourceUserId, pid) -> handle<copy>;
	[111] ActivateHomeButton(nn::applet::AppletResourceUserId, pid);
	[121] AcquireSleepButtonEventHandle(nn::applet::AppletResourceUserId, pid) -> handle<copy>;
	[131] ActivateSleepButton(nn::applet::AppletResourceUserId, pid);
	[141] AcquireCaptureButtonEventHandle(nn::applet::AppletResourceUserId, pid) -> handle<copy>;
	[151] ActivateCaptureButton(nn::applet::AppletResourceUserId, pid);
	[210] AcquireNfcDeviceUpdateEventHandle() -> handle<copy>;
	[211] GetNpadsWithNfc() -> (u64, buffer<u32,0xa>);
	[212] AcquireNfcActivateEventHandle(u32) -> handle<copy>;
	[213] ActivateNfc(b8, u32, nn::applet::AppletResourceUserId, pid);
	@version(4.0.0+)
	[214] GetXcdHandleForNpadWithNfc(u32, nn::applet::AppletResourceUserId) -> u64;
	@version(4.0.0+)
	[215] IsNfcActivated(u32) -> b8;
	[230] AcquireIrSensorEventHandle(u32) -> handle<copy>;
	[231] ActivateIrSensor(b8, u32, nn::applet::AppletResourceUserId, pid);
	[301] ActivateNpadSystem(u32);
	[303] ApplyNpadSystemCommonPolicy(nn::applet::AppletResourceUserId, pid);
	[304] EnableAssigningSingleOnSlSrPress(nn::applet::AppletResourceUserId, pid);
	[305] DisableAssigningSingleOnSlSrPress(nn::applet::AppletResourceUserId, pid);
	[306] GetLastActiveNpad() -> u32;
	[307] GetNpadSystemExtStyle(u32) -> (u64, u64);
	@version(5.0.0+)
	@undocumented
	[308] ApplyNpadSystemCommonPolicyFull(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[309] GetNpadFullKeyGripColor(unknown) -> unknown;
	[311] SetNpadPlayerLedBlinkingDevice(u32, nn::util::BitFlagSet<0x20,nn::hid::system::DeviceType>, nn::applet::AppletResourceUserId, pid);
	[321] GetUniquePadsFromNpad(u32) -> (u64, buffer<nn::hid::system::UniquePadId,0xa>);
	[322] GetIrSensorState(u32, nn::applet::AppletResourceUserId, pid) -> u64;
	[323] GetXcdHandleForNpadWithIrSensor(u32, nn::applet::AppletResourceUserId, pid) -> u64;
	[500] SetAppletResourceUserId(nn::applet::AppletResourceUserId);
	[501] RegisterAppletResourceUserId(b8, nn::applet::AppletResourceUserId);
	[502] UnregisterAppletResourceUserId(nn::applet::AppletResourceUserId);
	[503] EnableAppletToGetInput(b8, nn::applet::AppletResourceUserId);
	[504] SetAruidValidForVibration(b8, nn::applet::AppletResourceUserId);
	[505] EnableAppletToGetSixAxisSensor(b8, nn::applet::AppletResourceUserId);
	# Takes an input 32bit float.
	# 
	[510] SetVibrationMasterVolume(f32);
	[511] GetVibrationMasterVolume() -> f32;
	[512] BeginPermitVibrationSession(nn::applet::AppletResourceUserId);
	[513] EndPermitVibrationSession();
	[520] EnableHandheldHids();
	[521] DisableHandheldHids();
	[540] AcquirePlayReportControllerUsageUpdateEvent() -> handle<copy>;
	[541] GetPlayReportControllerUsages() -> (u64, buffer<nn::hid::system::PlayReportControllerUsage,0xa>);
	[542] AcquirePlayReportRegisteredDeviceUpdateEvent() -> handle<copy>;
	@version(1.0.0-4.1.0)
	[543] GetRegisteredDevices() -> (u64, buffer<nn::hid::system::RegisteredDevice,0xa>);
	@version(5.0.0+)
	[543] GetRegisteredDevicesOld() -> (u64, buffer<nn::hid::system::RegisteredDevice,0xa>);
	[544] AcquireConnectionTriggerTimeoutEvent() -> handle<copy>;
	[545] SendConnectionTrigger(nn::bluetooth::Address);
	[546] AcquireDeviceRegisteredEventForControllerSupport() -> handle<copy>;
	[547] GetAllowedBluetoothLinksCount() -> u64;
	@version(5.0.0+)
	@undocumented
	[548] GetRegisteredDevices(unknown) -> unknown;
	[700] ActivateUniquePad(nn::applet::AppletResourceUserId, nn::hid::system::UniquePadId, pid);
	[702] AcquireUniquePadConnectionEventHandle() -> handle<copy>;
	[703] GetUniquePadIds() -> (u64, buffer<nn::hid::system::UniquePadId,0xa>);
	[751] AcquireJoyDetachOnBluetoothOffEventHandle(nn::applet::AppletResourceUserId, pid) -> handle<copy>;
	[800] ListSixAxisSensorHandles(nn::hid::system::UniquePadId) -> (u64, buffer<nn::hid::system::UniqueSixAxisSensorHandle,0xa>);
	[801] IsSixAxisSensorUserCalibrationSupported(nn::hid::system::UniqueSixAxisSensorHandle) -> b8;
	[802] ResetSixAxisSensorCalibrationValues(nn::hid::system::UniqueSixAxisSensorHandle);
	[803] StartSixAxisSensorUserCalibration(nn::hid::system::UniqueSixAxisSensorHandle);
	[804] CancelSixAxisSensorUserCalibration(nn::hid::system::UniqueSixAxisSensorHandle);
	[805] GetUniquePadBluetoothAddress(nn::hid::system::UniquePadId) -> nn::bluetooth::Address;
	[806] DisconnectUniquePad(nn::hid::system::UniquePadId);
	@version(5.0.0+)
	@undocumented
	[807] GetUniquePadType(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[808] GetUniquePadInterface(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[809] GetUniquePadSerialNumber(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[810] GetUniquePadControllerNumber(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[811] GetSixAxisSensorUserCalibrationStage(unknown) -> unknown;
	[821] StartAnalogStickManualCalibration(nn::hid::system::UniquePadId, u64);
	[822] RetryCurrentAnalogStickManualCalibrationStage(nn::hid::system::UniquePadId, u64);
	[823] CancelAnalogStickManualCalibration(nn::hid::system::UniquePadId, u64);
	[824] ResetAnalogStickManualCalibration(nn::hid::system::UniquePadId, u64);
	@version(5.0.0+)
	@undocumented
	[825] GetAnalogStickState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[826] GetAnalogStickManualCalibrationStage(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[827] IsAnalogStickButtonPressed(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[828] IsAnalogStickInReleasePosition(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[829] IsAnalogStickInCircumference(unknown) -> unknown;
	[850] IsUsbFullKeyControllerEnabled() -> b8;
	[851] EnableUsbFullKeyController(b8);
	[852] IsUsbConnected(nn::hid::system::UniquePadId) -> b8;
	[900] ActivateInputDetector(nn::applet::AppletResourceUserId, pid);
	[901] NotifyInputDetector(nn::util::BitFlagSet<0x20,nn::hid::system::InputSourceId>);
	[1000] InitializeFirmwareUpdate();
	[1001] GetFirmwareVersion(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareVersion;
	[1002] GetAvailableFirmwareVersion(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareVersion;
	[1003] IsFirmwareUpdateAvailable(nn::hid::system::UniquePadId) -> b8;
	[1004] CheckFirmwareUpdateRequired(nn::hid::system::UniquePadId) -> u64;
	[1005] StartFirmwareUpdate(nn::hid::system::UniquePadId) -> nn::hid::system::FirmwareUpdateDeviceHandle;
	[1006] AbortFirmwareUpdate();
	[1007] GetFirmwareUpdateState(nn::hid::system::FirmwareUpdateDeviceHandle) -> nn::hid::system::FirmwareUpdateState;
	@version(4.0.0+)
	[1008] ActivateAudioControl();
	@version(4.0.0+)
	[1009] AcquireAudioControlEventHandle() -> handle<copy>;
	@version(4.0.0+)
	[1010] GetAudioControlStates() -> (u64, buffer<nn::hid::system::AudioControlState,0xa>);
	@version(4.0.0+)
	[1011] DeactivateAudioControl();
	@version(5.0.0+)
	@undocumented
	[1050] IsSixAxisSensorAccurateUserCalibrationSupported(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1051] StartSixAxisSensorAccurateUserCalibration(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1052] CancelSixAxisSensorAccurateUserCalibration(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1053] GetSixAxisSensorAccurateUserCalibrationState(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1100] GetHidbusSystemServiceObject(unknown) -> unknown;
}

interface nn::hid::IHidTemporaryServer is hid:tmp {
	[0] GetConsoleSixAxisSensorCalibrationValues(nn::hid::ConsoleSixAxisSensorHandle, nn::applet::AppletResourceUserId, pid) -> nn::hid::tmp::ConsoleSixAxisSensorCalibrationValues;
}

interface nn::hidbus::IHidbusServer is hidbus {
	@undocumented
	[1] GetBusHandle(unknown) -> unknown;
	@undocumented
	[2] IsExternalDeviceConnected(unknown) -> unknown;
	@undocumented
	[3] Initialize(unknown) -> unknown;
	@undocumented
	[4] Finalize(unknown) -> unknown;
	@undocumented
	[5] EnableExternalDevice(unknown) -> unknown;
	@undocumented
	[6] GetExternalDeviceId(unknown) -> unknown;
	@undocumented
	[7] SendCommandAsync(unknown) -> unknown;
	@undocumented
	[8] GetSendCommandAsynceResult(unknown) -> unknown;
	@undocumented
	[9] SetEventForSendCommandAsycResult(unknown) -> unknown;
	@undocumented
	[10] GetSharedMemoryHandle(unknown) -> unknown;
	@undocumented
	[11] EnableJoyPollingReceiveMode(unknown) -> unknown;
	@undocumented
	[12] DisableJoyPollingReceiveMode(unknown) -> unknown;
	@undocumented
	[13] GetPollingData(unknown) -> unknown;
}

interface nn::htc::tenv::IService {
	[0] GetVariable(bytes<0x40,1>) -> (u64, buffer<unknown,6>);
	[1] GetVariableLength(bytes<0x40,1>) -> u64;
	[2] WaitUntilVariableAvailable(u64);
}

interface nn::htc::tenv::IServiceManager is htc:tenv {
	[0] GetServiceInterface(u64, pid) -> object<unknown>;
}

interface nn::i2c::IManager is i2c, i2c:pcv {
	# Takes a raw
	# [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus%20services#GpioPadDescriptor "wikilink")
	# and returns a [\#IPadSession](#nn::gpio::IPadSession "wikilink") session
	# for it.
	# 
	[0] OpenSessionForDev(u16, u32, u32, u32) -> object<nn::i2c::ISession>;
	# Same thing as [\#OpenSessionForDev](#nn::gpio::IManager\(0\) "wikilink")
	# except it takes a **GpioPadName** which is then converted to a
	# [\#GpioPadDescriptor](http://switchbrew.org/index.php?title=Bus%20services#GpioPadDescriptor "wikilink").
	# Returns an [\#IPadSession](#nn::gpio::IPadSession "wikilink") session.
	# 
	[1] OpenSession(u32) -> object<nn::i2c::ISession>;
	# Takes an **I2cDevice** and returns true if the device exists or false
	# otherwise.
	# 
	[2] HasDevice(u32) -> u8;
	# Takes an u32 **port**, an u16 **addr**, an **AddressingMode** (1 for
	# 10-bit, 0 otherwise) and a **SpeedMode** (400000 or 100000). Returns
	# true if the device exists or false otherwise.
	# 
	[3] HasDeviceForDev(u16, u32, u32, u32) -> u8;
}

interface nn::i2c::ISession {
	[0] Send(u32, buffer<unknown,5>);
	[1] Receive(u32) -> buffer<unknown,6>;
	[2] ExecuteCommandList(buffer<unknown,9>) -> buffer<unknown,6>;
	[10] SendAuto(u32, buffer<unknown,0x21>);
	[11] ReceiveAuto(u32) -> buffer<unknown,0x22>;
	[12] ExecuteCommandListAuto(buffer<unknown,9>) -> buffer<unknown,0x22>;
}

interface nn::idle::detail::IPolicyManagerSystem is idle:sys {
	@undocumented
	[0] GetAutoPowerDownEvent() -> handle<copy>;
	@version(1.0.0-3.0.2)
	@undocumented
	[1] Unknown1();
	@version(1.0.0-3.0.2)
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3(unknown<0x38>);
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
}

interface nn::irsensor::IIrSensorServer is irs {
	# Takes a PID-descriptor and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[302] ActivateIrsensor(nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[303] DeactivateIrsensor(nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns a SharedMemory handle.
	# 
	# The SharedMemory is mapped with permissions=read-only and size=0x8000.
	# 
	[304] GetIrsensorSharedMemoryHandle(nn::applet::AppletResourceUserId, pid) -> handle<copy>;
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[305] StopImageProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"),
	# and a
	# [\#PackedMomentProcessorConfig](http://switchbrew.org/index.php?title=HID%20services#PackedMomentProcessorConfig "wikilink").
	# No output.
	# 
	[306] RunMomentProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedMomentProcessorConfig, pid);
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"),
	# and a
	# [\#PackedClusteringProcessorConfig](http://switchbrew.org/index.php?title=HID%20services#PackedClusteringProcessorConfig "wikilink").
	# No output.
	# 
	[307] RunClusteringProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedClusteringProcessorConfig, pid);
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink"),
	# a
	# [\#PackedImageTransferProcessorConfig](http://switchbrew.org/index.php?title=HID%20services#PackedImageTransferProcessorConfig "wikilink"),
	# an u64 for the TransferMemory\_size, and a TransferMemory handle. No
	# output.
	# 
	# Official sw creates the TransferMemory with an user-specified buffer and
	# permissions=0.
	# 
	[308] RunImageTransferProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedImageTransferProcessorConfig, u64, pid, handle<copy>);
	# Takes a PID-descriptor, a type-0x6 output buffer, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns an
	# [\#ImageTransferProcessorState](http://switchbrew.org/index.php?title=HID%20services#ImageTransferProcessorState "wikilink").
	# No output.
	# 
	[309] GetImageTransferProcessorState(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid) -> (nn::irsensor::ImageTransferProcessorState, buffer<bytes,6>);
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# a
	# [\#PackedTeraPluginProcessorConfig](http://switchbrew.org/index.php?title=HID%20services#PackedTeraPluginProcessorConfig "wikilink")
	# (immediately after the previous word), and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[310] RunTeraPluginProcessor(nn::irsensor::IrCameraHandle, nn::irsensor::PackedTeraPluginProcessorConfig, nn::applet::AppletResourceUserId, pid);
	# Takes an input u32. Returns an output
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink").
	# 
	[311] GetNpadIrCameraHandle(u32) -> nn::irsensor::IrCameraHandle;
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# a
	# [\#PackedDpdProcessorConfig](http://switchbrew.org/index.php?title=HID%20services#PackedDpdProcessorConfig "wikilink")
	# (immediately after the previous word), and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[312] RunPointingProcessor(nn::irsensor::IrCameraHandle, nn::irsensor::PackedPointingProcessorConfig, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	[313] SuspendImageProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid);
	# Takes a PID-descriptor, an
	# [\#IrCameraHandle](http://switchbrew.org/index.php?title=HID%20services#IrCameraHandle "wikilink"),
	# a
	# [\#PackedMcuVersion](http://switchbrew.org/index.php?title=HID%20services#PackedMcuVersion "wikilink"),
	# and an
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# No output.
	# 
	@version(3.0.0+)
	[314] CheckFirmwareVersion(nn::irsensor::IrCameraHandle, nn::irsensor::PackedMcuVersion, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[315] SetFunctionLevel(nn::irsensor::IrCameraHandle, nn::irsensor::PackedFunctionLevel, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[316] RunImageTransferExProcessor(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, nn::irsensor::PackedImageTransferProcessorExConfig, u64, pid, handle<copy>);
	@version(5.0.0+)
	[317] RunIrLedProcessor(nn::irsensor::IrCameraHandle, nn::irsensor::PackedIrLedProcessorConfig, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[318] StopImageProcessorAsync(nn::irsensor::IrCameraHandle, nn::applet::AppletResourceUserId, pid);
	@version(5.0.0+)
	[319] ActivateIrsensorWithFunctionLevel(nn::irsensor::PackedFunctionLevel, nn::applet::AppletResourceUserId, pid);
}

interface nn::irsensor::IIrSensorSystemServer is irs:sys {
	[500] SetAppletResourceUserId(nn::applet::AppletResourceUserId);
	[501] RegisterAppletResourceUserId(b8, nn::applet::AppletResourceUserId);
	[502] UnregisterAppletResourceUserId(nn::applet::AppletResourceUserId);
	[503] EnableAppletToGetInput(b8, nn::applet::AppletResourceUserId);
}

interface nn::jitsrv::IJitEnvironment {
	@undocumented
	[0] Control(unknown) -> unknown;
	@undocumented
	[1] GenerateCode(unknown) -> unknown;
	@undocumented
	[1000] LoadPlugin(unknown) -> unknown;
	@undocumented
	[1001] GetCodeAddress(unknown) -> unknown;
}

interface nn::jitsrv::IJitService is jit:u {
	@undocumented
	[0] CreateJitEnvironment(unknown) -> unknown;
}

interface nn::lbl::detail::ILblController is lbl {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2(unknown<4>);
	@undocumented
	[3] Unknown3() -> unknown<4>;
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5() -> unknown<4>;
	@undocumented
	[6] TurnOnBacklight(unknown<8>);
	@undocumented
	[7] TurnOffBacklight(unknown<8>);
	@undocumented
	[8] GetBacklightStatus() -> unknown<4>;
	@undocumented
	[9] Unknown9();
	@undocumented
	[10] Unknown10();
	@undocumented
	[11] Unknown11() -> unknown<1>;
	@undocumented
	[12] Unknown12();
	@undocumented
	[13] Unknown13();
	@undocumented
	[14] Unknown14() -> unknown<1>;
	@undocumented
	[15] Unknown15(unknown<4>);
	@undocumented
	[16] ReadRawLightSensor() -> unknown<4>;
	@undocumented
	[17] Unknown17(unknown<8>);
	@undocumented
	[18] Unknown18(unknown<4>) -> unknown<4>;
	@undocumented
	[19] Unknown19(unknown<0xc>);
	@undocumented
	[20] Unknown20() -> unknown<0xc>;
	@undocumented
	[21] Unknown21(unknown<0xc>);
	@undocumented
	[22] Unknown22() -> unknown<0xc>;
	@version(3.0.0+)
	@undocumented
	[23] Unknown23() -> unknown<1>;
	@version(3.0.0+)
	@undocumented
	[24] Unknown24(unknown<4>);
	@version(3.0.0+)
	@undocumented
	[25] Unknown25() -> unknown<4>;
	# No input/output. Used by
	# [AM\_services\#SetVrModeEnabled](http://switchbrew.org/index.php?title=AM_services#SetVrModeEnabled "wikilink").
	# 
	# Sets a global state field to 0x1.
	# 
	@version(3.0.0+)
	@undocumented
	[26] EnableVrMode();
	# No input/output. Used by
	# [AM\_services\#SetVrModeEnabled](http://switchbrew.org/index.php?title=AM_services#SetVrModeEnabled "wikilink").
	# 
	# Sets the global state field used by
	# [\#EnableVrMode](#nn::lbl::detail::ILblController\(26\) "wikilink") to
	# 0x0.
	# 
	@version(3.0.0+)
	@undocumented
	[27] DisableVrMode();
	# No input. Returns an output u8 bool set by the above
	# commands.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(3.0.0+)
	@undocumented
	[28] GetVrMode() -> unknown<1>;
}

interface nn::ldn::detail::IMonitorService {
	[0] GetStateForMonitor() -> u32;
	[1] GetNetworkInfoForMonitor() -> buffer<unknown<0x480>,0x1a>;
	[2] GetIpv4AddressForMonitor() -> (u32, u32);
	[3] GetDisconnectReasonForMonitor() -> u16;
	[4] GetSecurityParameterForMonitor() -> bytes<0x20,1>;
	[5] GetNetworkConfigForMonitor() -> bytes<0x20,8>;
	[100] InitializeMonitor();
	[101] FinalizeMonitor();
}

interface nn::ldn::detail::IMonitorServiceCreator is ldn:m {
	# Returns an
	# [\#IMonitorService](#nn::ldn::detail::IMonitorService "wikilink").
	# 
	[0] CreateMonitorService() -> object<nn::ldn::detail::IMonitorService>;
}

interface nn::ldn::detail::ISystemLocalCommunicationService {
	[0] GetState() -> u32;
	[1] GetNetworkInfo() -> buffer<unknown<0x480>,0x1a>;
	[2] GetIpv4Address() -> (u32, u32);
	[3] GetDisconnectReason() -> u16;
	[4] GetSecurityParameter() -> bytes<0x20,1>;
	[5] GetNetworkConfig() -> bytes<0x20,8>;
	[100] AttachStateChangeEvent() -> handle<copy>;
	[101] GetNetworkInfoLatestUpdate() -> (buffer<unknown<0x480>,0x1a>, buffer<unknown,0xa>);
	[102] Scan(u16, bytes<0x60,8>) -> (u16, buffer<unknown,0x22>);
	[103] ScanPrivate(u16, bytes<0x60,8>) -> (u16, buffer<unknown,0x22>);
	[200] OpenAccessPoint();
	[201] CloseAccessPoint();
	[202] CreateNetwork(bytes<0x44,2>, bytes<0x30,1>, bytes<0x20,8>);
	[203] CreateNetworkPrivate(bytes<0x44,2>, bytes<0x20,1>, bytes<0x30,1>, bytes<0x20,8>, buffer<unknown,9>);
	[204] DestroyNetwork();
	[205] Reject(u32);
	[206] SetAdvertiseData(buffer<unknown,0x21>);
	[207] SetStationAcceptPolicy(u8);
	[208] AddAcceptFilterEntry(bytes<6,1>);
	[209] ClearAcceptFilter();
	[300] OpenStation();
	[301] CloseStation();
	[302] Connect(bytes<0x44,2>, bytes<0x30,1>, u32, u32, buffer<unknown<0x480>,0x19>);
	[303] ConnectPrivate(bytes<0x44,2>, bytes<0x20,1>, bytes<0x30,1>, u32, u32, bytes<0x20,8>);
	[304] Disconnect();
	[400] InitializeSystem(u64, pid);
	[401] FinalizeSystem();
}

interface nn::ldn::detail::ISystemServiceCreator is ldn:s {
	# Returns an
	# [\#ISystemLocalCommunicationService](#nn::ldn::detail::ISystemLocalCommunicationService "wikilink").
	# 
	[0] CreateSystemLocalCommunicationService() -> object<nn::ldn::detail::ISystemLocalCommunicationService>;
}

interface nn::ldn::detail::IUserLocalCommunicationService {
	[0] GetState() -> u32;
	[1] GetNetworkInfo() -> buffer<unknown<0x480>,0x1a>;
	[2] GetIpv4Address() -> (u32, u32);
	[3] GetDisconnectReason() -> u16;
	[4] GetSecurityParameter() -> bytes<0x20,1>;
	[5] GetNetworkConfig() -> bytes<0x20,8>;
	[100] AttachStateChangeEvent() -> handle<copy>;
	[101] GetNetworkInfoLatestUpdate() -> (buffer<unknown<0x480>,0x1a>, buffer<unknown,0xa>);
	[102] Scan(u16, bytes<0x60,8>) -> (u16, buffer<unknown,0x22>);
	[103] ScanPrivate(u16, bytes<0x60,8>) -> (u16, buffer<unknown,0x22>);
	[200] OpenAccessPoint();
	[201] CloseAccessPoint();
	[202] CreateNetwork(bytes<0x44,2>, bytes<0x30,1>, bytes<0x20,8>);
	[203] CreateNetworkPrivate(bytes<0x44,2>, bytes<0x20,1>, bytes<0x30,1>, bytes<0x20,8>, buffer<unknown,9>);
	[204] DestroyNetwork();
	[205] Reject(u32);
	[206] SetAdvertiseData(buffer<unknown,0x21>);
	[207] SetStationAcceptPolicy(u8);
	[208] AddAcceptFilterEntry(bytes<6,1>);
	[209] ClearAcceptFilter();
	[300] OpenStation();
	[301] CloseStation();
	[302] Connect(bytes<0x44,2>, bytes<0x30,1>, u32, u32, buffer<unknown<0x480>,0x19>);
	[303] ConnectPrivate(bytes<0x44,2>, bytes<0x20,1>, bytes<0x30,1>, u32, u32, bytes<0x20,8>);
	[304] Disconnect();
	[400] Initialize(u64, pid);
	[401] Finalize();
}

interface nn::ldn::detail::IUserServiceCreator is ldn:u {
	# Returns an
	# [\#IUserLocalCommunicationService](#nn::ldn::detail::IUserLocalCommunicationService "wikilink").
	# 
	[0] CreateUserLocalCommunicationService() -> object<nn::ldn::detail::IUserLocalCommunicationService>;
}

interface nn::ldr::detail::IDebugMonitorInterface is ldr:dmnt {
	# Same as
	# [AddProcessToLaunchQueue](http://switchbrew.org/index.php?title=Loader_services#AddProcessToLaunchQueue "wikilink")
	# but for processes marked as debug.
	# 
	@undocumented
	[0] AddProcessToDebugLaunchQueue(unknown<0x10>, buffer<unknown,9>);
	# Same as
	# [ClearLaunchQueue](http://switchbrew.org/index.php?title=Loader_services#ClearLaunchQueue "wikilink").
	# 
	@undocumented
	[1] ClearDebugLaunchQueue();
	# Takes in a u64 ProcessID, and a C descriptor. Returns the number of
	# NsoInfos copied to output.
	# 
	# NsoInfo has the following layout:
	# 
	# | Offset | Size | Description                       |
	# | ------ | ---- | --------------------------------- |
	# | 0x0    | 0x20 | "Build ID", from NSO header+0x40. |
	# | 0x20   | 0x8  | Mapped address for this NSO       |
	# | 0x28   | 0x8  | Mapped size for this NSO          |
	# |        |      |                                   |
	# 
	@undocumented
	[2] GetNsoInfos(unknown<8>) -> (unknown<4>, buffer<unknown,0xa>);
}

interface nn::ldr::detail::IProcessManagerInterface is ldr:pm {
	@undocumented
	[0] CreateProcess(unknown<0x10>, handle<copy>) -> handle<move>;
	# Takes a TitleId + StorageId, parses the NPDM, and writes output to a C
	# descriptor buffer as
	# follows:
	# 
	# | Offset   | Size     | Description                                                                                                           |
	# | -------- | -------- | --------------------------------------------------------------------------------------------------------------------- |
	# | 0x0      | 0x1      | MainThreadPrio. Arg1 to svcStartProcess                                                                               |
	# | 0x1      | 0x1      | DefaultCpuId. Arg2 to svcStartProcess                                                                                 |
	# | 0x2      | 0x1      | ApplicationType, see [here](http://switchbrew.org/index.php?title=Process_Manager_services "wikilink").               |
	# | 0x3      | 0x1      | Padding                                                                                                               |
	# | 0x4      | 0x4      | MainThreadStackSize. Arg3 to svcStartProcess                                                                          |
	# | 0x8      | 0x8      | TitleIdRange\_Min                                                                                                     |
	# | 0x10     | 0x4      | ACID [Service Access Control](http://switchbrew.org/index.php?title=NPDM#Service_Access_Control "wikilink") list size |
	# | 0x14     | 0x4      | ACI0 [Service Access Control](http://switchbrew.org/index.php?title=NPDM#Service_Access_Control "wikilink") list size |
	# | 0x18     | 0x4      | ACID [FS Access Control](http://switchbrew.org/index.php?title=NPDM#FS_Access_Control "wikilink") buffer size         |
	# | 0x1C     | 0x4      | ACI0 [FS Access Control](http://switchbrew.org/index.php?title=NPDM#FS_Access_Control "wikilink") buffer size         |
	# | 0x20     | <Varies> | ACID [Service Access Control](http://switchbrew.org/index.php?title=NPDM#Service_Access_Control "wikilink") list      |
	# | <Varies> | <Varies> | ACI0 [Service Access Control](http://switchbrew.org/index.php?title=NPDM#Service_Access_Control "wikilink") list      |
	# | <Varies> | <Varies> | ACID [FS Access Control](http://switchbrew.org/index.php?title=NPDM#FS_Access_Control "wikilink") buffer              |
	# | <Varies> | <Varies> | ACI0 [FS Access Control](http://switchbrew.org/index.php?title=NPDM#FS_Access_Control "wikilink")                     |
	# 
	@undocumented
	[1] GetProgramInfo(unknown<0x10>) -> buffer<unknown,0x1a>;
	# Takes a TitleId + StorageId, returns an index.
	# 
	@undocumented
	[2] RegisterTitle(unknown<0x10>) -> unknown<8>;
	# Takes the index from
	# [\#RegisterTitle](#nn::ldr::detail::IProcessManagerInterface\(2\) "wikilink").
	# 
	@undocumented
	[3] UnregisterTitle(unknown<8>);
}

interface nn::ldr::detail::IRoInterface is ldr:ro {
	# | Word | Value                    |
	# | ---- | ------------------------ |
	# | 0    | 0x00000004               |
	# | 1    | 0x80000012               |
	# | 2    | 0x00000001               |
	# | 0-1  | Pid                      |
	# | 0    | "SCFI"                   |
	# | 1    | 0x00000000               |
	# | 2    | Always 0.                |
	# | 3    | Nro heap address         |
	# | 4    | Nro size                 |
	# | 5    | Bss backing heap address |
	# | 6    | Bss size                 |
	# 
	[0] LoadNro(u64, u64, u64, u64, u64, pid) -> u64;
	[1] UnloadNro(u64, u64, pid);
	# | Word | Value       |
	# | ---- | ----------- |
	# | 0    | 0x00000004  |
	# | 1    | 0x8000000E  |
	# | 2    | 0x00000001  |
	# |      |             |
	# | 0-1  | Pid         |
	# | 0    | "SFCI"      |
	# | 1    | 0x00000002  |
	# | 2    | Always 0.   |
	# | 3    | Nrr address |
	# | 4    | Nrr size    |
	# 
	[2] LoadNrr(u64, u64, u64, pid);
	[3] UnloadNrr(u64, u64, pid);
	# | Word | Value                       |
	# | ---- | --------------------------- |
	# | 0    | 0x00000004                  |
	# | 1    | 0x8000000A                  |
	# | 2    | 0x00000003                  |
	# | 0-1  | Pid                         |
	# | 2    | Process handle (0xFFFF8001) |
	# | 0    | "SFCI"                      |
	# | 1    | 0x00000004                  |
	# | 2    | Always 0.                   |
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[4] Initialize(u64, pid, handle<copy>);
}

interface nn::ldr::detail::IShellInterface is ldr:shel {
	# Takes a type-0x19 input buffer with launch arguments (as string), an u32
	# (size of arguments string), and an input title-id.
	# 
	# Loads a process for the specified title-id and passes along the supplied
	# arguments. Loaded processes are kept in a queue waiting for PM to launch
	# them. The maximum number of waiting processes in this list is 10.
	# 
	@undocumented
	[0] AddProcessToLaunchQueue(unknown<0x10>, buffer<unknown,9>);
	# Clears the loaded processes waiting queue.
	# 
	@undocumented
	[1] ClearLaunchQueue();
}

interface nn::lm::ILogGetter is lm:get {
	@undocumented
	[0] StartLogging(unknown) -> unknown;
	@undocumented
	[1] StopLogging(unknown) -> unknown;
	@undocumented
	[2] GetLog(unknown) -> unknown;
}

interface nn::lm::ILogService is lm {
	[0] OpenLogger(u64, pid) -> object<nn::lm::ILogger>;
}

interface nn::lm::ILogger {
	[0] Initialize(buffer<unknown,0x21>);
	@version(3.0.0+)
	[1] SetDestination(u32);
}

interface nn::lr::IAddOnContentLocationResolver {
	@undocumented
	[0] ResolveAddOnContentPath(unknown<8>) -> buffer<unknown,0x1a>;
	@undocumented
	[1] RegisterAddOnContentStorage(unknown<0x10>);
	@undocumented
	[2] UnregisterAllAddOnContentPath();
}

interface nn::lr::ILocationResolver {
	# Takes an u64 **TitleID** and a C descriptor. Used for
	# [NCA-type1](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type1 "wikilink").
	# 
	@undocumented
	[0] ResolveProgramPath(unknown<8>) -> buffer<unknown,0x1a>;
	# Takes an u64 **TitleID** and a X descriptor with a
	# [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink").
	# Used for
	# [NCA-type1](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type1 "wikilink").
	# 
	# Inserts a new
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# with **flag** set to 0.
	# 
	@undocumented
	[1] RedirectProgramPath(unknown<8>, buffer<unknown,0x19>);
	# Takes an u64 **TitleID** and a C descriptor. Used for
	# [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	@undocumented
	[2] ResolveApplicationControlPath(unknown<8>) -> buffer<unknown,0x1a>;
	# Takes an u64 **TitleID** and a C descriptor. Used for
	# [NCA-type4](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type4 "wikilink").
	# 
	@undocumented
	[3] ResolveApplicationHtmlDocumentPath(unknown<8>) -> buffer<unknown,0x1a>;
	# Takes an u64 **TitleID** and a C descriptor. Used for
	# [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	@undocumented
	[4] ResolveDataPath(unknown<8>) -> buffer<unknown,0x1a>;
	# Takes an u64 **TitleID** and a X descriptor with a
	# [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink").
	# Used for
	# [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	# Inserts a new
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# with **flag** set to 1.
	# 
	@undocumented
	[5] RedirectApplicationControlPath(unknown<8>, buffer<unknown,0x19>);
	# Takes an u64 **TitleID** and a X descriptor with a
	# [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink").
	# Used for
	# [NCA-type4](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type4 "wikilink").
	# 
	# Inserts a new
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# with **flag** set to 1.
	# 
	@undocumented
	[6] RedirectApplicationHtmlDocumentPath(unknown<8>, buffer<unknown,0x19>);
	# Takes an u64 **TitleID** and a C descriptor. Used for
	# [NCA-type5](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type5 "wikilink").
	# 
	@undocumented
	[7] ResolveApplicationLegalInformationPath(unknown<8>) -> buffer<unknown,0x1a>;
	# Takes an u64 **TitleID** and a X descriptor with a
	# [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services#ContentPath "wikilink").
	# Used for
	# [NCA-type5](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type5 "wikilink").
	# 
	# Inserts a new
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# with **flag** set to 1.
	# 
	@undocumented
	[8] RedirectApplicationLegalInformationPath(unknown<8>, buffer<unknown,0x19>);
	# Takes no input. Frees all linked-lists' entries that have **flag** set
	# to 0.
	# 
	@undocumented
	[9] Refresh();
	# Same as
	# [SetProgramNcaPath](http://switchbrew.org/index.php?title=NCM%20services#SetProgramNcaPath "wikilink"),
	# but inserts a new
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# with **flag** set to 1.
	# 
	@version(5.0.0+)
	@undocumented
	[10] SetProgramNcaPath2(unknown) -> unknown;
	# Takes no input. Frees all linked-lists' entries that have **flag** set
	# to 1.
	# 
	@version(5.0.0+)
	@undocumented
	[11] ClearLocationResolver2(unknown) -> unknown;
	# Takes an u64 **TitleID**. Used for
	# [NCA-type1](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type1 "wikilink").
	# 
	# Removes the
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# that matches the input TitleID.
	# 
	@version(5.0.0+)
	@undocumented
	[12] DeleteProgramNcaPath(unknown) -> unknown;
	# Takes an u64 **TitleID**. Used for
	# [NCA-type3](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type3 "wikilink").
	# 
	# Removes the
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# that matches the input TitleID.
	# 
	@version(5.0.0+)
	@undocumented
	[13] DeleteControlNcaPath(unknown) -> unknown;
	# Takes an u64 **TitleID**. Used for
	# [NCA-type4](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type4 "wikilink").
	# 
	# Removes the
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# that matches the input TitleID.
	# 
	@version(5.0.0+)
	@undocumented
	[14] DeleteDocHtmlNcaPath(unknown) -> unknown;
	# Takes an u64 **TitleID**. Used for
	# [NCA-type5](http://switchbrew.org/index.php?title=NCA_Content_FS#NCA-type5 "wikilink").
	# 
	# Removes the
	# [entry](http://switchbrew.org/index.php?title=NCM%20services#Location_List_Entry "wikilink")
	# that matches the input TitleID.
	# 
	@version(5.0.0+)
	@undocumented
	[15] DeleteInfoHtmlNcaPath(unknown) -> unknown;
}

interface nn::lr::ILocationResolverManager is lr {
	@undocumented
	[0] OpenLocationResolver(unknown<1>) -> object<nn::lr::ILocationResolver>;
	@undocumented
	[1] OpenRegisteredLocationResolver() -> object<nn::lr::IRegisteredLocationResolver>;
	@undocumented
	[2] RefreshLocationResolver(unknown<1>);
	@version(2.0.0+)
	@undocumented
	[3] OpenAddOnContentLocationResolver() -> object<nn::lr::IAddOnContentLocationResolver>;
}

interface nn::lr::IRegisteredLocationResolver {
	@undocumented
	[0] ResolveProgramPath(unknown<8>) -> buffer<unknown,0x1a>;
	@undocumented
	[1] RegisterProgramPath(unknown<8>, buffer<unknown,0x19>);
	@undocumented
	[2] UnregisterProgramPath(unknown<8>);
	@undocumented
	[3] RedirectProgramPath(unknown<8>, buffer<unknown,0x19>);
	@version(2.0.0+)
	@undocumented
	[4] ResolveHtmlDocumentPath(unknown<8>) -> buffer<unknown,0x1a>;
	@version(2.0.0+)
	@undocumented
	[5] RegisterHtmlDocumentPath(unknown<8>, buffer<unknown,0x19>);
	@version(2.0.0+)
	@undocumented
	[6] UnregisterHtmlDocumentPath(unknown<8>);
	@version(2.0.0+)
	@undocumented
	[7] RedirectHtmlDocumentPath(unknown<8>, buffer<unknown,0x19>);
}

interface nn::migration::user::IAsyncContext {
	@undocumented
	[0] GetSystemEvent(unknown) -> unknown;
	@undocumented
	[1] Cancel(unknown) -> unknown;
	@undocumented
	[2] HasDone(unknown) -> unknown;
	@undocumented
	[3] GetResult(unknown) -> unknown;
}

interface nn::migration::user::IClient {
	@undocumented
	[0] GetClientProfile() -> buffer<unknown,0x1a>;
	@undocumented
	[10] CreateLoginSession() -> unknown<0x10>;
	@undocumented
	[11] GetNetworkServiceAccountId() -> unknown<8>;
	@undocumented
	[12] GetUserNickname() -> unknown<0x21>;
	@undocumented
	[13] GetUserProfileImage() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[100] PrepareAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[101] GetConnectionRequirement() -> unknown<1>;
	@undocumented
	[200] ScanServersAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[201] ListServers() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[210] ConnectByServerIdAsync(unknown<0x10>) -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[300] GetStorageShortfall() -> unknown<8>;
	@undocumented
	[301] GetTotalTransferInfo() -> unknown<0x10>;
	@undocumented
	[302] GetImmigrantUid() -> unknown<0x10>;
	@undocumented
	[310] GetCurrentTransferInfo() -> unknown<0x10>;
	@undocumented
	[311] GetCurrentRelatedApplications() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[320] TransferNextAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[350] SuspendAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[400] CompleteAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[500] Abort();
	@undocumented
	[999] DebugSynchronizeStateInFinalizationAsync() -> object<nn::migration::detail::IAsyncContext>;
}

interface nn::migration::user::IServer {
	@undocumented
	[0] GetUid() -> unknown<0x10>;
	@undocumented
	[1] GetServerProfile() -> buffer<unknown,0x1a>;
	@undocumented
	[100] PrepareAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[101] GetConnectionRequirement() -> unknown<1>;
	@undocumented
	[200] WaitConnectionAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[201] GetClientProfile() -> buffer<unknown,0x1a>;
	@undocumented
	[202] AcceptConnectionAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[203] DeclineConnectionAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[300] ProcessTransferAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[400] CompleteAsync() -> object<nn::migration::detail::IAsyncContext>;
	@undocumented
	[500] Abort();
}

interface nn::migration::user::IService is mig:usr {
	@undocumented
	[10] TryGetLastMigrationInfo() -> unknown<0xc>;
	@undocumented
	[100] CreateServer(unknown<0x18>, handle<copy>, buffer<unknown,0x19>) -> object<nn::migration::user::IServer>;
	@undocumented
	[101] ResumeServer(unknown<4>, handle<copy>) -> object<nn::migration::user::IServer>;
	@undocumented
	[200] CreateClient(unknown<4>, handle<copy>, buffer<unknown,0x19>) -> object<nn::migration::user::IClient>;
	@undocumented
	[201] ResumeClient(unknown<4>, handle<copy>) -> object<nn::migration::user::IClient>;
}

interface nn::mii::detail::IDatabaseService {
	[0] IsUpdated(u32) -> b8;
	[1] IsFullDatabase() -> b8;
	[2] GetCount(u32) -> u32;
	[3] Get(u32) -> (u32, buffer<nn::mii::CharInfoElement,6>);
	[4] Get1(u32) -> (u32, buffer<nn::mii::CharInfo,6>);
	[5] UpdateLatest(nn::mii::CharInfo, u32) -> nn::mii::CharInfo;
	[6] BuildRandom(u32, u32, u32) -> nn::mii::CharInfo;
	[7] BuildDefault(u32) -> nn::mii::CharInfo;
	[8] Get2(u32) -> (u32, buffer<nn::mii::StoreDataElement,6>);
	[9] Get3(u32) -> (u32, buffer<nn::mii::StoreData,6>);
	[10] UpdateLatest1(nn::mii::StoreData, u32) -> nn::mii::StoreData;
	[11] FindIndex(nn::mii::CreateId, b8) -> u32;
	[12] Move(nn::mii::CreateId, u32);
	[13] AddOrReplace(nn::mii::StoreData);
	[14] Delete(nn::mii::CreateId);
	[15] DestroyFile();
	[16] DeleteFile();
	[17] Format();
	[18] Import(buffer<bytes,5>);
	[19] Export() -> buffer<bytes,6>;
	[20] IsBrokenDatabaseWithClearFlag() -> b8;
	[21] GetIndex(nn::mii::CharInfo) -> u32;
	@version(5.0.0+)
	@undocumented
	[22] SetInterfaceVersion(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[23] Convert(unknown) -> unknown;
}

interface nn::mii::detail::IImageDatabaseService is miiimg {
	@undocumented
	[0] Initialize(unknown) -> unknown;
	@undocumented
	[10] Reload(unknown) -> unknown;
	@undocumented
	[11] GetCount(unknown) -> unknown;
	@undocumented
	[12] IsEmpty(unknown) -> unknown;
	@undocumented
	[13] IsFull(unknown) -> unknown;
	@undocumented
	[14] GetAttribute(unknown) -> unknown;
	@undocumented
	[15] LoadImage(unknown) -> unknown;
	@undocumented
	[16] AddOrUpdateImage(unknown) -> unknown;
	@undocumented
	[17] DeleteImages(unknown) -> unknown;
	@undocumented
	[100] DeleteFile(unknown) -> unknown;
	@undocumented
	[101] DestroyFile(unknown) -> unknown;
	@undocumented
	[102] ImportFile(unknown) -> unknown;
	@undocumented
	[103] ExportFile(unknown) -> unknown;
	@undocumented
	[104] ForceInitialize(unknown) -> unknown;
}

interface nn::mii::detail::IStaticService is mii:u, mii:e {
	[0] GetDatabaseService(u32) -> object<nn::mii::detail::IDatabaseService>;
}

interface nn::mmnv::IRequest is mm:u {
	[0] InitializeOld(u32, u32, u32);
	[1] FinalizeOld(u32);
	[2] SetAndWaitOld(u32, u32, u32);
	[3] GetOld(u32) -> u32;
	[4] Initialize(u32, u32, u32) -> u32;
	[5] Finalize(u32);
	[6] SetAndWait(u32, u32, u32);
	[7] Get(u32) -> u32;
}

interface nn::ncm::IContentManager is ncm {
	@undocumented
	[0] CreateContentStorage(unknown<1>);
	@undocumented
	[1] CreateContentMetaDatabase(unknown<1>);
	@undocumented
	[2] VerifyContentStorage(unknown<1>);
	@undocumented
	[3] VerifyContentMetaDatabase(unknown<1>);
	@undocumented
	[4] OpenContentStorage(unknown<1>) -> object<nn::ncm::IContentStorage>;
	@undocumented
	[5] OpenContentMetaDatabase(unknown<1>) -> object<nn::ncm::IContentMetaDatabase>;
	@version(1.0.0)
	@undocumented
	[6] CloseContentStorageForcibly(unknown<1>);
	@version(1.0.0)
	@undocumented
	[7] CloseContentMetaDatabaseForcibly(unknown<1>);
	@undocumented
	[8] CleanupContentMetaDatabase(unknown<1>);
	@version(2.0.0+)
	@undocumented
	[9] OpenContentStorage2(unknown<1>);
	@version(2.0.0+)
	@undocumented
	[10] CloseContentStorage(unknown<1>);
	@version(2.0.0+)
	@undocumented
	[11] OpenContentMetaDatabase2(unknown<1>);
	@version(2.0.0+)
	@undocumented
	[12] CloseContentMetaDatabase(unknown<1>);
}

interface nn::ncm::IContentMetaDatabase {
	@undocumented
	[0] Set(unknown<0x10>, buffer<unknown,5>);
	@undocumented
	[1] Get(unknown<0x10>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[2] Remove(unknown<0x10>);
	@undocumented
	[3] GetContentIdByType(unknown<0x18>) -> unknown<0x10>;
	@undocumented
	[4] ListContentInfo(unknown<0x18>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[5] List(unknown<0x20>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[6] GetLatestContentMetaKey(unknown<8>) -> unknown<0x10>;
	# Each 24-byte entry (officially "ApplicationContentMetaKey") is as
	# follows:
	# 
	# ` `[`meta_record`](http://switchbrew.org/index.php?title=NCA#Meta_records "wikilink")` meta_record;`  
	# ` u64    base_title_id;`
	# 
	# This function takes in a type 6 buffer to write entries to, and a u8
	# "filter"
	# [type](http://switchbrew.org/index.php?title=NCM%20services#Title_Types "wikilink").
	# If filter is zero, all update records will be copied to to the output
	# buffer (space permitting). Otherwise, only titles with type ==
	# filter\_type will be copied to the output buffer.
	# 
	# This func returns a u32 num\_entries\_total, and a u32
	# num\_entries\_written.
	# 
	@undocumented
	[7] ListApplication(unknown<1>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[8] Has(unknown<0x10>) -> unknown<1>;
	@undocumented
	[9] HasAll(buffer<unknown,5>) -> unknown<1>;
	@undocumented
	[10] GetSize(unknown<0x10>) -> unknown<8>;
	@undocumented
	[11] GetRequiredSystemVersion(unknown<0x10>) -> unknown<4>;
	@undocumented
	[12] GetPatchId(unknown<0x10>) -> unknown<8>;
	@undocumented
	[13] DisableForcibly();
	# Takes a type-6 byte buffer, and a type-5 buffer containing
	# [\#NcaIDs](http://switchbrew.org/index.php?title=NCM%20services#NcaID "wikilink").
	# 
	# This function was stubbed to return 0xDC05 in
	# [2.0.0](http://switchbrew.org/index.php?title=2.0.0 "wikilink").
	# 
	# On 1.0.0: Initialized the output buffer to all 1s. Then, for each
	# [\#NcaID](http://switchbrew.org/index.php?title=NCM%20services#NcaID "wikilink")
	# in the input buffer, it checks if that NcaID is present anywhere in the
	# database, and if so writes 0 to the corresponding output byte.
	# 
	# In pseudocode, the function basically does the following:
	# 
	# for i in range(len(out\_buf)):
	# 
	# `   out_buf[i] = 1`
	# 
	# for i, NcaID in NcaIDs:
	# 
	# `   if is_present_in_database(NcaID):`  
	# `       out_buf[i] = 0`
	# 
	@undocumented
	[14] LookupOrphanContent(buffer<unknown,5>) -> buffer<unknown,6>;
	@undocumented
	[15] Commit();
	@undocumented
	[16] HasContent(unknown<0x20>) -> unknown<1>;
	@undocumented
	[17] ListContentMetaInfo(unknown<0x18>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[18] GetAttributes(unknown<0x10>) -> unknown<1>;
	@version(2.0.0+)
	@undocumented
	[19] GetRequiredApplicationVersion(unknown<0x10>) -> unknown<4>;
	@version(5.0.0+)
	@undocumented
	[20] Unknown20(unknown) -> unknown;
}

interface nn::ncm::IContentStorage {
	# Generates a random
	# [\#NcaID](http://switchbrew.org/index.php?title=NCM%20services#NcaID "wikilink")
	# for use as a placeholder.
	# 
	# Calls nn::util::GenerateUuid(), which internally calls
	# nn::os::GenerateRandomBytes(16);
	# 
	@undocumented
	[0] GeneratePlaceHolderId() -> unknown<0x10>;
	@undocumented
	[1] CreatePlaceHolder(unknown<0x28>);
	@undocumented
	[2] DeletePlaceHolder(unknown<0x10>);
	@undocumented
	[3] HasPlaceHolder(unknown<0x10>) -> unknown<1>;
	@undocumented
	[4] WritePlaceHolder(unknown<0x18>, buffer<unknown,5>);
	@undocumented
	[5] Register(unknown<0x20>);
	@undocumented
	[6] Delete(unknown<0x10>);
	@undocumented
	[7] Has(unknown<0x10>) -> unknown<1>;
	@undocumented
	[8] GetPath(unknown<0x10>) -> buffer<unknown,0x1a>;
	@undocumented
	[9] GetPlaceHolderPath(unknown<0x10>) -> buffer<unknown,0x1a>;
	@undocumented
	[10] CleanupAllPlaceHolder();
	@undocumented
	[11] ListPlaceHolder() -> (unknown<4>, buffer<unknown,6>);
	# Writes the total number of entries which can be read by GetEntries, to
	# cmdreply <SFCO_offset>+0x10.
	# 
	@undocumented
	[12] GetContentCount() -> unknown<4>;
	# Takes an output buffer, u32 offset and gets all entries starting at that
	# offset. Returns number of entries read.
	# 
	# Each entry is a
	# [\#NcaID](http://switchbrew.org/index.php?title=NCM%20services#NcaID "wikilink").
	# 
	# The total read entries is exactly the same as the number of "<hex>.nca"
	# directories in the storage FS(or at least under the "registered"
	# directory?).
	# 
	@undocumented
	[13] ListContentId(unknown<4>) -> (unknown<4>, buffer<unknown,6>);
	# Takes a
	# [\#NcaID](http://switchbrew.org/index.php?title=NCM%20services#NcaID "wikilink")
	# as input.
	# 
	# Returns the total size readable by ReadEntryRaw. This is the same as the
	# size-field in the
	# [NAX0](http://switchbrew.org/index.php?title=NAX0 "wikilink")
	# "<NcaID>.nca/00" file.
	# 
	@undocumented
	[14] GetSize(unknown<0x10>) -> unknown<8>;
	@undocumented
	[15] DisableForcibly();
	@version(2.0.0+)
	@undocumented
	[16] RevertToPlaceHolder(unknown<0x30>);
	@version(2.0.0+)
	@undocumented
	[17] SetPlaceHolderSize(unknown<0x18>);
	# Takes an output buffer, a
	# [\#NcaID](http://switchbrew.org/index.php?title=NCM%20services#NcaID "wikilink")
	# as input, and a u64 file offset.
	# 
	# Reads plaintext NCA file contents from the Registered path for the
	# NcaID.
	# 
	@version(2.0.0+)
	@undocumented
	[18] ReadContentIdFile(unknown<0x18>) -> buffer<unknown,6>;
	@version(2.0.0+)
	@undocumented
	[19] GetRightsIdFromPlaceHolderId(unknown<0x10>) -> unknown<0x18>;
	@version(2.0.0+)
	@undocumented
	[20] GetRightsIdFromContentId(unknown<0x10>) -> unknown<0x18>;
	@version(2.0.0+)
	@undocumented
	[21] WriteContentForDebug(unknown<0x18>, buffer<unknown,5>);
	@version(2.0.0+)
	@undocumented
	[22] GetFreeSpaceSize() -> unknown<8>;
	@version(2.0.0+)
	@undocumented
	[23] GetTotalSpaceSize() -> unknown<8>;
	@version(3.0.0+)
	@undocumented
	[24] FlushStorage();
	@version(4.0.0+)
	@undocumented
	[25] Unknown25(unknown<0x10>) -> unknown<8>;
	@version(4.0.0+)
	@undocumented
	[26] Unknown26();
}

interface nn::news::detail::ipc::IServiceCreator is news:a, news:c, news:m, news:p, news:v {
	@undocumented
	[0] Unknown0() -> object<nn::news::detail::ipc::INewsService>;
	@undocumented
	[1] Unknown1() -> object<nn::news::detail::ipc::INewlyArrivedEventHolder>;
	@undocumented
	[2] Unknown2() -> object<nn::news::detail::ipc::INewsDataService>;
	@undocumented
	[3] Unknown3() -> object<nn::news::detail::ipc::INewsDatabaseService>;
	@undocumented
	[4] Unknown4() -> object<nn::news::detail::ipc::IOverwriteEventHolder>;
}

interface nn::nfc::am::detail::IAm {
	@undocumented
	[0] Initialize();
	@undocumented
	[1] Finalize();
	@undocumented
	[2] NotifyForegroundApplet(unknown<8>);
}

interface nn::nfc::am::detail::IAmManager is nfc:am {
	@undocumented
	[0] CreateAmInterface() -> object<nn::nfc::am::detail::IAm>;
}

interface nn::nfc::detail::ISystem {
	[0] Initialize(u64, u64, pid, buffer<unknown,5>);
	[1] Finalize();
	[2] GetStateOld() -> u32;
	[3] IsNfcEnabledOld() -> u8;
	[100] SetNfcEnabledOld(u8);
	@version(4.0.0+)
	[400] InitializeSystem(u64, u64, pid, buffer<unknown,5>);
	@version(4.0.0+)
	[401] FinalizeSystem();
	@version(4.0.0+)
	[402] GetState() -> u32;
	@version(4.0.0+)
	[403] IsNfcEnabled() -> u8;
	@version(4.0.0+)
	[404] ListDevices() -> (u32, buffer<unknown,0xa>);
	@version(4.0.0+)
	[405] GetDeviceState(bytes<8,4>) -> u32;
	@version(4.0.0+)
	[406] GetNpadId(bytes<8,4>) -> u32;
	@version(4.0.0+)
	[407] AttachAvailabilityChangeEvent() -> handle<copy>;
	@version(4.0.0+)
	[408] StartDetection(bytes<8,4>, u32);
	@version(4.0.0+)
	[409] StopDetection(bytes<8,4>);
	@version(4.0.0+)
	[410] GetTagInfo(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	@version(4.0.0+)
	[411] AttachActivateEvent(bytes<8,4>) -> handle<copy>;
	@version(4.0.0+)
	[412] AttachDeactivateEvent(bytes<8,4>) -> handle<copy>;
	@version(4.0.0+)
	[500] SetNfcEnabled(u8);
	@version(4.0.0+)
	[1000] ReadMifare(bytes<8,4>, buffer<unknown,5>) -> buffer<unknown,6>;
	@version(4.0.0+)
	[1001] WriteMifare(bytes<8,4>, buffer<unknown,5>);
	@version(4.0.0+)
	[1300] SendCommandByPassThrough(bytes<8,4>, u64, buffer<unknown,5>) -> (u32, buffer<unknown,6>);
	@version(4.0.0+)
	[1301] KeepPassThroughSession(bytes<8,4>);
	@version(4.0.0+)
	[1302] ReleasePassThroughSession(bytes<8,4>);
}

interface nn::nfc::detail::ISystemManager is nfc:sys {
	[0] CreateSystemInterface() -> object<nn::nfc::detail::ISystem>;
}

interface nn::nfc::detail::IUser {
	[0] InitializeOld(u64, u64, pid, buffer<unknown,5>);
	[1] FinalizeOld();
	[2] GetStateOld() -> u32;
	[3] IsNfcEnabledOld() -> u8;
	@version(4.0.0+)
	[400] Initialize(u64, u64, pid, buffer<unknown,5>);
	@version(4.0.0+)
	[401] Finalize();
	@version(4.0.0+)
	[402] GetState() -> u32;
	@version(4.0.0+)
	[403] IsNfcEnabled() -> u8;
	@version(4.0.0+)
	[404] ListDevices() -> (u32, buffer<unknown,0xa>);
	@version(4.0.0+)
	[405] GetDeviceState(bytes<8,4>) -> u32;
	@version(4.0.0+)
	[406] GetNpadId(bytes<8,4>) -> u32;
	@version(4.0.0+)
	[407] AttachAvailabilityChangeEvent() -> handle<copy>;
	@version(4.0.0+)
	[408] StartDetection(bytes<8,4>, u32);
	@version(4.0.0+)
	[409] StopDetection(bytes<8,4>);
	@version(4.0.0+)
	[410] GetTagInfo(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	@version(4.0.0+)
	[411] AttachActivateEvent(bytes<8,4>) -> handle<copy>;
	@version(4.0.0+)
	[412] AttachDeactivateEvent(bytes<8,4>) -> handle<copy>;
	@version(4.0.0+)
	[1000] ReadMifare(bytes<8,4>, buffer<unknown,5>) -> buffer<unknown,6>;
	@version(4.0.0+)
	[1001] WriteMifare(bytes<8,4>, buffer<unknown,5>);
	@version(4.0.0+)
	[1300] SendCommandByPassThrough(bytes<8,4>, u64, buffer<unknown,5>) -> (u32, buffer<unknown,6>);
	@version(4.0.0+)
	[1301] KeepPassThroughSession(bytes<8,4>);
	@version(4.0.0+)
	[1302] ReleasePassThroughSession(bytes<8,4>);
}

interface nn::nfc::detail::IUserManager is nfc:user {
	[0] CreateUserInterface() -> object<nn::nfc::mifare::detail::IUser>;
}

interface nn::nfc::mifare::detail::IUser {
	[0] Initialize(u64, u64, pid, buffer<unknown,5>);
	[1] Finalize();
	[2] ListDevices() -> (u32, buffer<unknown,0xa>);
	[3] StartDetection(bytes<8,4>);
	[4] StopDetection(bytes<8,4>);
	[5] Read(bytes<8,4>, buffer<unknown,5>) -> buffer<unknown,6>;
	[6] Write(bytes<8,4>, buffer<unknown,5>);
	[7] GetTagInfo(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	[8] GetActivateEventHandle(bytes<8,4>) -> handle<copy>;
	[9] GetDeactivateEventHandle(bytes<8,4>) -> handle<copy>;
	[10] GetState() -> u32;
	[11] GetDeviceState(bytes<8,4>) -> u32;
	[12] GetNpadId(bytes<8,4>) -> u32;
	[13] GetAvailabilityChangeEventHandle() -> handle<copy>;
}

interface nn::nfc::mifare::detail::IUserManager is nfc:mf:u {
	@undocumented
	[0] CreateUserInterface() -> object<nn::nfc::detail::IUser>;
}

interface nn::nfp::detail::IDebug {
	[0] InitializeDebug(u64, u64, pid, buffer<unknown,5>);
	[1] FinalizeDebug();
	[2] ListDevices() -> (u32, buffer<unknown,0xa>);
	[3] StartDetection(bytes<8,4>);
	[4] StopDetection(bytes<8,4>);
	[5] Mount(bytes<8,4>, u32, u32);
	[6] Unmount(bytes<8,4>);
	[7] OpenApplicationArea(bytes<8,4>, u32);
	[8] GetApplicationArea(bytes<8,4>) -> (u32, buffer<unknown,6>);
	[9] SetApplicationArea(bytes<8,4>, buffer<unknown,5>);
	[10] Flush(bytes<8,4>);
	[11] Restore(bytes<8,4>);
	[12] CreateApplicationArea(bytes<8,4>, u32, buffer<unknown,5>);
	[13] GetTagInfo(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	[14] GetRegisterInfo(bytes<8,4>) -> buffer<unknown<0x100>,0x1a>;
	[15] GetCommonInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[16] GetModelInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[17] AttachActivateEvent(bytes<8,4>) -> handle<copy>;
	[18] AttachDeactivateEvent(bytes<8,4>) -> handle<copy>;
	[19] GetState() -> u32;
	[20] GetDeviceState(bytes<8,4>) -> u32;
	[21] GetNpadId(bytes<8,4>) -> u32;
	[22] GetApplicationArea2(bytes<8,4>) -> u32;
	[23] AttachAvailabilityChangeEvent() -> handle<copy>;
	[24] RecreateApplicationArea(bytes<8,4>, u32, buffer<unknown,5>);
	[100] Format(bytes<8,4>);
	[101] GetAdminInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[102] GetRegisterInfo2(bytes<8,4>) -> buffer<unknown<0x100>,0x1a>;
	[103] SetRegisterInfo(bytes<8,4>, buffer<unknown<0x100>,0x19>);
	[104] DeleteRegisterInfo(bytes<8,4>);
	[105] DeleteApplicationArea(bytes<8,4>);
	[106] ExistsApplicationArea(bytes<8,4>) -> u8;
	[200] GetAll(bytes<8,4>) -> buffer<unknown<0x298>,0x1a>;
	[201] SetAll(bytes<8,4>, buffer<unknown<0x298>,0x19>);
	[202] FlushDebug(bytes<8,4>);
	[203] BreakTag(bytes<8,4>, u32);
	[204] ReadBackupData() -> (u32, buffer<unknown,6>);
	[205] WriteBackupData(buffer<unknown,5>);
	[206] WriteNtf(bytes<8,4>, u32, buffer<unknown,5>);
	@version(1.0.0-3.0.2)
	[300] Unknown300(u64, u64, pid, buffer<unknown,5>);
	@version(1.0.0-3.0.2)
	[301] Unknown301();
	@version(1.0.0-3.0.2)
	[302] Unknown302() -> (u32, buffer<unknown,0xa>);
	@version(1.0.0-3.0.2)
	[303] Unknown303(bytes<8,4>, u32);
	@version(1.0.0-3.0.2)
	[304] Unknown304(bytes<8,4>);
	@version(1.0.0-3.0.2)
	[305] Unknown305(bytes<8,4>, u64, buffer<unknown,5>) -> (u32, buffer<unknown,6>);
	@version(1.0.0-3.0.2)
	[306] Unknown306(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	@version(1.0.0-3.0.2)
	[307] Unknown307(bytes<8,4>) -> handle<copy>;
	@version(1.0.0-3.0.2)
	[308] Unknown308(bytes<8,4>) -> handle<copy>;
	@version(1.0.0-3.0.2)
	[309] Unknown309() -> u32;
	@version(1.0.0-3.0.2)
	[310] Unknown310(bytes<8,4>) -> u32;
	@version(1.0.0-3.0.2)
	[311] Unknown311(bytes<8,4>) -> u32;
	@version(1.0.0-3.0.2)
	[312] Unknown312(bytes<8,4>);
	@version(1.0.0-3.0.2)
	[313] Unknown313(bytes<8,4>);
	@version(1.0.0-3.0.2)
	[314] Unknown314() -> handle<copy>;
}

interface nn::nfp::detail::IDebugManager is nfp:dbg {
	[0] CreateDebugInterface() -> object<nn::nfp::detail::IDebug>;
}

interface nn::nfp::detail::ISystem {
	[0] InitializeSystem(u64, u64, pid, buffer<unknown,5>);
	[1] FinalizeSystem();
	[2] ListDevices() -> (u32, buffer<unknown,0xa>);
	[3] StartDetection(bytes<8,4>);
	[4] StopDetection(bytes<8,4>);
	[5] Mount(bytes<8,4>, u32, u32);
	[6] Unmount(bytes<8,4>);
	[10] Flush(bytes<8,4>);
	[11] Restore(bytes<8,4>);
	[13] GetTagInfo(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	[14] GetRegisterInfo(bytes<8,4>) -> buffer<unknown<0x100>,0x1a>;
	[15] GetCommonInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[16] GetModelInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[17] AttachActivateEvent(bytes<8,4>) -> handle<copy>;
	[18] AttachDeactivateEvent(bytes<8,4>) -> handle<copy>;
	[19] GetState() -> u32;
	[20] GetDeviceState(bytes<8,4>) -> u32;
	[21] GetNpadId(bytes<8,4>) -> u32;
	[23] AttachAvailabilityChangeEvent() -> handle<copy>;
	[100] Format(bytes<8,4>);
	[101] GetAdminInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[102] GetRegisterInfo2(bytes<8,4>) -> buffer<unknown<0x100>,0x1a>;
	[103] SetRegisterInfo(bytes<8,4>, buffer<unknown<0x100>,0x19>);
	[104] DeleteRegisterInfo(bytes<8,4>);
	[105] DeleteApplicationArea(bytes<8,4>);
	[106] ExistsApplicationArea(bytes<8,4>) -> u8;
}

interface nn::nfp::detail::ISystemManager is nfp:sys {
	[0] CreateSystemInterface() -> object<nn::nfp::detail::ISystem>;
}

interface nn::nfp::detail::IUser {
	[0] Initialize(u64, u64, pid, buffer<unknown,5>);
	[1] Finalize();
	[2] ListDevices() -> (u32, buffer<unknown,0xa>);
	[3] StartDetection(bytes<8,4>);
	[4] StopDetection(bytes<8,4>);
	[5] Mount(bytes<8,4>, u32, u32);
	[6] Unmount(bytes<8,4>);
	[7] OpenApplicationArea(bytes<8,4>, u32);
	[8] GetApplicationArea(bytes<8,4>) -> (u32, buffer<unknown,6>);
	[9] SetApplicationArea(bytes<8,4>, buffer<unknown,5>);
	[10] Flush(bytes<8,4>);
	[11] Restore(bytes<8,4>);
	[12] CreateApplicationArea(bytes<8,4>, u32, buffer<unknown,5>);
	[13] GetTagInfo(bytes<8,4>) -> buffer<unknown<0x58>,0x1a>;
	[14] GetRegisterInfo(bytes<8,4>) -> buffer<unknown<0x100>,0x1a>;
	[15] GetCommonInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[16] GetModelInfo(bytes<8,4>) -> buffer<unknown<0x40>,0x1a>;
	[17] AttachActivateEvent(bytes<8,4>) -> handle<copy>;
	[18] AttachDeactivateEvent(bytes<8,4>) -> handle<copy>;
	[19] GetState() -> u32;
	[20] GetDeviceState(bytes<8,4>) -> u32;
	[21] GetNpadId(bytes<8,4>) -> u32;
	[22] GetApplicationArea2(bytes<8,4>) -> u32;
	[23] AttachAvailabilityChangeEvent() -> handle<copy>;
	[24] RecreateApplicationArea(bytes<8,4>, u32, buffer<unknown,5>);
}

interface nn::nfp::detail::IUserManager is nfp:user {
	[0] CreateUserInterface() -> object<nn::nfp::detail::IUser>;
}

interface nn::nifm::detail::IGeneralService {
	[1] GetClientId() -> buffer<nn::nifm::ClientId,0x1a>;
	[2] CreateScanRequest() -> object<nn::nifm::detail::IScanRequest>;
	[4] CreateRequest(u32) -> object<nn::nifm::detail::IRequest>;
	[5] GetCurrentNetworkProfile() -> buffer<nn::nifm::detail::sf::NetworkProfileData,0x1a>;
	[6] EnumerateNetworkInterfaces(u32) -> (u32, buffer<nn::nifm::detail::sf::NetworkInterfaceInfo,0xa>);
	[7] EnumerateNetworkProfiles(u8) -> (u32, buffer<nn::nifm::detail::sf::NetworkProfileBasicInfo,6>);
	[8] GetNetworkProfile(nn::util::Uuid) -> buffer<nn::nifm::detail::sf::NetworkProfileData,0x1a>;
	[9] SetNetworkProfile(buffer<nn::nifm::detail::sf::NetworkProfileData,0x19>) -> nn::util::Uuid;
	[10] RemoveNetworkProfile(nn::util::Uuid);
	@version(4.0.0+)
	[11] GetScanDataOld() -> (u32, buffer<nn::nifm::detail::sf::AccessPointDataOld,6>);
	@version(1.0.0-3.0.2)
	[11] GetScanData() -> (u32, buffer<nn::nifm::detail::sf::AccessPointDataOld,6>);
	[12] GetCurrentIpAddress() -> nn::nifm::IpV4Address;
	@version(1.0.0-3.0.2)
	[13] GetCurrentAccessPoint() -> buffer<nn::nifm::detail::sf::AccessPointDataOld,0x1a>;
	@version(4.0.0+)
	[13] GetCurrentAccessPointOld() -> buffer<nn::nifm::detail::sf::AccessPointDataOld,0x1a>;
	[14] CreateTemporaryNetworkProfile(buffer<nn::nifm::detail::sf::NetworkProfileData,0x19>) -> (nn::util::Uuid, object<nn::nifm::detail::INetworkProfile>);
	[15] GetCurrentIpConfigInfo() -> (nn::nifm::IpAddressSetting, nn::nifm::DnsSetting);
	[16] SetWirelessCommunicationEnabled(b8);
	[17] IsWirelessCommunicationEnabled() -> b8;
	[18] GetInternetConnectionStatus() -> nn::nifm::detail::sf::InternetConnectionStatus;
	[19] SetEthernetCommunicationEnabled(b8);
	[20] IsEthernetCommunicationEnabled() -> b8;
	[21] IsAnyInternetRequestAccepted(buffer<nn::nifm::ClientId,0x19>) -> b8;
	[22] IsAnyForegroundRequestAccepted() -> b8;
	[23] PutToSleep();
	[24] WakeUp();
	[25] GetSsidListVersion() -> nn::nifm::SsidListVersion;
	[26] SetExclusiveClient(buffer<nn::nifm::ClientId,0x19>);
	[27] GetDefaultIpSetting() -> buffer<nn::nifm::IpSettingData,0x1a>;
	[28] SetDefaultIpSetting(buffer<nn::nifm::IpSettingData,0x19>);
	[29] SetWirelessCommunicationEnabledForTest(b8);
	[30] SetEthernetCommunicationEnabledForTest(b8);
	@version(2.0.0+)
	[31] GetTelemetorySystemEventReadableHandle() -> handle<copy>;
	@version(2.0.0+)
	[32] GetTelemetryInfo() -> buffer<nn::nifm::TelemetryInfo,0x16>;
	@version(2.0.0+)
	[33] ConfirmSystemAvailability();
	@version(4.0.0+)
	[34] SetBackgroundRequestEnabled(b8);
	@version(4.0.0+)
	[35] GetScanData() -> (u32, buffer<nn::nifm::detail::sf::AccessPointData,6>);
	@version(4.0.0+)
	[36] GetCurrentAccessPoint() -> buffer<nn::nifm::detail::sf::AccessPointData,0x1a>;
	@version(4.0.0+)
	[37] Shutdown();
}

interface nn::nifm::detail::INetworkProfile {
	[0] Update(buffer<nn::nifm::detail::sf::NetworkProfileData,0x19>) -> nn::util::Uuid;
	@version(1.0.0-2.3.0)
	[1] Persist(nn::util::Uuid) -> nn::util::Uuid;
	@version(3.0.0+)
	[1] PersistOld(nn::util::Uuid) -> nn::util::Uuid;
	@version(3.0.0+)
	[2] Persist() -> nn::util::Uuid;
}

interface nn::nifm::detail::IRequest {
	[0] GetRequestState() -> u32;
	[1] GetResult();
	[2] GetSystemEventReadableHandles() -> (handle<copy>, handle<copy>);
	[3] Cancel();
	[4] Submit();
	[5] SetRequirement(nn::nifm::Requirement);
	[6] SetRequirementPreset(u32);
	[8] SetPriority(u8);
	[9] SetNetworkProfileId(nn::util::Uuid);
	[10] SetRejectable(b8);
	[11] SetConnectionConfirmationOption(i8);
	[12] SetPersistent(b8);
	[13] SetInstant(b8);
	[14] SetSustainable(b8, u8);
	[15] SetRawPriority(u8);
	[16] SetGreedy(b8);
	[17] SetSharable(b8);
	[18] SetRequirementByRevision(u32);
	[19] GetRequirement() -> nn::nifm::Requirement;
	[20] GetRevision() -> u32;
	[21] GetAppletInfo(u32) -> (u32, u32, u32, buffer<bytes,6>);
	[22] GetAdditionalInfo() -> (u32, buffer<nn::nifm::AdditionalInfo,0x16>);
	[23] SetKeptInSleep(b8);
	[24] RegisterSocketDescriptor(u32);
	[25] UnregisterSocketDescriptor(u32);
}

interface nn::nifm::detail::IScanRequest {
	[0] Submit();
	[1] IsProcessing() -> b8;
	[2] GetResult();
	[3] GetSystemEventReadableHandle() -> handle<copy>;
}

interface nn::nifm::detail::IStaticService is nifm:u, nifm:a, nifm:s {
	@version(1.0.0-2.3.0)
	[4] CreateGeneralService() -> object<nn::nifm::detail::IGeneralService>;
	@version(3.0.0+)
	[4] CreateGeneralServiceOld() -> object<nn::nifm::detail::IGeneralService>;
	@version(3.0.0+)
	[5] CreateGeneralService(u64, pid) -> object<nn::nifm::detail::IGeneralService>;
}

interface nn::nim::detail::INetworkInstallManager is nim {
	@undocumented
	[0] CreateSystemUpdateTask(unknown<0x18>) -> unknown<0x10>;
	# Takes a 0x10-byte input struct, from the output of ListSystemUpdateTask.
	# 
	@undocumented
	[1] DestroySystemUpdateTask(unknown<0x10>);
	# Takes a type-0x6 output buffer, for an array of 0x10-byte entries.
	# Returns an u32 for total output entries.
	# 
	# Doesn't return anything on a v2.1 system where sysupdate domains are
	# blocked.
	# 
	@undocumented
	[2] ListSystemUpdateTask() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[3] RequestSystemUpdateTaskRun(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[4] GetSystemUpdateTaskInfo(unknown<0x10>) -> unknown<0x38>;
	@undocumented
	[5] CommitSystemUpdateTask(unknown<0x10>);
	@undocumented
	[6] CreateNetworkInstallTask(unknown<0x10>, buffer<unknown,5>) -> unknown<0x10>;
	@undocumented
	[7] DestroyNetworkInstallTask(unknown<0x10>);
	@undocumented
	[8] ListNetworkInstallTask() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[9] RequestNetworkInstallTaskRun(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[10] GetNetworkInstallTaskInfo(unknown<0x10>) -> unknown<0x40>;
	@undocumented
	[11] CommitNetworkInstallTask(unknown<0x10>);
	@undocumented
	[12] RequestLatestSystemUpdateMeta() -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[14] ListApplicationNetworkInstallTask(unknown<8>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[15] ListNetworkInstallTaskContentMeta(unknown<0x14>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[16] RequestLatestVersion(unknown<8>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[17] SetNetworkInstallTaskAttribute(unknown<0x18>);
	@undocumented
	[18] AddNetworkInstallTaskContentMeta(unknown<0x10>, buffer<unknown,5>);
	@undocumented
	[19] GetDownloadedSystemDataPath(unknown<0x18>) -> buffer<unknown,0x16>;
	@undocumented
	[20] CalculateNetworkInstallTaskRequiredSize(unknown<0x10>) -> unknown<8>;
	@undocumented
	[21] IsExFatDriverIncluded(unknown<0x10>) -> unknown<1>;
	@undocumented
	[22] GetBackgroundDownloadStressTaskInfo() -> unknown<0x10>;
	@version(2.0.0+)
	@undocumented
	[23] RequestDeviceAuthenticationToken() -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@version(2.0.0+)
	@undocumented
	[24] RequestGameCardRegistrationStatus(unknown<8>, buffer<unknown,5>, buffer<unknown,5>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@version(2.0.0+)
	@undocumented
	[25] RequestRegisterGameCard(unknown<0x10>, buffer<unknown,5>, buffer<unknown,5>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@version(2.0.0+)
	@undocumented
	[26] RequestRegisterNotificationToken(unknown<0x28>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@version(2.0.0+)
	@undocumented
	[27] RequestDownloadTaskList(unknown<0x28>) -> (handle<copy>, object<nn::nim::detail::IAsyncData>);
	@version(2.0.0+)
	@undocumented
	[28] RequestApplicationControl(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@version(2.0.0+)
	@undocumented
	[29] RequestLatestApplicationControl(unknown<8>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@version(2.0.0+)
	@undocumented
	[30] RequestVersionList(unknown<0x28>) -> (handle<copy>, object<nn::nim::detail::IAsyncData>);
	@version(2.0.0+)
	@undocumented
	[31] CreateApplyDeltaTask(unknown<0x20>, buffer<unknown,5>) -> unknown<0x10>;
	@version(2.0.0+)
	@undocumented
	[32] DestroyApplyDeltaTask(unknown<0x10>);
	@version(2.0.0+)
	@undocumented
	[33] ListApplicationApplyDeltaTask(unknown<8>) -> (unknown<4>, buffer<unknown,6>);
	@version(2.0.0+)
	@undocumented
	[34] RequestApplyDeltaTaskRun(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@version(2.0.0+)
	@undocumented
	[35] GetApplyDeltaTaskInfo(unknown<0x10>) -> unknown<0x30>;
	@version(2.0.0+)
	@undocumented
	[36] ListApplyDeltaTask(unknown<0x14>) -> (unknown<4>, buffer<unknown,6>);
	@version(2.0.0+)
	@undocumented
	[37] CommitApplyDeltaTask(unknown<0x10>);
	@version(2.0.0+)
	@undocumented
	[38] CalculateApplyDeltaTaskRequiredSize(unknown<0x10>) -> unknown<8>;
	@version(2.0.0+)
	@undocumented
	[39] PrepareShutdown();
	@version(2.0.0+)
	@undocumented
	[40] ListApplyDeltaTask2() -> (unknown<4>, buffer<unknown,6>);
	@version(2.0.0+)
	@undocumented
	[41] ClearNotEnoughSpaceStateOfApplyDeltaTask(unknown<0x10>);
	@version(3.0.0+)
	@undocumented
	[42] Unknown42(unknown<0x10>) -> unknown<0x10>;
	@version(3.0.0+)
	@undocumented
	[43] Unknown43() -> unknown<0x10>;
	@version(3.0.0+)
	@undocumented
	[44] Unknown44(unknown<0x10>) -> unknown<1>;
	@version(3.0.0+)
	@undocumented
	[45] Unknown45(unknown<0x28>) -> unknown<8>;
	@version(3.0.0+)
	@undocumented
	[46] Unknown46();
}

interface nn::nim::detail::IShopServiceManager is nim:shp {
	@undocumented
	[0] RequestDeviceAuthenticationToken() -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[1] RequestCachedDeviceAuthenticationToken(unknown<8>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[100] RequestRegisterDeviceAccount() -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[101] RequestUnregisterDeviceAccount() -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[102] RequestDeviceAccountStatus() -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[103] GetDeviceAccountInfo() -> unknown<0x20>;
	@undocumented
	[104] RequestDeviceRegistrationInfo() -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[105] RequestTransferDeviceAccount() -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[106] RequestSyncRegistration() -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[107] IsOwnDeviceId(unknown<8>) -> unknown<1>;
	@undocumented
	[200] RequestRegisterNotificationToken(unknown<0x28>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[300] RequestUnlinkDevice(unknown<8>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[301] RequestUnlinkDeviceIntegrated(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[302] RequestLinkDevice(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[303] HasDeviceLink(unknown<0x10>) -> unknown<1>;
	@undocumented
	[304] RequestUnlinkDeviceAll() -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[305] RequestCreateVirtualAccount(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@undocumented
	[306] RequestDeviceLinkStatus(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
	@undocumented
	[400] GetAccountByVirtualAccount(unknown<4>) -> unknown<0x10>;
	@undocumented
	[500] RequestSyncTicket() -> (handle<copy>, object<nn::nim::detail::IAsyncProgressResult>);
	@undocumented
	[501] RequestDownloadTicket(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncResult>);
	@version(4.0.0+)
	@undocumented
	[502] RequestDownloadTicketForPrepurchasedContents(unknown<0x10>) -> (handle<copy>, object<nn::nim::detail::IAsyncValue>);
}

interface nn::npns::INpnsSystem is npns:s {
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2(unknown<8>);
	@undocumented
	[3] Unknown3(unknown<2>) -> buffer<unknown,6>;
	@undocumented
	[4] Unknown4(unknown<2>) -> buffer<unknown,6>;
	@undocumented
	[5] Unknown5() -> handle<copy>;
	@undocumented
	[6] Unknown6();
	@undocumented
	[7] Unknown7() -> handle<copy>;
	@undocumented
	[11] Unknown11(buffer<unknown,9>);
	@undocumented
	[12] Unknown12(buffer<unknown,9>);
	@undocumented
	[13] Unknown13(buffer<unknown,9>) -> unknown<1>;
	@undocumented
	[21] Unknown21(unknown<0x10>) -> unknown<0x28>;
	@undocumented
	[22] Unknown22(unknown<0x18>) -> unknown<0x28>;
	@undocumented
	[23] Unknown23(unknown<0x10>);
	@undocumented
	[24] Unknown24(unknown<0x18>);
	@undocumented
	[25] Unknown25(unknown<0x28>) -> unknown<1>;
	@undocumented
	[31] Unknown31(unknown<0x10>);
	@undocumented
	[32] Unknown32(unknown<0x10>);
	@undocumented
	[101] Unknown101();
	@undocumented
	[102] Unknown102();
	@undocumented
	[103] Unknown103() -> unknown<4>;
	@undocumented
	[104] Unknown104() -> buffer<unknown,6>;
	@undocumented
	[105] Unknown105() -> handle<copy>;
	@undocumented
	[111] Unknown111() -> buffer<unknown,0xa>;
	@undocumented
	[112] Unknown112();
	@undocumented
	[113] Unknown113();
	@undocumented
	[114] Unknown114(buffer<unknown,9>, buffer<unknown,9>);
	@undocumented
	[115] Unknown115() -> (buffer<unknown,0xa>, buffer<unknown,0xa>);
	@undocumented
	[201] Unknown201(unknown<0x10>);
	@undocumented
	[202] Unknown202(unknown<4>);
}

interface nn::npns::INpnsUser is npns:u {
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2(unknown<8>);
	@undocumented
	[3] Unknown3(unknown<2>) -> buffer<unknown,6>;
	@undocumented
	[4] Unknown4(unknown<2>) -> buffer<unknown,6>;
	@undocumented
	[5] Unknown5() -> handle<copy>;
	@undocumented
	[7] Unknown7() -> handle<copy>;
	@undocumented
	[21] Unknown21(unknown<0x10>) -> unknown<0x28>;
	@undocumented
	[23] Unknown23(unknown<0x10>);
	@undocumented
	[25] Unknown25(unknown<0x28>) -> unknown<1>;
	@undocumented
	[101] Unknown101();
	@undocumented
	[102] Unknown102();
	@undocumented
	[103] Unknown103() -> unknown<4>;
	@undocumented
	[104] Unknown104() -> buffer<unknown,6>;
	@undocumented
	[111] Unknown111() -> buffer<unknown,0xa>;
}

interface nn::ns::detail::IAccountProxyInterface {
	@undocumented
	[0] CreateUserAccount(unknown<0x21>, buffer<unknown,5>);
}

interface nn::ns::detail::IApplicationManagerInterface is ns:am {
	# Takes a type-6 output buffer and an u32 entry\_offset.
	# 
	# Returns an array of title-info entries using the specified offset and
	# size. No input titleID is passed to this.
	# 
	@undocumented
	[0] ListApplicationRecord(unknown<4>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[1] GenerateApplicationRecordCount() -> unknown<8>;
	@undocumented
	[2] GetApplicationRecordUpdateSystemEvent() -> handle<copy>;
	@undocumented
	[3] GetApplicationViewDeprecated(buffer<unknown,5>) -> buffer<unknown,6>;
	@undocumented
	[4] DeleteApplicationEntity(unknown<8>);
	@undocumented
	[5] DeleteApplicationCompletely(unknown<8>);
	@undocumented
	[6] IsAnyApplicationEntityRedundant() -> unknown<1>;
	@undocumented
	[7] DeleteRedundantApplicationEntity();
	@undocumented
	[8] IsApplicationEntityMovable(unknown<0x10>) -> unknown<1>;
	@undocumented
	[9] MoveApplicationEntity(unknown<0x10>);
	@undocumented
	[11] CalculateApplicationOccupiedSize(unknown<8>) -> unknown<0x80>;
	@undocumented
	[16] PushApplicationRecord(unknown<0x10>, buffer<unknown,5>);
	@undocumented
	[17] ListApplicationRecordContentMeta(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	# Takes an input u64 titleID, returns an output u64 PID.
	# 
	# Launches an application title which is registered with NS.
	# 
	@version(1.0.0-5.1.0)
	@undocumented
	[19] LaunchApplication(unknown<8>) -> unknown<8>;
	# Takes a 0x16-type output buffer, an u8
	# [type](http://switchbrew.org/index.php?title=NCA "wikilink"), and an u64
	# titleID.
	# 
	# The input titleID is used with the application-title table like various
	# other cmds, anything not in that table can't be used with this.
	# 
	# Returns a string path for the specified type of patch content with this
	# titleID, otherwise returns regular-application paths when update-title
	# not installed. Returns an error when the specified type of content
	# doesn't exist for this title. Starts with
	# "@{SdCardContent,UserContent}://" and ends in ".nca".
	# 
	# For gamecard content, the output path is: "@GcSXXXXXXXX:/<NcaId>.nca".
	# NCA-type0 with gamecard returns 0 with an empty output string.
	# 
	# The output string is then used by the user-process with
	# [FS](http://switchbrew.org/index.php?title=Filesystem_services "wikilink")
	# to mount the content.
	# 
	@undocumented
	[21] GetApplicationContentPath(unknown<0x10>) -> buffer<unknown,0x16>;
	@undocumented
	[22] TerminateApplication(unknown<8>);
	@undocumented
	[23] ResolveApplicationContentPath(unknown<0x10>);
	@undocumented
	[26] BeginInstallApplication(unknown<0x10>);
	@undocumented
	[27] DeleteApplicationRecord(unknown<8>);
	@undocumented
	[30] RequestApplicationUpdateInfo(unknown<8>) -> (handle<copy>, object<nn::ns::detail::IAsyncValue>);
	@undocumented
	[32] CancelApplicationDownload(unknown<8>);
	@undocumented
	[33] ResumeApplicationDownload(unknown<8>);
	@undocumented
	[35] UpdateVersionList(buffer<unknown,5>);
	@undocumented
	[36] PushLaunchVersion(unknown<0x10>);
	@undocumented
	[37] ListRequiredVersion() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[38] CheckApplicationLaunchVersion(unknown<8>);
	@undocumented
	[39] CheckApplicationLaunchRights(unknown<8>);
	@undocumented
	[40] GetApplicationLogoData(unknown<8>, buffer<unknown,0x15>) -> (unknown<8>, buffer<unknown,6>);
	@undocumented
	[41] CalculateApplicationDownloadRequiredSize(unknown<8>) -> unknown<0x10>;
	@undocumented
	[42] CleanupSdCard();
	@undocumented
	[43] CheckSdCardMountStatus();
	@undocumented
	[44] GetSdCardMountStatusChangedEvent() -> handle<copy>;
	@undocumented
	[45] GetGameCardAttachmentEvent() -> handle<copy>;
	@undocumented
	[46] GetGameCardAttachmentInfo() -> unknown<0x10>;
	# Takes an input media-id that must be 5.
	# 
	# Returns the u64 from
	# [Content\_Manager\_services\#IContentStorage](http://switchbrew.org/index.php?title=Content_Manager_services#IContentStorage "wikilink")
	# cmd22.
	# 
	@undocumented
	[47] GetTotalSpaceSize(unknown<1>) -> unknown<8>;
	# Takes an input media-id that must be 5.
	# 
	# Returns the u64 from
	# [Content\_Manager\_services\#IContentStorage](http://switchbrew.org/index.php?title=Content_Manager_services#IContentStorage "wikilink")
	# cmd23.
	# 
	@undocumented
	[48] GetFreeSpaceSize(unknown<1>) -> unknown<8>;
	@undocumented
	[49] GetSdCardRemovedEvent() -> handle<copy>;
	@undocumented
	[52] GetGameCardUpdateDetectionEvent() -> handle<copy>;
	@undocumented
	[53] DisableApplicationAutoDelete(unknown<8>);
	@undocumented
	[54] EnableApplicationAutoDelete(unknown<8>);
	@undocumented
	[55] GetApplicationDesiredLanguage(unknown<4>) -> unknown<1>;
	@undocumented
	[56] SetApplicationTerminateResult(unknown<0x10>);
	@undocumented
	[57] ClearApplicationTerminateResult(unknown<8>);
	@undocumented
	[58] GetLastSdCardMountUnexpectedResult();
	@undocumented
	[59] ConvertApplicationLanguageToLanguageCode(unknown<1>) -> unknown<8>;
	# Takes an input u8 pointer for the resulting Id to be written to and a
	# string represented as a u64 (i.e 0x53552D6E65 for 'en-US').
	# 
	# Returns 0 if an ID was successfully found, otherwise returns 0x25810.
	# 
	@undocumented
	[60] ConvertLanguageCodeToApplicationLanguage(unknown<8>) -> unknown<1>;
	@undocumented
	[61] GetBackgroundDownloadStressTaskInfo() -> unknown<0x10>;
	@undocumented
	[62] GetGameCardStopper() -> object<nn::ns::detail::IGameCardStopper>;
	@undocumented
	[63] IsSystemProgramInstalled(unknown<8>) -> unknown<1>;
	@undocumented
	[64] StartApplyDeltaTask(unknown<8>);
	@undocumented
	[65] GetRequestServerStopper() -> object<nn::ns::detail::IRequestServerStopper>;
	@undocumented
	[66] GetBackgroundApplyDeltaStressTaskInfo() -> unknown<0x10>;
	@undocumented
	[67] CancelApplicationApplyDelta(unknown<8>);
	@undocumented
	[68] ResumeApplicationApplyDelta(unknown<8>);
	@undocumented
	[69] CalculateApplicationApplyDeltaRequiredSize(unknown<8>) -> unknown<0x10>;
	@undocumented
	[70] ResumeAll();
	@undocumented
	[71] GetStorageSize(unknown<1>) -> unknown<0x10>;
	@undocumented
	[80] RequestDownloadApplication(unknown<0x10>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[81] RequestDownloadAddOnContent(unknown<0x10>, buffer<unknown,5>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[82] DownloadApplication(unknown<0x10>);
	@undocumented
	[83] CheckApplicationResumeRights(unknown<8>);
	@undocumented
	[84] GetDynamicCommitEvent() -> handle<copy>;
	@undocumented
	[85] RequestUpdateApplication2(unknown<8>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[86] EnableApplicationCrashReport(unknown<1>);
	@undocumented
	[87] IsApplicationCrashReportEnabled() -> unknown<1>;
	@undocumented
	[90] BoostSystemMemoryResourceLimit(unknown<8>);
	@version(5.0.0+)
	@undocumented
	[91] Unknown91(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[92] Unknown92(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[93] Unknown93(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[94] LaunchApplication2(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[95] Unknown95(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[96] Unknown96(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[97] Unknown97(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[98] Unknown98(unknown) -> unknown;
	@undocumented
	[100] ResetToFactorySettings();
	@undocumented
	[101] ResetToFactorySettingsWithoutUserSaveData();
	@undocumented
	[102] ResetToFactorySettingsForRefurbishment();
	@undocumented
	[200] CalculateUserSaveDataStatistics(unknown<0x10>) -> unknown<0x10>;
	@undocumented
	[201] DeleteUserSaveDataAll(unknown<0x10>) -> object<nn::ns::detail::IProgressMonitorForDeleteUserSaveDataAll>;
	@undocumented
	[210] DeleteUserSystemSaveData(unknown<0x18>);
	@version(6.0.0+)
	@undocumented
	[211] Unknown211(unknown) -> unknown;
	@undocumented
	[220] UnregisterNetworkServiceAccount(unknown<0x10>);
	@version(6.0.0+)
	@undocumented
	[221] Unknown221(unknown) -> unknown;
	@undocumented
	[300] GetApplicationShellEvent() -> handle<copy>;
	@undocumented
	[301] PopApplicationShellEventInfo() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[302] LaunchLibraryApplet(unknown<8>) -> unknown<8>;
	@undocumented
	[303] TerminateLibraryApplet(unknown<8>);
	@undocumented
	[304] LaunchSystemApplet() -> unknown<8>;
	@undocumented
	[305] TerminateSystemApplet(unknown<8>);
	@undocumented
	[306] LaunchOverlayApplet() -> unknown<8>;
	@undocumented
	[307] TerminateOverlayApplet(unknown<8>);
	@undocumented
	[400] GetApplicationControlData(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[401] InvalidateAllApplicationControlCache();
	@undocumented
	[402] RequestDownloadApplicationControlData(unknown<8>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[403] GetMaxApplicationControlCacheCount() -> unknown<4>;
	@undocumented
	[404] InvalidateApplicationControlCache(unknown<8>);
	@undocumented
	[405] ListApplicationControlCacheEntryInfo() -> (unknown<4>, buffer<unknown,6>);
	@version(6.0.0+)
	@undocumented
	[406] Unknown406(unknown) -> unknown;
	@undocumented
	[502] RequestCheckGameCardRegistration(unknown<8>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[503] RequestGameCardRegistrationGoldPoint(unknown<0x18>) -> (handle<copy>, object<nn::ns::detail::IAsyncValue>);
	@undocumented
	[504] RequestRegisterGameCard(unknown<0x20>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[505] GetGameCardMountFailureEvent() -> handle<copy>;
	@undocumented
	[506] IsGameCardInserted() -> unknown<1>;
	@undocumented
	[507] EnsureGameCardAccess();
	@undocumented
	[508] GetLastGameCardMountFailureResult();
	@undocumented
	[509] ListApplicationIdOnGameCard(unknown) -> unknown;
	@undocumented
	[600] CountApplicationContentMeta(unknown<8>) -> unknown<4>;
	# Returns 0x10-byte entries using the specified titleID starting at the
	# specified u32 entryindex. Can only return game titles. The second entry
	# if any is the update-title usually. When the input entryindex is \>=
	# totalentries, this will return 0 with out\_entrycount=0.
	# 
	# Entry
	# structure:
	# 
	# | Offset | Size | Description                                                                                                                           |
	# | ------ | ---- | ------------------------------------------------------------------------------------------------------------------------------------- |
	# | 0x0    | 0x1  | u8 "type". [Title type](http://switchbrew.org/index.php?title=Content_Manager_services "wikilink") (String is from web-applet)        |
	# | 0x1    | 0x1  | u8 "installedStorage" / [StorageId](http://switchbrew.org/index.php?title=Filesystem_services "wikilink") (String is from web-applet) |
	# | 0x2    | 0x1  | Unknown. Non-zero with output from cmd 605, differs for app/update titles.                                                            |
	# | 0x3    | 0x1  | Padding                                                                                                                               |
	# | 0x4    | 0x4  | u32 Title-version                                                                                                                     |
	# | 0x8    | 0x8  | u64 titleID                                                                                                                           |
	# 
	@undocumented
	[601] ListApplicationContentMetaStatus(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@version(2.0.0-5.1.0)
	@undocumented
	[602] ListAvailableAddOnContent(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[603] GetOwnedApplicationContentMetaStatus(unknown<0x10>) -> unknown<0x10>;
	@undocumented
	[604] RegisterContentsExternalKey(unknown<0x10>);
	@undocumented
	[605] ListApplicationContentMetaStatusWithRightsCheck(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[606] GetContentMetaStorage(unknown<0x10>) -> unknown<1>;
	@version(6.0.0+)
	@undocumented
	[607] Unknown607(unknown) -> unknown;
	@undocumented
	[700] PushDownloadTaskList(buffer<unknown,5>);
	@undocumented
	[701] ClearTaskStatusList();
	@undocumented
	[702] RequestDownloadTaskList();
	@undocumented
	[703] RequestEnsureDownloadTask() -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[704] ListDownloadTaskStatus() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[705] RequestDownloadTaskListData() -> (handle<copy>, object<nn::ns::detail::IAsyncValue>);
	@undocumented
	[800] RequestVersionList();
	@undocumented
	[801] ListVersionList() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[802] RequestVersionListData() -> (handle<copy>, object<nn::ns::detail::IAsyncValue>);
	@undocumented
	[900] GetApplicationRecord(unknown<8>) -> unknown<0x18>;
	@undocumented
	[901] GetApplicationRecordProperty(unknown<8>) -> buffer<unknown,0x16>;
	@undocumented
	[902] EnableApplicationAutoUpdate(unknown<8>);
	@undocumented
	[903] DisableApplicationAutoUpdate(unknown<8>);
	@undocumented
	[904] TouchApplication(unknown<8>);
	@undocumented
	[905] RequestApplicationUpdate(unknown<0x10>);
	@undocumented
	[906] IsApplicationUpdateRequested(unknown<8>) -> unknown<8>;
	@undocumented
	[907] WithdrawApplicationUpdateRequest(unknown<8>);
	@undocumented
	[908] ListApplicationRecordInstalledContentMeta(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[909] WithdrawCleanupAddOnContentsWithNoRightsRecommendation(unknown<8>);
	@version(6.0.0+)
	@undocumented
	[910] Unknown910(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[911] Unknown911(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[912] Unknown912(unknown) -> unknown;
	@undocumented
	[1000] RequestVerifyApplicationDeprecated(unknown<0x10>, handle<copy>) -> (handle<copy>, object<nn::ns::detail::IProgressAsyncResult>);
	@undocumented
	[1001] CorruptApplicationForDebug(unknown<0x10>);
	@undocumented
	[1002] RequestVerifyAddOnContentsRights(unknown<8>) -> (handle<copy>, object<nn::ns::detail::IProgressAsyncResult>);
	@undocumented
	[1003] RequestVerifyApplication(unknown) -> unknown;
	@undocumented
	[1004] CorruptContentForDebug(unknown) -> unknown;
	@undocumented
	[1200] NeedsUpdateVulnerability() -> unknown<1>;
	@undocumented
	[1300] IsAnyApplicationEntityInstalled(unknown<8>) -> unknown<1>;
	@undocumented
	[1301] DeleteApplicationContentEntities(unknown<0x10>);
	@undocumented
	[1302] CleanupUnrecordedApplicationEntity(unknown<8>);
	@undocumented
	[1303] CleanupAddOnContentsWithNoRights(unknown<8>);
	@undocumented
	[1304] DeleteApplicationContentEntity(unknown<0x10>);
	@version(6.0.0+)
	@undocumented
	[1308] Unknown1308(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[1309] Unknown1309(unknown) -> unknown;
	@undocumented
	[1400] PrepareShutdown();
	@undocumented
	[1500] FormatSdCard();
	@undocumented
	[1501] NeedsSystemUpdateToFormatSdCard() -> unknown<1>;
	@undocumented
	[1502] GetLastSdCardFormatUnexpectedResult();
	@undocumented
	[1504] InsertSdCard();
	@undocumented
	[1505] RemoveSdCard();
	@undocumented
	[1600] GetSystemSeedForPseudoDeviceId() -> unknown<0x20>;
	@undocumented
	[1601] ResetSystemSeedForPseudoDeviceId();
	@undocumented
	[1700] ListApplicationDownloadingContentMeta(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[1701] GetApplicationView(buffer<unknown,5>) -> buffer<unknown,6>;
	@undocumented
	[1702] GetApplicationDownloadTaskStatus(unknown<8>) -> unknown<1>;
	@undocumented
	[1703] GetApplicationViewDownloadErrorContext(unknown<8>) -> buffer<unknown,0x16>;
	@undocumented
	[1800] IsNotificationSetupCompleted() -> unknown<1>;
	@undocumented
	[1801] GetLastNotificationInfoCount() -> unknown<8>;
	@undocumented
	[1802] ListLastNotificationInfo() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[1803] ListNotificationTask() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[1900] IsActiveAccount(unknown<4>) -> unknown<1>;
	@undocumented
	[1901] RequestDownloadApplicationPrepurchasedRights(unknown<8>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[1902] GetApplicationTicketInfo(unknown) -> unknown;
	@undocumented
	[2000] GetSystemDeliveryInfo() -> buffer<unknown,0x16>;
	@undocumented
	[2001] SelectLatestSystemDeliveryInfo(buffer<unknown,0x15>, buffer<unknown,5>, buffer<unknown,5>) -> unknown<4>;
	@undocumented
	[2002] VerifyDeliveryProtocolVersion(buffer<unknown,0x15>);
	@undocumented
	[2003] GetApplicationDeliveryInfo(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[2004] HasAllContentsToDeliver(buffer<unknown,5>) -> unknown<1>;
	@undocumented
	[2005] CompareApplicationDeliveryInfo(buffer<unknown,5>, buffer<unknown,5>) -> unknown<4>;
	@undocumented
	[2006] CanDeliverApplication(buffer<unknown,5>, buffer<unknown,5>) -> unknown<1>;
	@undocumented
	[2007] ListContentMetaKeyToDeliverApplication(unknown<4>, buffer<unknown,5>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[2008] NeedsSystemUpdateToDeliverApplication(buffer<unknown,0x15>, buffer<unknown,5>) -> unknown<1>;
	@undocumented
	[2009] EstimateRequiredSize(buffer<unknown,5>) -> unknown<8>;
	@undocumented
	[2010] RequestReceiveApplication(unknown<0x10>, buffer<unknown,5>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[2011] CommitReceiveApplication(unknown<8>);
	@undocumented
	[2012] GetReceiveApplicationProgress(unknown<8>) -> unknown<0x10>;
	@undocumented
	[2013] RequestSendApplication(unknown<0x10>, buffer<unknown,5>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[2014] GetSendApplicationProgress(unknown<8>) -> unknown<0x10>;
	@undocumented
	[2015] CompareSystemDeliveryInfo(buffer<unknown,0x15>, buffer<unknown,0x15>) -> unknown<4>;
	@undocumented
	[2016] ListNotCommittedContentMeta(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[2017] CreateDownloadTask(unknown<8>, buffer<unknown,5>);
	@version(6.0.0+)
	@undocumented
	[2018] Unknown2018(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2050] Unknown2050(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2100] Unknown2100(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2101] Unknown2101(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2150] Unknown2150(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2151] Unknown2151(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2152] Unknown2152(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2153] Unknown2153(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2154] Unknown2154(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2160] Unknown2160(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2161] Unknown2161(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2170] Unknown2170(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2171] Unknown2171(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2180] Unknown2180(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2181] Unknown2181(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2182] Unknown2182(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2190] Unknown2190(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2199] Unknown2199(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2200] Unknown2200(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2201] Unknown2201(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2250] Unknown2250(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[2300] Unknown2300(unknown) -> unknown;
}

interface nn::ns::detail::IContentManagementInterface {
	@undocumented
	[11] CalculateApplicationOccupiedSize(unknown<8>) -> unknown<0x80>;
	@undocumented
	[43] CheckSdCardMountStatus();
	@undocumented
	[47] GetTotalSpaceSize(unknown<1>) -> unknown<8>;
	@undocumented
	[48] GetFreeSpaceSize(unknown<1>) -> unknown<8>;
	@undocumented
	[600] CountApplicationContentMeta(unknown<8>) -> unknown<4>;
	@undocumented
	[601] ListApplicationContentMetaStatus(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[605] ListApplicationContentMetaStatusWithRightsCheck(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[607] IsAnyApplicationRunning() -> unknown<1>;
}

interface nn::ns::detail::IDevelopInterface is ns:dev {
	# Wrapper for "pm:shell"
	# [LaunchProcess](http://switchbrew.org/index.php?title=Process_Manager_services#LaunchProcess "wikilink").
	# 
	@undocumented
	[0] LaunchProgram(unknown<0x18>) -> unknown<8>;
	# Wrapper for "pm:shell"
	# [TerminateTitleByPid](http://switchbrew.org/index.php?title=Process_Manager_services#TerminateTitleByPid "wikilink").
	# 
	@undocumented
	[1] TerminateProcess(unknown<8>);
	# Wrapper for "pm:shell"
	# [TerminateTitleByTitleId](http://switchbrew.org/index.php?title=Process_Manager_services#TerminateTitleByTitleId "wikilink").
	# 
	@undocumented
	[2] TerminateProgram(unknown<8>);
	# Wrapper for "pm:shell"
	# [GetProcessEventWaiter](http://switchbrew.org/index.php?title=Process_Manager_services#GetProcessEventWaiter "wikilink").
	# 
	@undocumented
	[4] GetShellEventHandle() -> handle<copy>;
	# Wrapper for "pm:shell"
	# [GetProcessEventType](http://switchbrew.org/index.php?title=Process_Manager_services#GetProcessEventType "wikilink").
	# 
	@undocumented
	[5] GetShellEventInfo() -> unknown<0x10>;
	# Calls "pm:shell"
	# [GetCrashingProcessPid](http://switchbrew.org/index.php?title=Process_Manager_services#GetCrashingProcessPid "wikilink")
	# and sends PID to
	# [TerminateTitleByPid](http://switchbrew.org/index.php?title=Process_Manager_services#TerminateTitleByPid "wikilink").
	# 
	@undocumented
	[6] TerminateApplication();
	# Takes a type-0x5 input buffer containing the
	# [ContentPath](http://switchbrew.org/index.php?title=Filesystem_services "wikilink"),
	# returns an output 0x10-byte struct.
	# 
	# Calls
	# [IPathResolverForStorage](http://switchbrew.org/index.php?title=NCM_services#IPathResolverForStorage "wikilink")
	# Set...NcaPath functions.
	# 
	@undocumented
	[7] PrepareLaunchProgramFromHost(buffer<unknown,5>) -> unknown<0x10>;
	# Takes an input u64 titleID, returns an output u64 PID.
	# 
	# Launches an application title which is registered with NS.
	# 
	@undocumented
	[8] LaunchApplication(unknown<0x10>) -> unknown<8>;
	# Takes 2 input u8s, an u32
	# [launch\_flags](http://switchbrew.org/index.php?title=Process_Manager_services "wikilink"),
	# and an u64 titleID. Returns an output u64 PID.
	# 
	# Launches an application title which is registered with
	# NS.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@undocumented
	[9] LaunchApplicationWithStorageId(unknown<0x10>) -> unknown<8>;
}

interface nn::ns::detail::IDocumentInterface {
	@undocumented
	[21] GetApplicationContentPath(unknown<0x10>) -> buffer<unknown,0x16>;
	@undocumented
	[23] ResolveApplicationContentPath(unknown<0x10>);
}

interface nn::ns::detail::IDownloadTaskInterface {
	@undocumented
	[701] ClearTaskStatusList();
	@undocumented
	[702] RequestDownloadTaskList();
	@undocumented
	[703] RequestEnsureDownloadTask() -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[704] ListDownloadTaskStatus() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[705] RequestDownloadTaskListData() -> (handle<copy>, object<nn::ns::detail::IAsyncValue>);
	@undocumented
	[706] TryCommitCurrentApplicationDownloadTask();
	@undocumented
	[707] EnableAutoCommit();
	@undocumented
	[708] DisableAutoCommit();
	@undocumented
	[709] TriggerDynamicCommitEvent();
}

interface nn::ns::detail::IFactoryResetInterface {
	@undocumented
	[100] ResetToFactorySettings();
	@undocumented
	[101] ResetToFactorySettingsWithoutUserSaveData();
	@undocumented
	[102] ResetToFactorySettingsForRefurbishment();
}

interface nn::ns::detail::IServiceGetterInterface is ns:am2, ns:ec, ns:rid, ns:rt, ns:web {
	@undocumented
	[7992] GetECommerceInterface() -> object<nn::ns::detail::IECommerceInterface>;
	@undocumented
	[7993] GetApplicationVersionInterface() -> object<nn::ns::detail::IApplicationVersionInterface>;
	@undocumented
	[7994] GetFactoryResetInterface() -> object<nn::ns::detail::IFactoryResetInterface>;
	@undocumented
	[7995] GetAccountProxyInterface() -> object<nn::ns::detail::IAccountProxyInterface>;
	@undocumented
	[7996] GetApplicationManagerInterface() -> object<nn::ns::detail::IApplicationManagerInterface>;
	@undocumented
	[7997] GetDownloadTaskInterface() -> object<nn::ns::detail::IDownloadTaskInterface>;
	@undocumented
	[7998] GetContentManagementInterface() -> object<nn::ns::detail::IContentManagementInterface>;
	@undocumented
	[7999] GetDocumentInterface() -> object<nn::ns::detail::IDocumentInterface>;
}

interface nn::ns::detail::ISystemUpdateInterface is ns:su {
	@undocumented
	[0] GetBackgroundNetworkUpdateState() -> unknown<1>;
	@undocumented
	[1] OpenSystemUpdateControl() -> object<nn::ns::detail::ISystemUpdateControl>;
	@undocumented
	[2] NotifyExFatDriverRequired();
	@undocumented
	[3] ClearExFatDriverStatusForDebug();
	@undocumented
	[4] RequestBackgroundNetworkUpdate();
	@undocumented
	[5] NotifyBackgroundNetworkUpdate(unknown<0x10>);
	@undocumented
	[6] NotifyExFatDriverDownloadedForDebug();
	@undocumented
	[9] GetSystemUpdateNotificationEventForContentDelivery() -> handle<copy>;
	@undocumented
	[10] NotifySystemUpdateForContentDelivery();
	@undocumented
	[11] PrepareShutdown();
	@undocumented
	[16] DestroySystemUpdateTask();
	@undocumented
	[17] RequestSendSystemUpdate(unknown<8>, buffer<unknown,0x15>) -> (handle<copy>, object<nn::ns::detail::IAsyncResult>);
	@undocumented
	[18] GetSendSystemUpdateProgress() -> unknown<0x10>;
}

interface nn::ns::detail::IVulnerabilityManagerInterface is ns:vm {
	@version(3.0.0+)
	@undocumented
	[1200] NeedsUpdateVulnerability() -> unknown<1>;
	@version(4.0.0+)
	@undocumented
	[1201] UpdateSafeSystemVersionForDebug(unknown<0x10>);
	@version(4.0.0+)
	@undocumented
	[1202] GetSafeSystemVersion() -> unknown<0x10>;
}

interface nn::nsd::detail::IManager is nsd:u, nsd:a {
	[10] GetSettingName() -> buffer<unknown<0x100>,0x16>;
	# Takes a type-0x16 buffer with size 8. Returns a string.
	# 
	# The output string is used by
	# [NIM](http://switchbrew.org/index.php?title=NIM_services "wikilink") for
	# the "eid:%s" in the User-Agent strings.
	# 
	# This is the "lp1" string also used in domains.
	# 
	[11] GetEnvironmentIdentifier() -> buffer<unknown<8>,0x16>;
	[12] GetDeviceId() -> bytes<0x10,1>;
	[13] DeleteSettings(u32);
	[14] ImportSettings(u32, buffer<unknown,5>) -> buffer<unknown,6>;
	[20] Resolve(buffer<unknown<0x100>,0x15>) -> buffer<unknown<0x100>,0x16>;
	[21] ResolveEx(buffer<unknown<0x100>,0x15>) -> (u32, buffer<unknown<0x100>,0x16>);
	[30] GetNasServiceSetting(buffer<unknown<0x10>,0x15>) -> buffer<unknown<0x108>,0x16>;
	[31] GetNasServiceSettingEx(buffer<unknown<0x10>,0x15>) -> (u32, buffer<unknown<0x108>,0x16>);
	[40] GetNasRequestFqdn() -> buffer<unknown<0x100>,0x16>;
	[41] GetNasRequestFqdnEx() -> (u32, buffer<unknown<0x100>,0x16>);
	[42] GetNasApiFqdn() -> buffer<unknown<0x100>,0x16>;
	[43] GetNasApiFqdnEx() -> (u32, buffer<unknown<0x100>,0x16>);
	[50] GetCurrentSetting() -> buffer<unknown<0x12bf0>,0x16>;
	# Requires the `nsd!test_mode` setting to be equal to 1.
	# 
	# Mounts the system save data for bsdsockets as `nsdsave` and reads from
	# `nsd:/file` to the specified buffer, at the specified size and offset
	# with no checks whatsoever. `nsdsave` is then unmounted.
	# 
	[60] ReadSaveDataFromFsForTest() -> buffer<unknown<0x12bf0>,0x16>;
	# Requires the `nsd!test_mode` setting to be equal to 1.
	# 
	# Mounts the system save data for bsdsockets as `nsdsave` and writes to
	# `nsd:/file` (appending is allowed) using the specified buffer, at the
	# specified size and offset, with no checks whatsoever. `nsdsave` is then
	# commited and unmounted.
	# 
	[61] WriteSaveDataToFsForTest(buffer<unknown<0x12bf0>,0x15>);
	# Requires the `nsd!test_mode` setting to be equal to 1.
	# 
	# Deletes the system save data for
	# bsdsockets.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[62] DeleteSaveDataOfFsForTest();
}

interface nn::ntc::detail::service::IEnsureNetworkClockAvailabilityService {
	[0] StartTask();
	[1] GetFinishNotificationEvent() -> handle<copy>;
	[2] GetResult();
	[3] Cancel();
	[4] IsProcessing() -> u8;
	[5] GetServerTime() -> u64;
}

interface nn::ntc::detail::service::IStaticService is ntc {
	[0] OpenEnsureNetworkClockAvailabilityService(u32, u32) -> object<nn::ntc::detail::service::IEnsureNetworkClockAvailabilityService>;
	[100] SuspendAutonomicTimeCorrection();
	[101] ResumeAutonomicTimeCorrection();
}

interface nn::omm::detail::IOperationModeManager is omm {
	@undocumented
	[0] GetOperationMode() -> unknown<1>;
	@undocumented
	[1] GetOperationModeChangeEvent() -> handle<copy>;
	@undocumented
	[2] EnableAudioVisual();
	@undocumented
	[3] DisableAudioVisual();
	@undocumented
	[4] EnterSleepAndWait(handle<copy>);
	@undocumented
	[5] GetCradleStatus() -> unknown<1>;
	@undocumented
	[6] FadeInDisplay();
	@undocumented
	[7] FadeOutDisplay();
	@version(2.0.0+)
	@undocumented
	[8] Unknown8() -> unknown<0x10>;
	@version(2.0.0+)
	@undocumented
	[9] Unknown9();
	@version(3.0.0+)
	@undocumented
	[10] Unknown10(unknown<1>);
	@version(3.0.0+)
	@undocumented
	[11] Unknown11() -> unknown<8>;
	@version(3.0.0+)
	@undocumented
	[12] Unknown12() -> handle<copy>;
	@version(3.0.0+)
	@undocumented
	[13] Unknown13();
	@version(3.0.0+)
	@undocumented
	[14] Unknown14() -> unknown<1>;
	@version(4.0.0+)
	@undocumented
	[15] Unknown15();
	@version(4.0.0+)
	@undocumented
	[16] Unknown16();
	@version(4.0.0+)
	@undocumented
	[17] Unknown17();
	@version(4.0.0+)
	@undocumented
	[18] Unknown18();
	@version(4.0.0+)
	@undocumented
	[19] Unknown19() -> handle<copy>;
	@version(4.0.0+)
	@undocumented
	[20] Unknown20() -> unknown<1>;
	@version(4.0.0+)
	@undocumented
	[21] Unknown21(unknown<1>);
	@version(4.0.0+)
	@undocumented
	[22] Unknown22() -> handle<copy>;
	@version(4.0.0+)
	@undocumented
	[23] Unknown23() -> unknown<1>;
}

interface nn::pcie::detail::IManager is pcie {
	# Takes the current process handle (0xFFFF8001).
	# 
	# Returns an event handle and session handle to a
	# [\#ISession](#nn::pcie::detail::ISession "wikilink").
	# 
	@undocumented
	[0] RegisterClassDriver(unknown<0x18>, handle<copy>) -> (handle<copy>, object<nn::pcie::detail::ISession>);
	# Takes a type-6 buffer.
	# 
	# Returns a list of connected PCIe endpoint devices.
	# 
	@undocumented
	[1] QueryFunctionsUnregistered() -> (unknown<4>, buffer<unknown,6>);
}

interface nn::pcie::detail::ISession {
	@undocumented
	[0] QueryFunctions() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[1] AcquireFunction(unknown<4>) -> handle<copy>;
	@undocumented
	[2] ReleaseFunction(unknown<4>);
	@undocumented
	[3] GetFunctionState(unknown<4>) -> buffer<unknown,6>;
	@undocumented
	[4] GetBarProfile(unknown<8>) -> unknown<0x18>;
	@undocumented
	[5] ReadConfig(unknown<0xc>) -> unknown<4>;
	@undocumented
	[6] WriteConfig(unknown<0x10>);
	@undocumented
	[7] ReadBarRegion(unknown<0x10>) -> buffer<unknown,6>;
	@undocumented
	[8] WriteBarRegion(unknown<0x10>, buffer<unknown,5>);
	@undocumented
	[9] FindCapability(unknown<8>) -> unknown<4>;
	@undocumented
	[10] FindExtendedCapability(unknown<8>) -> unknown<4>;
	@undocumented
	[11] MapDma(unknown<0x18>) -> unknown<8>;
	@undocumented
	[12] UnmapDma(unknown<0x10>);
	@undocumented
	[13] UnmapDmaBusAddress(unknown<0x10>);
	@undocumented
	[14] GetDmaBusAddress(unknown<0x10>) -> unknown<8>;
	@undocumented
	[15] GetDmaBusAddressRange(unknown<4>) -> unknown<0x10>;
	@undocumented
	[16] SetDmaEnable(unknown<8>);
	@undocumented
	[17] AcquireIrq(unknown<8>) -> handle<copy>;
	@undocumented
	[18] ReleaseIrq(unknown<4>);
	@undocumented
	[19] SetIrqEnable(unknown<0xc>);
	@undocumented
	[20] SetAspmEnable(unknown<8>);
}

interface nn::pctl::detail::ipc::IParentalControlService {
	@version(4.0.0+)
	[1] Initialize();
	[1001] CheckFreeCommunicationPermission();
	[1002] ConfirmLaunchApplicationPermission(b8, nn::ncm::ApplicationId, buffer<i8,9>);
	[1003] ConfirmResumeApplicationPermission(b8, nn::ncm::ApplicationId, buffer<i8,9>);
	[1004] ConfirmSnsPostPermission();
	[1005] ConfirmSystemSettingsPermission();
	[1006] IsRestrictionTemporaryUnlocked() -> b8;
	[1007] RevertRestrictionTemporaryUnlocked();
	[1008] EnterRestrictedSystemSettings();
	[1009] LeaveRestrictedSystemSettings();
	[1010] IsRestrictedSystemSettingsEntered() -> b8;
	[1011] RevertRestrictedSystemSettingsEntered();
	[1012] GetRestrictedFeatures() -> u32;
	@version(4.0.0+)
	[1013] ConfirmStereoVisionPermission();
	@version(5.0.0+)
	@undocumented
	[1014] ConfirmPlayableApplicationVideoOld(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1015] ConfirmPlayableApplicationVideo(unknown) -> unknown;
	[1031] IsRestrictionEnabled() -> b8;
	[1032] GetSafetyLevel() -> u32;
	[1033] SetSafetyLevel(u32);
	[1034] GetSafetyLevelSettings(u32) -> nn::pctl::RestrictionSettings;
	[1035] GetCurrentSettings() -> nn::pctl::RestrictionSettings;
	[1036] SetCustomSafetyLevelSettings(nn::pctl::RestrictionSettings);
	[1037] GetDefaultRatingOrganization() -> u32;
	[1038] SetDefaultRatingOrganization(u32);
	[1039] GetFreeCommunicationApplicationListCount() -> u32;
	[1042] AddToFreeCommunicationApplicationList(nn::ncm::ApplicationId);
	[1043] DeleteSettings();
	[1044] GetFreeCommunicationApplicationList(u32) -> (u32, buffer<nn::pctl::FreeCommunicationApplicationInfo,6>);
	[1045] UpdateFreeCommunicationApplicationList(buffer<nn::pctl::FreeCommunicationApplicationInfo,5>);
	[1046] DisableFeaturesForReset();
	[1047] NotifyApplicationDownloadStarted(nn::ncm::ApplicationId);
	@version(4.0.0+)
	[1061] ConfirmStereoVisionRestrictionConfigurable();
	@version(4.0.0+)
	[1062] GetStereoVisionRestriction() -> b8;
	@version(4.0.0+)
	[1063] SetStereoVisionRestriction(b8);
	@version(5.0.0+)
	@undocumented
	[1064] ResetConfirmedStereoVisionPermission(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1065] IsStereoVisionPermitted(unknown) -> unknown;
	[1201] UnlockRestrictionTemporarily(buffer<u8,9>);
	[1202] UnlockSystemSettingsRestriction(buffer<u8,9>);
	[1203] SetPinCode(buffer<u8,9>);
	# This cmd takes no input, and produces 0x20 bytes of raw output
	# containing snprintf("%02d%08llu", 10, \[inquiry\_rnd\]) on \<=
	# [3.0.0](http://switchbrew.org/index.php?title=3.0.0 "wikilink"). This
	# changed on
	# [3.0.1](http://switchbrew.org/index.php?title=3.0.1 "wikilink") to
	# produce "11(...)" instead of "10(...)".
	# 
	# The random number generation relies on TinyMT.
	# 
	[1204] GenerateInquiryCode() -> nn::pctl::InquiryCode;
	# This cmd takes the 0x20 bytes produced by GenerateInquiryCode, and an
	# 0x20 byte X descriptor containing snprintf("%08llu", master\_key), and
	# returns a bool 00 if the master key is not valid, and 01 if it is.
	# 
	# Master Keys are validated as follows on \<=
	# [3.0.0](http://switchbrew.org/index.php?title=3.0.0 "wikilink"): first,
	# svcSleepThread(1000000000LL) is called to introduce a delay to prevent
	# brute force attacks. Then, strlen(master\_key) is called -- if this is
	# not 8, 0 is returned. Next, the inquiry code is regenerated and
	# snprintf("%02d%08llu", 10, generated\_inquiry\_rnd) is compared to the
	# inquiry data passed in as an argument. If this doesn't match, 0 is
	# returned. Then, hmac-sha256(snprintf("%02d%08llu", 10,
	# generated\_inquiry\_rnd)) is called using hardcoded keydata, and the
	# master key argument is compared to snprintf("%08llu", (hmac\_result &
	# 0xFFFFFFFFFFFF) % 100000000). If this matches, 1 is returned, otherwise
	# 0 is returned.
	# 
	# On [3.0.1](http://switchbrew.org/index.php?title=3.0.1 "wikilink") this
	# was changed to use different hardcoded keydata, and to pass 11 as the
	# snprintf argument instead of
	# 10.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	[1205] CheckMasterKey(nn::pctl::InquiryCode, buffer<u8,9>) -> b8;
	[1206] GetPinCodeLength() -> u32;
	[1207] GetPinCodeChangedEvent() -> handle<copy>;
	@version(4.0.0+)
	[1208] GetPinCode() -> (u32, buffer<u8,0xa>);
	[1403] IsPairingActive() -> b8;
	[1406] GetSettingsLastUpdated() -> nn::time::PosixTime;
	[1411] GetPairingAccountInfo(nn::pctl::detail::PairingInfoBase) -> nn::pctl::detail::PairingAccountInfoBase;
	[1421] GetAccountNickname(nn::pctl::detail::PairingAccountInfoBase) -> (u32, buffer<u8,0xa>);
	[1424] GetAccountState(nn::pctl::detail::PairingAccountInfoBase) -> u32;
	[1432] GetSynchronizationEvent() -> handle<copy>;
	[1451] StartPlayTimer();
	[1452] StopPlayTimer();
	[1453] IsPlayTimerEnabled() -> b8;
	[1454] GetPlayTimerRemainingTime() -> nn::TimeSpanType;
	[1455] IsRestrictedByPlayTimer() -> b8;
	[1456] GetPlayTimerSettings() -> nn::pctl::PlayTimerSettings;
	[1457] GetPlayTimerEventToRequestSuspension() -> handle<copy>;
	@version(4.0.0+)
	[1458] IsPlayTimerAlarmDisabled() -> b8;
	[1471] NotifyWrongPinCodeInputManyTimes();
	[1472] CancelNetworkRequest();
	[1473] GetUnlinkedEvent() -> handle<copy>;
	[1474] ClearUnlinkedEvent();
	[1601] DisableAllFeatures() -> b8;
	[1602] PostEnableAllFeatures() -> b8;
	[1603] IsAllFeaturesDisabled() -> (b8, b8);
	[1901] DeleteFromFreeCommunicationApplicationListForDebug(nn::ncm::ApplicationId);
	[1902] ClearFreeCommunicationApplicationListForDebug();
	@version(5.0.0+)
	@undocumented
	[1903] GetExemptApplicationListCountForDebug(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1904] GetExemptApplicationListForDebug(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1905] UpdateExemptApplicationListForDebug(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1906] AddToExemptApplicationListForDebug(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1907] DeleteFromExemptApplicationListForDebug(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[1908] ClearExemptApplicationListForDebug(unknown) -> unknown;
	[1941] DeletePairing();
	[1951] SetPlayTimerSettingsForDebug(nn::pctl::PlayTimerSettings);
	[1952] GetPlayTimerSpentTimeForTest() -> nn::TimeSpanType;
	@version(4.0.0+)
	[1953] SetPlayTimerAlarmDisabledForDebug(b8);
	[2001] RequestPairingAsync(buffer<u8,9>) -> (nn::pctl::detail::AsyncData, handle<copy>);
	[2002] FinishRequestPairing(nn::pctl::detail::AsyncData) -> nn::pctl::detail::PairingInfoBase;
	[2003] AuthorizePairingAsync(nn::pctl::detail::PairingInfoBase) -> (nn::pctl::detail::AsyncData, handle<copy>);
	[2004] FinishAuthorizePairing(nn::pctl::detail::AsyncData) -> nn::pctl::detail::PairingInfoBase;
	[2005] RetrievePairingInfoAsync() -> (nn::pctl::detail::AsyncData, handle<copy>);
	[2006] FinishRetrievePairingInfo(nn::pctl::detail::AsyncData) -> nn::pctl::detail::PairingInfoBase;
	[2007] UnlinkPairingAsync(b8) -> (nn::pctl::detail::AsyncData, handle<copy>);
	[2008] FinishUnlinkPairing(b8, nn::pctl::detail::AsyncData);
	[2009] GetAccountMiiImageAsync(nn::pctl::detail::PairingAccountInfoBase) -> (nn::pctl::detail::AsyncData, u32, handle<copy>, buffer<bytes,6>);
	[2010] FinishGetAccountMiiImage(nn::pctl::detail::AsyncData) -> (u32, buffer<bytes,6>);
	[2011] GetAccountMiiImageContentTypeAsync(nn::pctl::detail::PairingAccountInfoBase) -> (nn::pctl::detail::AsyncData, u32, handle<copy>, buffer<u8,0xa>);
	[2012] FinishGetAccountMiiImageContentType(nn::pctl::detail::AsyncData) -> (u32, buffer<u8,0xa>);
	[2013] SynchronizeParentalControlSettingsAsync() -> (nn::pctl::detail::AsyncData, handle<copy>);
	[2014] FinishSynchronizeParentalControlSettings(nn::pctl::detail::AsyncData);
	[2015] FinishSynchronizeParentalControlSettingsWithLastUpdated(nn::pctl::detail::AsyncData) -> nn::time::PosixTime;
	@version(5.0.0+)
	@undocumented
	[2016] RequestUpdateExemptionListAsync(unknown) -> unknown;
}

interface nn::pctl::detail::ipc::IParentalControlServiceFactory is pctl, pctl:a, pctl:s, pctl:r {
	[0] CreateService(u64, pid) -> object<nn::pctl::detail::ipc::IParentalControlService>;
	@version(4.0.0+)
	[1] CreateServiceWithoutInitialize(u64, pid) -> object<nn::pctl::detail::ipc::IParentalControlService>;
}

interface nn::pcv::IArbitrationManager is pcv:arb {
	[0] ReleaseControl(u32);
}

interface nn::pcv::IImmediateManager is pcv:imm {
	[0] SetClockRate(u32, u32);
}

interface nn::pcv::detail::IPcvService is pcv {
	[0] SetPowerEnabled(b8, u32);
	[1] SetClockEnabled(b8, u32);
	[2] SetClockRate(u32, u32);
	[3] GetClockRate(u32) -> u32;
	[4] GetState(u32) -> nn::pcv::ModuleState;
	[5] GetPossibleClockRates(u32, u32) -> (u32, u32, buffer<u32,0xa>);
	[6] SetMinVClockRate(u32, u32);
	[7] SetReset(b8, u32);
	[8] SetVoltageEnabled(b8, u32);
	[9] GetVoltageEnabled(u32) -> b8;
	[10] GetVoltageRange(u32) -> (u32, u32, u32);
	[11] SetVoltageValue(u32, u32);
	[12] GetVoltageValue(u32) -> u32;
	[13] GetTemperatureThresholds(u32) -> (u32, buffer<nn::pcv::TemperatureThreshold,0xa>);
	[14] SetTemperature(u32);
	[15] Initialize();
	[16] IsInitialized() -> b8;
	[17] Finalize();
	[18] PowerOn(nn::pcv::PowerControlTarget, u32);
	[19] PowerOff(nn::pcv::PowerControlTarget);
	[20] ChangeVoltage(nn::pcv::PowerControlTarget, u32);
	[21] GetPowerClockInfoEvent() -> handle<copy>;
	[22] GetOscillatorClock() -> u32;
	[23] GetDvfsTable(u32, u32) -> (u32, buffer<u32,0xa>, buffer<u32,0xa>);
	[24] GetModuleStateTable(u32) -> (u32, buffer<nn::pcv::ModuleState,0xa>);
	[25] GetPowerDomainStateTable(u32) -> (u32, buffer<nn::pcv::PowerDomainState,0xa>);
	[26] GetFuseInfo(u32) -> (u32, buffer<u32,0xa>);
}

interface nn::pinmux::IManager is pinmux {
	@undocumented
	[0] OpenSession(unknown<4>) -> object<nn::pinmux::ISession>;
}

interface nn::pinmux::ISession {
	@undocumented
	[0] SetPinAssignment(unknown<4>);
	@undocumented
	[1] GetPinAssignment() -> unknown<4>;
	@undocumented
	[2] SetPinAssignmentForHardwareTest(unknown<4>);
}

interface nn::pl::detail::ISharedFontManager is pl:u {
	# Takes a
	# [\#SharedFontType](http://switchbrew.org/index.php?title=Shared%20Database%20services#SharedFontType "wikilink")
	# (uint32), no output.
	# 
	[0] RequestLoad(u32);
	# Takes a
	# [\#SharedFontType](http://switchbrew.org/index.php?title=Shared%20Database%20services#SharedFontType "wikilink")
	# (uint32), returns the
	# [\#LoadState](http://switchbrew.org/index.php?title=Shared%20Database%20services#LoadState "wikilink")
	# (uint32).
	# 
	[1] GetLoadState(u32) -> u32;
	# Takes a
	# [\#SharedFontType](http://switchbrew.org/index.php?title=Shared%20Database%20services#SharedFontType "wikilink")
	# (uint32), returns the Font Size (uint32).
	# 
	[2] GetSize(u32) -> u32;
	# Takes a
	# [\#SharedFontType](http://switchbrew.org/index.php?title=Shared%20Database%20services#SharedFontType "wikilink")
	# (uint32), returns the offset (uint32) to the Font Address.
	# 
	[3] GetSharedMemoryAddressOffset(u32) -> u32;
	# No input, returns an output SharedMemory handle.
	# 
	# User-processes map this SharedMemory with size=0x1100000 and
	# permissions=R--.
	# 
	# Font data is TTF, located at the offset returned by
	# [\#GetSharedMemoryAddressOffset](#nn::pl::detail::ISharedFontManager\(3\) "wikilink").
	# 
	[4] GetSharedMemoryNativeHandle() -> handle<copy>;
	# Takes an input u64
	# [LanguageCode](http://switchbrew.org/index.php?title=Settings_services#LanguageCode "wikilink")
	# and 3 type-0x6 output buffers, returns an output u8 and u32. The u8 is a
	# bool to specify if the fonts are loaded or not and the u32 is the font
	# count. The first buffer contains a list of [Shared font
	# types](http://switchbrew.org/index.php?title=Shared%20Database%20services#SharedFontType "wikilink"),
	# the second buffer contains the font offsets and the final buffer
	# contains the font sizes. The buffers are an array of u32s which specify
	# information about a specific font. Buffer1\[n\] is related to
	# Buffer2\[n\] and Buffer3\[n\]. Example: Font index 0s offset is at
	# Buffer2\[0\], size is at Buffer3\[0\]. The fonts are relative to the
	# shared memory created by
	# [\#GetSharedMemoryNativeHandle](#nn::pl::detail::ISharedFontManager\(4\) "wikilink")
	# 
	[5] GetSharedFontInOrderOfPriority(bytes<8,1>) -> (u8, u32, buffer<unknown,6>, buffer<unknown,6>, buffer<unknown,6>);
}

interface nn::pm::detail::IBootModeInterface is pm:bm {
	@undocumented
	[0] GetBootMode() -> unknown<4>;
	@undocumented
	[1] SetMaintenanceBoot();
}

interface nn::pm::detail::IDebugMonitorInterface is pm:dmnt {
	# Always returns u32 0 on retail.
	# 
	# \[2.0.0+\] Additional check on input that can return 0xC0F. The meaning
	# is probably useless because function is somewhat nopped on non-dev
	# builds anyway.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[0] IsDebugMode(unknown<8>) -> (unknown<4>, buffer<unknown,6>);
	# Returns an array of pids of all processes that have mask 4 set in
	# process flags.
	# 
	# \[2.0.0+\] Additional check on input that can return 0xC0F. The meaning
	# is probably useless because function is somewhat nopped on non-dev
	# builds anyway.
	# 
	@version(5.0.0+)
	@undocumented
	[0] GetDebugProcesses(unknown<8>) -> (unknown<4>, buffer<unknown,6>);
	# Takes a pid. Last process event must be ProcessEvent\_Created or
	# ProcessEvent\_DebugAttached.
	# 
	# Then it uses svcStartProcess(process\_handle, u8, u8, u32) with args
	# coming from ldr:pm GetProgramInfo.
	# 
	# After that, it sets last process state to ProcessEvent\_DebugDetached.
	# 
	@version(5.0.0+)
	@undocumented
	[1] StartDebugProcess() -> (unknown<4>, buffer<unknown,6>);
	# Returns an array of pids of all processes that have mask 4 set in
	# process flags.
	# 
	# \[2.0.0+\] Additional check on input that can return 0xC0F. The meaning
	# is probably useless because function is somewhat nopped on non-dev
	# builds anyway.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[1] GetDebugProcesses() -> (unknown<4>, buffer<unknown,6>);
	# Takes a pid. Last process event must be ProcessEvent\_Created or
	# ProcessEvent\_DebugAttached.
	# 
	# Then it uses svcStartProcess(process\_handle, u8, u8, u32) with args
	# coming from ldr:pm GetProgramInfo.
	# 
	# After that, it sets last process state to ProcessEvent\_DebugDetached.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[2] StartDebugProcess(unknown<8>);
	# Takes a title-id and returns the pid.
	# 
	@version(5.0.0+)
	@undocumented
	[2] GetTitlePid(unknown<8>);
	# Takes a title-id and returns the pid.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[3] GetTitlePid(unknown<8>) -> unknown<8>;
	# Takes a title-id of the program to debug. Sets this to a global field.
	# 
	# Next time it gets launched it will be handled differently.
	# 
	# Returns an event handle that is signaled when the requested title is
	# about to be launched.
	# 
	@version(5.0.0+)
	@undocumented
	[3] EnableDebugForTitleId(unknown<8>) -> unknown<8>;
	# Takes a title-id of the program to debug. Sets this to a global field.
	# 
	# Next time it gets launched it will be handled differently.
	# 
	# Returns an event handle that is signaled when the requested title is
	# about to be launched.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[4] EnableDebugForTitleId(unknown<8>) -> handle<copy>;
	# Returns the pid of the application process.
	# 
	@version(5.0.0+)
	@undocumented
	[4] GetApplicationPid(unknown<8>) -> handle<copy>;
	# Returns the pid of the application process.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[5] GetApplicationPid() -> unknown<8>;
	# Does \*not\* take a specific title-id as input.
	# 
	# Returns an event handle that is triggered for application titles.
	# 
	@version(5.0.0+)
	@undocumented
	[5] EnableDebugForApplication() -> unknown<8>;
	# Does \*not\* take a specific title-id as input.
	# 
	# Returns an event handle that is triggered for application titles.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[6] EnableDebugForApplication() -> handle<copy>;
	# Takes in a u32 of bitflags.
	# 
	# Disables debugging/clears the globally specified tid if bit 0 is set,
	# disables debugging/clears the next application if bit 1 is set.
	# 
	@version(6.0.0+)
	@undocumented
	[6] DisableDebug() -> handle<copy>;
}

interface nn::pm::detail::IInformationInterface is pm:info {
	# Takes a pid and returns the title-id associated with the process.
	# 
	@undocumented
	[0] GetTitleId(unknown<8>) -> unknown<8>;
}

interface nn::pm::detail::IShellInterface is pm:shell {
	# Takes launch\_flags, title-id, and storageID. See [\#Process
	# launch](http://switchbrew.org/index.php?title=Process%20Manager%20services#Process_launch "wikilink").
	# 
	# Returns the u64 title PID.
	# 
	@undocumented
	[0] LaunchProcess(unknown<0x18>) -> unknown<8>;
	@undocumented
	[1] TerminateProcessByPid(unknown<8>);
	@undocumented
	[2] TerminateProcessByTitleId(unknown<8>);
	@undocumented
	[3] GetProcessEventWaiter() -> handle<copy>;
	# Returns 1 if flags has mask 2 set.
	# 
	# Returns 2 if flags has mask 1 set and state is 6.
	# 
	# Returns 3 if flags has mask 0x10 set and not 0x20.
	# 
	# Returns 4 if flags has mask 0x30 set.
	# 
	# \[2.0.0+\] returns 5 if state \>= 2 and flags has mask 0x100 set.
	# 
	# Returns 0 if process is not found.
	# 
	@undocumented
	[4] GetProcessEventType() -> unknown<0x10>;
	# Takes a pid as input. If the process with pid has the state "dead", it
	# unregisters the pid in fsp:pr, sm:m, and ldr:pm.
	# 
	# Then it removes the process from PMs internal linked-list of active
	# processes.
	# 
	# \[5.0.0+\] This command was removed.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[5] FinalizeDeadProcess(unknown<8>);
	# This launches the
	# [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink") title.
	# 
	# \[4.0.0+\] When booting from SafeMode Firmware, instead of
	# [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink"), this
	# launches the following titles in order:
	# 
	#   - 0100000000000009 (settings)
	#   - 0100000000000006 (usb)
	#   - 010000000000001D (pcie)
	#   - 0100000000000007 (tma)
	#   - 010000000000001F (ns)
	#   - 0100000000000015 (lm)
	#   - 0100000000000010 (ptm)
	#   - 0100000000000016 (wlan)
	#   - 0100000000000012 (bsdsockets)
	#   - 010000000000000F (nifm)
	#   - 0100000000000024 (ssl)
	#   - 0100000000000025 (nim)
	#   - 0100000000000031 (glue)
	#   - 010000000000003D (safemode)
	# 
	@version(5.0.0+)
	@undocumented
	[5] NotifyBootFinished(unknown<8>);
	# Returns the pid of the application process.
	# 
	@version(5.0.0+)
	@undocumented
	[6] GetApplicationPid(unknown<8>);
	# Takes a pid as input. Clears 0x10 from process flags.
	# 
	# \[5.0.0+\] This command was removed.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[6] ClearProcessNotificationFlag(unknown<8>);
	# This launches the
	# [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink") title.
	# 
	# \[4.0.0+\] When booting from SafeMode Firmware, instead of
	# [boot2](http://switchbrew.org/index.php?title=boot2 "wikilink"), this
	# launches the following titles in order:
	# 
	#   - 0100000000000009 (settings)
	#   - 0100000000000006 (usb)
	#   - 010000000000001D (pcie)
	#   - 0100000000000007 (tma)
	#   - 010000000000001F (ns)
	#   - 0100000000000015 (lm)
	#   - 0100000000000010 (ptm)
	#   - 0100000000000016 (wlan)
	#   - 0100000000000012 (bsdsockets)
	#   - 010000000000000F (nifm)
	#   - 0100000000000024 (ssl)
	#   - 0100000000000025 (nim)
	#   - 0100000000000031 (glue)
	#   - 010000000000003D (safemode)
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[7] NotifyBootFinished();
	# Takes an u64 **mem\_size** as input. If the desired memory size doesn't
	# exceed an internal limit (imposed by PM by looking at the
	# [MemoryArrange](http://switchbrew.org/index.php?title=SPL_services#MemoryArrange "wikilink")
	# ConfigItem), PM calls svcSetResourceLimitLimitValue to set the new
	# [LimitableResource\_Memory](http://switchbrew.org/index.php?title=SVC#LimitableResource "wikilink")
	# value.
	# 
	# This is used directly by [ns:am2
	# BoostSystemMemoryResourceLimit](http://switchbrew.org/index.php?title=NS_Services#IApplicationManagerInterface "wikilink").
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(5.0.0+)
	@undocumented
	[7] BoostSystemMemoryResourceLimit();
	# Returns the pid of the application process.
	# 
	@version(1.0.0-4.1.0)
	@undocumented
	[8] GetApplicationPid() -> unknown<8>;
	# Takes an u64 **mem\_size** as input. If the desired memory size doesn't
	# exceed an internal limit (imposed by PM by looking at the
	# [MemoryArrange](http://switchbrew.org/index.php?title=SPL_services#MemoryArrange "wikilink")
	# ConfigItem), PM calls svcSetResourceLimitLimitValue to set the new
	# [LimitableResource\_Memory](http://switchbrew.org/index.php?title=SVC#LimitableResource "wikilink")
	# value.
	# 
	# This is used directly by [ns:am2
	# BoostSystemMemoryResourceLimit](http://switchbrew.org/index.php?title=NS_Services#IApplicationManagerInterface "wikilink").
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(4.0.0-4.1.0)
	@undocumented
	[9] BoostSystemMemoryResourceLimit(unknown<8>);
}

interface nn::prepo::detail::ipc::IPrepoService is prepo:u, prepo:s, prepo:m, prepo:a {
	[10100] SaveReport(u64, pid, buffer<u8,9>, buffer<bytes,5>);
	[10101] SaveReportWithUser(nn::account::Uid, u64, pid, buffer<u8,9>, buffer<bytes,5>);
	[10200] RequestImmediateTransmission();
	[10300] GetTransmissionStatus() -> u32;
	[20100] SaveSystemReport(nn::ApplicationId, buffer<u8,9>, buffer<bytes,5>);
	[20101] SaveSystemReportWithUser(nn::account::Uid, nn::ApplicationId, buffer<u8,9>, buffer<bytes,5>);
	@version(4.0.0+)
	[20200] SetOperationMode(u64);
	[30100] ClearStorage();
	[40100] IsUserAgreementCheckEnabled() -> b8;
	[40101] SetUserAgreementCheckEnabled(b8);
	[90100] GetStorageUsage() -> (u64, u64);
	@version(5.0.0+)
	@undocumented
	[90200] GetStatistics(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[90201] GetThroughputHistory(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[90300] GetLastUploadError(unknown) -> unknown;
}

interface nn::profiler::IProfiler is banana {
	@undocumented
	[0] GetSystemEvent(unknown) -> unknown;
	@undocumented
	[1] StartSignalingEvent(unknown) -> unknown;
	@undocumented
	[2] StopSignalingEvent(unknown) -> unknown;
}

interface nn::psc::sf::IPmControl is psc:c {
	@undocumented
	[0] Unknown0() -> handle<copy>;
	@undocumented
	[1] Unknown1(unknown<0xc>);
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3() -> unknown<4>;
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] Unknown6() -> (unknown<0x28>, buffer<unknown,6>, buffer<unknown,6>);
}

interface nn::psc::sf::IPmModule {
	@undocumented
	[0] Initialize(unknown<4>, buffer<unknown,5>) -> handle<copy>;
	@undocumented
	[1] GetRequest() -> unknown<8>;
	@undocumented
	[2] Acknowledge();
	@undocumented
	[3] Unknown3();
}

interface nn::psc::sf::IPmService is psc:m {
	@undocumented
	[0] GetPmModule() -> object<nn::psc::sf::IPmModule>;
}

interface nn::psm::IPsmServer is psm {
	@undocumented
	[0] GetBatteryChargePercentage() -> unknown<4>;
	@undocumented
	[1] GetChargerType() -> unknown<4>;
	@undocumented
	[2] EnableBatteryCharging();
	@undocumented
	[3] DisableBatteryCharging();
	@undocumented
	[4] IsBatteryChargingEnabled() -> unknown<1>;
	@undocumented
	[5] AcquireControllerPowerSupply();
	@undocumented
	[6] ReleaseControllerPowerSupply();
	@undocumented
	[7] OpenSession() -> object<nn::psm::IPsmSession>;
	@undocumented
	[8] EnableEnoughPowerChargeEmulation();
	@undocumented
	[9] DisableEnoughPowerChargeEmulation();
	@undocumented
	[10] EnableFastBatteryCharging();
	@undocumented
	[11] DisableFastBatteryCharging();
	@undocumented
	[12] GetBatteryVoltageState() -> unknown<4>;
	@undocumented
	[13] GetRawBatteryChargePercentage() -> unknown<8>;
	@undocumented
	[14] IsEnoughPowerSupplied() -> unknown<1>;
	@undocumented
	[15] GetBatteryAgePercentage() -> unknown<8>;
	@undocumented
	[16] GetBatteryChargeInfoEvent() -> handle<copy>;
	@undocumented
	[17] GetBatteryChargeInfoFields() -> unknown<0x40>;
}

interface nn::psm::IPsmSession {
	@undocumented
	[0] BindStateChangeEvent() -> handle<copy>;
	@undocumented
	[1] UnbindStateChangeEvent();
	@undocumented
	[2] SetChargerTypeChangeEventEnabled(unknown<1>);
	@undocumented
	[3] SetPowerSupplyChangeEventEnabled(unknown<1>);
	@undocumented
	[4] SetBatteryVoltageStateChangeEventEnabled(unknown<1>);
}

interface nn::pwm::IChannelSession {
	[0] SetPeriod(u64);
	[1] GetPeriod() -> u64;
	[2] SetDuty(u32);
	[3] GetDuty() -> u32;
	[4] SetEnabled(u8);
	[5] GetEnabled() -> u8;
}

interface nn::pwm::IManager is pwm {
	[0] OpenSessionForDev(u32) -> object<nn::pwm::IChannelSession>;
	[1] OpenSession(u32) -> object<nn::pwm::IChannelSession>;
}

interface nn::sasbus::IManager is sasbus {
	@undocumented
	[0] OpenSession(unknown<4>) -> object<nn::sasbus::ISession>;
}

interface nn::sasbus::ISession {
	@undocumented
	[0] Unknown0(unknown<1>, buffer<unknown,0x21>);
	@undocumented
	[1] Unknown1(unknown<1>) -> buffer<unknown,0x22>;
	@undocumented
	[2] Unknown2(unknown<0x18>, handle<copy>);
	@undocumented
	[3] Unknown3();
}

interface nn::settings::IFactorySettingsServer is set:cal {
	[0] GetBluetoothBdAddress() -> nn::settings::factory::BdAddress;
	[1] GetConfigurationId1() -> nn::settings::factory::ConfigurationId1;
	[2] GetAccelerometerOffset() -> nn::settings::factory::AccelerometerOffset;
	[3] GetAccelerometerScale() -> nn::settings::factory::AccelerometerScale;
	[4] GetGyroscopeOffset() -> nn::settings::factory::GyroscopeOffset;
	[5] GetGyroscopeScale() -> nn::settings::factory::GyroscopeScale;
	[6] GetWirelessLanMacAddress() -> nn::settings::factory::MacAddress;
	[7] GetWirelessLanCountryCodeCount() -> u32;
	[8] GetWirelessLanCountryCodes() -> (u32, buffer<nn::settings::factory::CountryCode,0xa>);
	[9] GetSerialNumber() -> nn::settings::factory::SerialNumber;
	[10] SetInitialSystemAppletProgramId(nn::ncm::ProgramId);
	[11] SetOverlayDispProgramId(nn::ncm::ProgramId);
	[12] GetBatteryLot() -> nn::settings::factory::BatteryLot;
	# Takes a type-0x16 output buffer with fixed size 0x180.
	# 
	# Returns the device certificate (ECC signed). This is identical to 3DS
	# DeviceCert/CTCert besides the strings. NIM loads the DeviceId from this.
	# 
	[14] GetEciDeviceCertificate() -> buffer<nn::settings::factory::EccB233DeviceCertificate,0x16>;
	# Takes a type-0x16 output buffer with fixed size 0x240.
	# 
	# Returns the ETicket certificate (RSA signed).
	# 
	[15] GetEticketDeviceCertificate() -> buffer<nn::settings::factory::Rsa2048DeviceCertificate,0x16>;
	# Takes a type-0x16 output buffer with fixed size 0x134.
	# 
	# Returns the extended SSL key (0x130 bytes) from
	# [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink").
	# If the extended key is not programmed then it falls back to the normal
	# SSL key (0x110 bytes).
	# 
	# Used by SSL-sysmodule, see
	# [here](http://switchbrew.org/index.php?title=SSL_services "wikilink").
	# 
	[16] GetSslKey() -> buffer<nn::settings::factory::SslKey,0x16>;
	# Takes a type-0x16 output buffer with fixed size 0x804.
	# 
	# Returns a
	# [container](http://switchbrew.org/index.php?title=Settings_services#setcal_Container_Structure "wikilink")
	# with the plaintext SSL certificate.
	# 
	# Used by SSL-sysmodule, see
	# [here](http://switchbrew.org/index.php?title=SSL_services "wikilink").
	# 
	[17] GetSslCertificate() -> buffer<nn::settings::factory::SslCertificate,0x16>;
	# Takes a type-0x16 output buffer with fixed size 0x134.
	# 
	# Returns the extended GameCard key (0x130 bytes) from
	# [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink").
	# If the extended key is not programmed then it falls back to the normal
	# GameCard key (0x110 bytes).
	# 
	[18] GetGameCardKey() -> buffer<nn::settings::factory::GameCardKey,0x16>;
	# Takes a type-0x16 output buffer with fixed size 0x404.
	# 
	# Returns a
	# [container](http://switchbrew.org/index.php?title=Settings_services#setcal_Container_Structure "wikilink")
	# with the GameCard certificate.
	# 
	[19] GetGameCardCertificate() -> buffer<nn::settings::factory::GameCardCertificate,0x16>;
	# Returns the extended device ECC-B233 key (0x50 bytes) from
	# [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink").
	# If the extended key is not programmed then it falls back to the normal
	# device ECC-B233 key (0x30 bytes).
	# 
	[20] GetEciDeviceKey() -> nn::settings::factory::EccB233DeviceKey;
	# Takes a type-0x16 output buffer with fixed size 0x244.
	# 
	# Returns the extended ETicket RSA-2048 key (0x240 bytes) from
	# [CAL0](http://switchbrew.org/index.php?title=Calibration#CAL0 "wikilink").
	# If the extended key is not programmed then it falls back to the normal
	# ETicket RSA-2048 key (0x220 bytes).
	# 
	[21] GetEticketDeviceKey() -> buffer<nn::settings::factory::Rsa2048DeviceKey,0x16>;
	[22] GetSpeakerParameter() -> nn::settings::factory::SpeakerParameter;
	@version(4.0.0+)
	[23] GetLcdVendorId() -> u32;
	@version(5.0.0+)
	@undocumented
	[24] GetEciDeviceCertificate2(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[25] GetEciDeviceKey2(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[26] GetAmiiboKey(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[27] GetAmiiboEcqvCertificate(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[28] GetAmiiboEcdsaCertificate(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[29] GetAmiiboEcqvBlsKey(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[30] GetAmiiboEcqvBlsCertificate(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[31] GetAmiiboEcqvBlsRootCertificate(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[32] GetUnknownId(unknown) -> unknown;
	@version(6.0.0+)
	@undocumented
	[33] GetUnknownId2(unknown) -> unknown;
}

interface nn::settings::IFirmwareDebugSettingsServer is set:fd {
	[2] SetSettingsItemValue(buffer<nn::settings::SettingsName,0x19>, buffer<nn::settings::SettingsItemKey,0x19>, buffer<bytes,5>);
	[3] ResetSettingsItemValue(buffer<nn::settings::SettingsName,0x19>, buffer<nn::settings::SettingsItemKey,0x19>);
	[4] CreateSettingsItemKeyIterator(buffer<nn::settings::SettingsName,0x19>) -> object<nn::settings::ISettingsItemKeyIterator>;
	@version(4.0.0+)
	[10] ReadSettings(u32) -> (u64, buffer<bytes,6>);
	@version(4.0.0+)
	[11] ResetSettings(u32);
	@version(4.0.0+)
	[20] SetWebInspectorFlag(b8);
	@version(4.0.0+)
	[21] SetAllowedSslHosts(buffer<nn::settings::system::AllowedSslHost,5>);
	@version(4.0.0+)
	[22] SetHostFsMountPoint(buffer<nn::settings::system::HostFsMountPoint,0x15>);
}

interface nn::settings::ISettingsServer is set {
	[0] GetLanguageCode() -> nn::settings::LanguageCode;
	[1] GetAvailableLanguageCodes() -> (u32, buffer<nn::settings::LanguageCode,0xa>);
	@version(4.0.0+)
	[2] MakeLanguageCode(u32) -> nn::settings::LanguageCode;
	[3] GetAvailableLanguageCodeCount() -> u32;
	[4] GetRegionCode() -> u32;
	@version(4.0.0+)
	[5] GetAvailableLanguageCodes2() -> (u32, buffer<nn::settings::LanguageCode,6>);
	@version(4.0.0+)
	[6] GetAvailableLanguageCodeCount2() -> u32;
	@version(4.0.0+)
	[7] GetKeyCodeMap() -> buffer<nn::kpr::KeyCodeMap,0x16>;
	@version(5.0.0+)
	@undocumented
	[8] GetQuestFlag(unknown) -> unknown;
}

interface nn::settings::ISystemSettingsServer is set:sys {
	[0] SetLanguageCode(nn::settings::LanguageCode);
	[1] SetNetworkSettings(buffer<nn::settings::system::NetworkSettings,5>);
	[2] GetNetworkSettings() -> (u32, buffer<nn::settings::system::NetworkSettings,6>);
	# Takes a type-0x1A output buffer. User-processes use hard-coded size
	# 0x100.
	# 
	# If needed, reads the content of the
	# [System\_Version\_Title](http://switchbrew.org/index.php?title=System_Version_Title "wikilink")
	# "/file" into state. This is only done once.
	# 
	# Then the above 0x100-byte data is copied to the output buffer.
	# 
	[3] GetFirmwareVersion() -> buffer<nn::settings::system::FirmwareVersion,0x1a>;
	@version(3.0.0+)
	[4] GetFirmwareVersion2() -> buffer<nn::settings::system::FirmwareVersion,0x1a>;
	@version(5.0.0+)
	@undocumented
	[5] GetFirmwareVersionDigest(unknown) -> unknown;
	[7] GetLockScreenFlag() -> b8;
	[8] SetLockScreenFlag(b8);
	[9] GetBacklightSettings() -> nn::settings::system::BacklightSettings;
	[10] SetBacklightSettings(nn::settings::system::BacklightSettings);
	[11] SetBluetoothDevicesSettings(buffer<nn::settings::system::BluetoothDevicesSettings,5>);
	[12] GetBluetoothDevicesSettings() -> (u32, buffer<nn::settings::system::BluetoothDevicesSettings,6>);
	[13] GetExternalSteadyClockSourceId() -> nn::util::Uuid;
	[14] SetExternalSteadyClockSourceId(nn::util::Uuid);
	[15] GetUserSystemClockContext() -> nn::time::SystemClockContext;
	[16] SetUserSystemClockContext(nn::time::SystemClockContext);
	[17] GetAccountSettings() -> nn::settings::system::AccountSettings;
	[18] SetAccountSettings(nn::settings::system::AccountSettings);
	[19] GetAudioVolume(u32) -> nn::settings::system::AudioVolume;
	[20] SetAudioVolume(nn::settings::system::AudioVolume, u32);
	[21] GetEulaVersions() -> (u32, buffer<nn::settings::system::EulaVersion,6>);
	[22] SetEulaVersions(buffer<nn::settings::system::EulaVersion,5>);
	# No input, returns an output s32.
	# 
	# This is the current Theme set by System Settings.
	# 
	#   - 0: "Basic White"
	#   - 1: "Basic Black"
	# 
	[23] GetColorSetId() -> u32;
	# Takes an input s32, no output.
	# 
	[24] SetColorSetId(u32);
	[25] GetConsoleInformationUploadFlag() -> b8;
	[26] SetConsoleInformationUploadFlag(b8);
	[27] GetAutomaticApplicationDownloadFlag() -> b8;
	[28] SetAutomaticApplicationDownloadFlag(b8);
	[29] GetNotificationSettings() -> nn::settings::system::NotificationSettings;
	[30] SetNotificationSettings(nn::settings::system::NotificationSettings);
	[31] GetAccountNotificationSettings() -> (u32, buffer<nn::settings::system::AccountNotificationSettings,6>);
	[32] SetAccountNotificationSettings(buffer<nn::settings::system::AccountNotificationSettings,5>);
	[35] GetVibrationMasterVolume() -> f32;
	[36] SetVibrationMasterVolume(f32);
	[37] GetSettingsItemValueSize(buffer<nn::settings::SettingsName,0x19>, buffer<nn::settings::SettingsItemKey,0x19>) -> u64;
	# Takes two type-0x19 input buffers and a type-0x6 output buffer. Returns
	# an output u64 for the actual size written to the outbuf.
	# 
	# The outbuf\_size is compared with the config\_size. When config\_size is
	# larger than outbuf\_size, outbuf\_size is used for the memcpy, otherwise
	# config\_size is used. Afterwards the size used for the memcpy is written
	# to output(see above).
	# 
	# If loading from main config fails, it will also attempt to load config
	# from various state if the input strings match hard-coded strings.
	# 
	[38] GetSettingsItemValue(buffer<nn::settings::SettingsName,0x19>, buffer<nn::settings::SettingsItemKey,0x19>) -> (u64, buffer<bytes,6>);
	[39] GetTvSettings() -> nn::settings::system::TvSettings;
	[40] SetTvSettings(nn::settings::system::TvSettings);
	[41] GetEdid() -> buffer<nn::settings::system::Edid,0x1a>;
	[42] SetEdid(buffer<nn::settings::system::Edid,0x19>);
	[43] GetAudioOutputMode(u32) -> u32;
	[44] SetAudioOutputMode(u32, u32);
	[45] IsForceMuteOnHeadphoneRemoved() -> b8;
	[46] SetForceMuteOnHeadphoneRemoved(b8);
	# Gets a flag determining whether the console is a kiosk unit (codenamed
	# "Quest"). Used by qlaunch to determine whether to launch Retail
	# Interactive Display Menu.
	# 
	[47] GetQuestFlag() -> b8;
	[48] SetQuestFlag(b8);
	[49] GetDataDeletionSettings() -> nn::settings::system::DataDeletionSettings;
	[50] SetDataDeletionSettings(nn::settings::system::DataDeletionSettings);
	[51] GetInitialSystemAppletProgramId() -> nn::ncm::ProgramId;
	[52] GetOverlayDispProgramId() -> nn::ncm::ProgramId;
	[53] GetDeviceTimeZoneLocationName() -> nn::time::LocationName;
	[54] SetDeviceTimeZoneLocationName(nn::time::LocationName);
	[55] GetWirelessCertificationFileSize() -> u64;
	[56] GetWirelessCertificationFile() -> (u64, buffer<bytes,6>);
	[57] SetRegionCode(u32);
	[58] GetNetworkSystemClockContext() -> nn::time::SystemClockContext;
	[59] SetNetworkSystemClockContext(nn::time::SystemClockContext);
	[60] IsUserSystemClockAutomaticCorrectionEnabled() -> b8;
	[61] SetUserSystemClockAutomaticCorrectionEnabled(b8);
	# Returns an output u8.
	# 
	# Loads the 1-byte config for \<"settings\_debug",
	# "is\_debug\_mode\_enabled"\>. If that fails, value 0x1 is written to
	# output. This uses the same func as ReadSetting internally.
	# 
	# Returned retval is always 0.
	# 
	[62] GetDebugModeFlag() -> b8;
	[63] GetPrimaryAlbumStorage() -> u32;
	[64] SetPrimaryAlbumStorage(u32);
	[65] GetUsb30EnableFlag() -> b8;
	[66] SetUsb30EnableFlag(b8);
	[67] GetBatteryLot() -> nn::settings::system::BatteryLot;
	# Returns the 0x18-byte SerialNumber string.
	# 
	[68] GetSerialNumber() -> nn::settings::system::SerialNumber;
	[69] GetNfcEnableFlag() -> b8;
	[70] SetNfcEnableFlag(b8);
	[71] GetSleepSettings() -> nn::settings::system::SleepSettings;
	[72] SetSleepSettings(nn::settings::system::SleepSettings);
	[73] GetWirelessLanEnableFlag() -> b8;
	[74] SetWirelessLanEnableFlag(b8);
	[75] GetInitialLaunchSettings() -> nn::settings::system::InitialLaunchSettings;
	[76] SetInitialLaunchSettings(nn::settings::system::InitialLaunchSettings);
	[77] GetDeviceNickName() -> buffer<nn::settings::system::DeviceNickName,0x16>;
	[78] SetDeviceNickName(buffer<nn::settings::system::DeviceNickName,0x15>);
	[79] GetProductModel() -> u32;
	[80] GetLdnChannel() -> u32;
	[81] SetLdnChannel(u32);
	[82] AcquireTelemetryDirtyFlagEventHandle() -> handle<copy>;
	[83] GetTelemetryDirtyFlags() -> nn::util::BitFlagSet<0x80,nn::settings::system::TelemetryDirtyFlag>;
	[84] GetPtmBatteryLot() -> nn::settings::factory::BatteryLot;
	[85] SetPtmBatteryLot(nn::settings::factory::BatteryLot);
	[86] GetPtmFuelGaugeParameter() -> nn::settings::system::PtmFuelGaugeParameter;
	[87] SetPtmFuelGaugeParameter(nn::settings::system::PtmFuelGaugeParameter);
	[88] GetBluetoothEnableFlag() -> b8;
	[89] SetBluetoothEnableFlag(b8);
	[90] GetMiiAuthorId() -> nn::util::Uuid;
	[91] SetShutdownRtcValue(u64);
	[92] GetShutdownRtcValue() -> u64;
	[93] AcquireFatalDirtyFlagEventHandle() -> handle<copy>;
	[94] GetFatalDirtyFlags() -> nn::util::BitFlagSet<0x80,nn::settings::system::FatalDirtyFlag>;
	@version(2.0.0+)
	[95] GetAutoUpdateEnableFlag() -> b8;
	@version(2.0.0+)
	[96] SetAutoUpdateEnableFlag(b8);
	@version(2.0.0+)
	[97] GetNxControllerSettings() -> (u32, buffer<nn::settings::system::NxControllerSettings,6>);
	@version(2.0.0+)
	[98] SetNxControllerSettings(buffer<nn::settings::system::NxControllerSettings,5>);
	@version(2.0.0+)
	[99] GetBatteryPercentageFlag() -> b8;
	@version(2.0.0+)
	[100] SetBatteryPercentageFlag(b8);
	@version(2.0.0+)
	[101] GetExternalRtcResetFlag() -> b8;
	@version(2.0.0+)
	[102] SetExternalRtcResetFlag(b8);
	@version(3.0.0+)
	[103] GetUsbFullKeyEnableFlag() -> b8;
	@version(3.0.0+)
	[104] SetUsbFullKeyEnableFlag(b8);
	@version(3.0.0+)
	[105] SetExternalSteadyClockInternalOffset(u64);
	@version(3.0.0+)
	[106] GetExternalSteadyClockInternalOffset() -> u64;
	@version(3.0.0+)
	[107] GetBacklightSettingsEx() -> nn::settings::system::BacklightSettingsEx;
	@version(3.0.0+)
	[108] SetBacklightSettingsEx(nn::settings::system::BacklightSettingsEx);
	@version(3.0.0+)
	[109] GetHeadphoneVolumeWarningCount() -> u32;
	@version(3.0.0+)
	[110] SetHeadphoneVolumeWarningCount(u32);
	@version(3.0.0+)
	[111] GetBluetoothAfhEnableFlag() -> b8;
	@version(3.0.0+)
	[112] SetBluetoothAfhEnableFlag(b8);
	@version(3.0.0+)
	[113] GetBluetoothBoostEnableFlag() -> b8;
	@version(3.0.0+)
	[114] SetBluetoothBoostEnableFlag(b8);
	@version(3.0.0+)
	[115] GetInRepairProcessEnableFlag() -> b8;
	@version(3.0.0+)
	[116] SetInRepairProcessEnableFlag(b8);
	@version(3.0.0+)
	[117] GetHeadphoneVolumeUpdateFlag() -> b8;
	@version(3.0.0+)
	[118] SetHeadphoneVolumeUpdateFlag(b8);
	@version(3.0.0+)
	[119] NeedsToUpdateHeadphoneVolume(b8) -> (b8, b8, i8);
	@version(3.0.0+)
	[120] GetPushNotificationActivityModeOnSleep() -> u32;
	@version(3.0.0+)
	[121] SetPushNotificationActivityModeOnSleep(u32);
	# Returns 0x01 if
	# [safemode](http://switchbrew.org/index.php?title=Safemode "wikilink")
	# needs to be launched.
	# 
	@version(4.0.0+)
	[122] GetServiceDiscoveryControlSettings() -> nn::settings::system::ServiceDiscoveryControlSettings;
	@version(4.0.0+)
	[123] SetServiceDiscoveryControlSettings(nn::settings::system::ServiceDiscoveryControlSettings);
	@version(4.0.0+)
	[124] GetErrorReportSharePermission() -> u32;
	@version(4.0.0+)
	[125] SetErrorReportSharePermission(u32);
	@version(4.0.0+)
	[126] GetAppletLaunchFlags() -> nn::util::BitFlagSet<0x20,nn::settings::system::AppletLaunchFlag>;
	@version(4.0.0+)
	[127] SetAppletLaunchFlags(nn::util::BitFlagSet<0x20,nn::settings::system::AppletLaunchFlag>);
	@version(4.0.0+)
	[128] GetConsoleSixAxisSensorAccelerationBias() -> nn::settings::system::ConsoleSixAxisSensorAccelerationBias;
	@version(4.0.0+)
	[129] SetConsoleSixAxisSensorAccelerationBias(nn::settings::system::ConsoleSixAxisSensorAccelerationBias);
	@version(4.0.0+)
	[130] GetConsoleSixAxisSensorAngularVelocityBias() -> nn::settings::system::ConsoleSixAxisSensorAngularVelocityBias;
	@version(4.0.0+)
	[131] SetConsoleSixAxisSensorAngularVelocityBias(nn::settings::system::ConsoleSixAxisSensorAngularVelocityBias);
	@version(4.0.0+)
	[132] GetConsoleSixAxisSensorAccelerationGain() -> nn::settings::system::ConsoleSixAxisSensorAccelerationGain;
	@version(4.0.0+)
	[133] SetConsoleSixAxisSensorAccelerationGain(nn::settings::system::ConsoleSixAxisSensorAccelerationGain);
	@version(4.0.0+)
	[134] GetConsoleSixAxisSensorAngularVelocityGain() -> nn::settings::system::ConsoleSixAxisSensorAngularVelocityGain;
	@version(4.0.0+)
	[135] SetConsoleSixAxisSensorAngularVelocityGain(nn::settings::system::ConsoleSixAxisSensorAngularVelocityGain);
	@version(4.0.0+)
	[136] GetKeyboardLayout() -> u32;
	@version(4.0.0+)
	[137] SetKeyboardLayout(u32);
	@version(4.0.0+)
	[138] GetWebInspectorFlag() -> b8;
	# Takes a type-0x6 output buffer, returns an output s32. This buffer
	# contains an array of 0x8-byte "nn::settings::system::AllowedSslHost"
	# entries.
	# 
	@version(4.0.0+)
	[139] GetAllowedSslHosts() -> (u32, buffer<nn::settings::system::AllowedSslHost,6>);
	@version(4.0.0+)
	[140] GetHostFsMountPoint() -> buffer<nn::settings::system::HostFsMountPoint,0x16>;
	@version(5.0.0+)
	@undocumented
	[141] GetRequiresRunRepairTimeReviser(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[142] SetRequiresRunRepairTimeReviser(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[143] SetBlePairingSettings(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[144] GetBlePairingSettings(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[145] GetConsoleSixAxisSensorAngularVelocityTimeBias(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[146] SetConsoleSixAxisSensorAngularVelocityTimeBias(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[147] GetConsoleSixAxisSensorAngularAcceleration(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[148] SetConsoleSixAxisSensorAngularAcceleration(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[149] GetRebootlessSystemUpdateVersion(unknown) -> unknown;
}

interface nn::sm::detail::IManagerInterface is sm:m {
	# Takes a pid and two A descriptors with the ACID and ACI0 service lists.
	# That data originates from
	# [NPDM](http://switchbrew.org/index.php?title=NPDM "wikilink").
	# 
	[0] RegisterProcess(u64, buffer<unknown,5>, buffer<unknown,5>);
	# Takes a pid.
	# 
	[1] UnregisterProcess(u64);
}

interface nn::sm::detail::IUserInterface is sm: {
	# Takes a pid descriptor and a reserved input u64.
	# 
	[0] Initialize(u64, pid);
	# Takes a zero-padded service name encoded as an u64 integer. Returns a
	# handle.
	# 
	[1] GetService(bytes<8,1>) -> handle<move>;
	# Takes a zero-padded service name encoded as an u64 integer, an u8 bool,
	# and an u32 (session count) at the next word. Returns a handle.
	# 
	[2] RegisterService(bytes<8,1>, u8, u32) -> handle<move>;
	# Takes a zero-padded service name encoded as an u64 integer.
	# 
	[3] UnregisterService(bytes<8,1>);
}

interface nn::socket::resolver::IResolver is sfdnsres {
	[0] SetDnsAddressesPrivate(u32, buffer<unknown,5>);
	[1] GetDnsAddressPrivate(u32) -> buffer<unknown,6>;
	[2] GetHostByName(u8, u32, u64, pid, buffer<unknown,5>) -> (u32, u32, u32, buffer<unknown,6>);
	[3] GetHostByAddr(u32, u32, u32, u64, pid, buffer<unknown,5>) -> (u32, u32, u32, buffer<unknown,6>);
	[4] GetHostStringError(u32) -> buffer<unknown,6>;
	[5] GetGaiStringError(u32) -> buffer<unknown,6>;
	# Takes three type 5 buffers (host, port, and hints), and a type 6 buffer
	# (the output addrinfos). Also takes a u8 (padded to 4 bytes so the next
	# raw parameter can align), a u32, and a u64. The u8 is a boolean for
	# whether to enable "nsd resolve" (1) or not (0). Not sure what the u32
	# is. It seems to either come from a parameter to `GetAddrInfo` or be
	# zero. The u64 is most likely a placeholder for the server to copy the
	# PID into and should be zero. Both hints and the output buffer contain
	# serialized addrinfo chains. The hints buffer is sized 0x400 bytes long
	# by default, and the output buffer 0x1000 bytes.
	# 
	[6] GetAddrInfo(u8, u32, u64, pid, buffer<unknown,5>, buffer<unknown,5>, buffer<unknown,5>) -> (u32, u32, u32, buffer<unknown,6>);
	[7] GetNameInfo(u32, u32, u64, pid, buffer<unknown,5>) -> (u32, u32, buffer<unknown,6>, buffer<unknown,6>);
	[8] RequestCancelHandle(u64, pid) -> u32;
	[9] CancelSocketCall(u32, u64, pid);
	@undocumented
	[10] Unknown10(unknown) -> unknown;
	# This function clears `nn::socket::resolver::g_DnsIpServerAddressArray`,
	# setting its length to 0 as well. The array initially contains IPs filled
	# by `bsdconfig`, a privileged service handling DHCP and such.
	# 
	# Takes no arguments, doesn't return anything, never fails.
	# 
	@undocumented
	[11] ClearDnsIpServerAddressArray(unknown) -> unknown;
}

interface nn::socket::sf::IClient is bsd:u, bsd:s {
	[0] RegisterClient(bytes<0x20,4>, u64, u64, pid, handle<copy>) -> u32;
	[1] StartMonitoring(u64, pid);
	# FreeBSD's `socket` command. `bsd:u` disallows the usage of the
	# `SOCK_SEQPACKET` and `SOCK_RAW` types, with the exception of `(AF_INET,
	# SOCK_RAW, IPPROTO_ICMP)` (IPv4 `ping`), `bsd:s` needs to be used for
	# those.
	# 
	# The only registered domains are `AF_INET` and `AF_ROUTE`.
	# 
	# SocketExempt: same as socket but the socket is immediately shutdown
	# (disconnected) on creation.
	# 
	[2] Socket(u32, u32, u32) -> (u32, u32);
	[3] SocketExempt(u32, u32, u32) -> (u32, u32);
	# FreeBSD's `open` command, limited to opening `/dev/bpf`. This can be
	# used, for example, to enable promiscuous mode, see FreeBSD's `/dev/bpf`
	# for more details.
	# 
	[4] Open(u32, buffer<unknown,0x21>) -> (u32, u32);
	[5] Select(u32, bytes<0x18,8>, buffer<unknown,0x21>, buffer<unknown,0x21>, buffer<unknown,0x21>) -> (u32, u32, buffer<unknown,0x22>, buffer<unknown,0x22>, buffer<unknown,0x22>);
	[6] Poll(u32, u32, buffer<unknown,0x21>) -> (u32, u32, buffer<unknown,0x22>);
	# FreeBSD's `sysctl` command. Privileged operations are reserved for
	# `bsd:s`. `CTL_NET`, `CTL_VM`, `CTL_KERN` and `CTL_DEBUG` commands are
	# implemented (?).
	# 
	[7] Sysctl(buffer<unknown,0x21>, buffer<unknown,0x21>) -> (u32, u32, u32, buffer<unknown,0x22>);
	[8] Recv(u32, u32) -> (u32, u32, buffer<unknown,0x22>);
	[9] RecvFrom(u32, u32) -> (u32, u32, u32, buffer<unknown,0x22>, buffer<unknown,0x22>);
	[10] Send(u32, u32, buffer<unknown,0x21>) -> (u32, u32);
	[11] SendTo(u32, u32, buffer<unknown,0x21>, buffer<unknown,0x21>) -> (u32, u32);
	[12] Accept(u32) -> (u32, u32, u32, buffer<unknown,0x22>);
	[13] Bind(u32, buffer<unknown,0x21>) -> (u32, u32);
	[14] Connect(u32, buffer<unknown,0x21>) -> (u32, u32);
	[15] GetPeerName(u32) -> (u32, u32, u32, buffer<unknown,0x22>);
	[16] GetSockName(u32) -> (u32, u32, u32, buffer<unknown,0x22>);
	[17] GetSockOpt(u32, u32, u32) -> (u32, u32, u32, buffer<unknown,0x22>);
	[18] Listen(u32, u32) -> (u32, u32);
	# FreeBSD's `ioctl` function. The following ioctls are whitelisted, refer
	# to FreeBSD's headers for more details: SIOCATMARK, BIOCGBLEN, BIOCSETF
	# BIOCIMMEDIATE, BIOCSETIF, BIOCVERSION, FIONSPACE, FIONWRITE, FIONREAD,
	# SIOCGETSGCNT, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCDIFADDR, SIOCGIFINDEX,
	# SIOCGIFADDR, SIOCGIFCONF, SIOCGIFNETMASK, SIOCAIFADDR, SIOCGIFMTU,
	# SIOCSIFMTU, SIOCGIFMEDIA, SIOCSIFLLADDR and SIOCGIFXMEDIA.
	# 
	# Nintendo use the following definition (hence changing all ioctls using
	# this
	# structure):
	# 
	# `struct bpf_program {`  
	# `   u_int bf_len;`  
	# `   struct bpf_insn bf_insns[BPF_MAXINSNS]; // [512]. This is a pointer in the official structure`  
	# `};`
	# 
	[19] Ioctl(u32, u32, u32, buffer<unknown,0x21>, buffer<unknown,0x21>, buffer<unknown,0x21>, buffer<unknown,0x21>) -> (u32, u32, buffer<unknown,0x22>, buffer<unknown,0x22>, buffer<unknown,0x22>, buffer<unknown,0x22>);
	# FreeBSD's `fcntl`, limited to `F_GETFL` and `F_SETFL` with `O_NONBLOCK`.
	# 
	[20] Fcntl(u32, u32, u32) -> (u32, u32);
	[21] SetSockOpt(u32, u32, u32, buffer<unknown,0x21>) -> (u32, u32);
	[22] Shutdown(u32, u32) -> (u32, u32);
	[23] ShutdownAllSockets(u32) -> (u32, u32);
	[24] Write(u32, buffer<unknown,0x21>) -> (u32, u32);
	[25] Read(u32) -> (u32, u32, buffer<unknown,0x22>);
	[26] Close(u32) -> (u32, u32);
	# Takes a socket file descriptor and an unused u64. Duplicates the socket
	# (FreeBSD's `dup`). Reserved to `bsd:s`.
	# 
	[27] DuplicateSocket(u32, u64) -> (u32, u32);
	[28] GetResourceStatistics(u32, u32, u64, pid) -> (u32, u32, buffer<unknown,0x22>);
	@version(3.0.0+)
	[29] RecvMMsg(u32, u32, u32, bytes<0x10,8>) -> (u32, u32, buffer<unknown,0x22>);
	@version(3.0.0+)
	[30] SendMMsg(u32, u32, u32, buffer<unknown,0x21>, buffer<unknown,0x21>) -> (u32, u32);
}

interface nn::spl::detail::IGeneralInterface is spl:, spl:mig, spl:fs, spl:ssl, spl:es, spl:manu {
	# Wrapper for [GetConfig
	# SMC](http://switchbrew.org/index.php?title=SMC#GetConfig "wikilink").
	# 
	# Takes a u32 (**ConfigItem**), and returns one or more u64s
	# (**ConfigVal**).
	# 
	@undocumented
	[0] GetConfig(unknown<4>) -> unknown<8>;
	# Wrapper for [ExpMod
	# SMC](http://switchbrew.org/index.php?title=SMC#ExpMod "wikilink").
	# 
	# Takes one type-10 (C descriptor) buffer (**data\_out\_buf**) and 3
	# type-9 (X descriptor) buffers (**data\_in\_buf**, **exp\_in\_buf** and
	# **mod\_in\_buf**).
	# 
	# Performs asymmetric crypto with user supplied modulus and exponent.
	# 
	@undocumented
	[1] UserExpMod(buffer<unknown,9>, buffer<unknown,9>, buffer<unknown,9>) -> buffer<unknown,0xa>;
	# Wrapper for [GenerateAesKek
	# SMC](http://switchbrew.org/index.php?title=SMC#GenerateAesKek "wikilink").
	# 
	# Takes a 16-byte EKS (**Encryption Key Source**) and two words
	# (**KeyGeneration** and **option**) as input.
	# 
	# Returns a scrambled sealed KEK (**Key Encryption Key** used as
	# **key\_x**).
	# 
	@undocumented
	[2] GenerateAesKek(unknown<0x18>) -> unknown<0x10>;
	# Wrapper for [LoadAesKey
	# SMC](http://switchbrew.org/index.php?title=SMC#LoadAesKey "wikilink").
	# 
	# Takes a u32 (**keyslot**) and two 16-byte keys (**key\_x** and
	# **key\_y**).
	# 
	# Sets the specified **keyslot** with a key generated from **key\_x** and
	# **key\_y**.
	# 
	# \[2.0.0+\] Now verifies that the engine in use (0..3) is locked/owned by
	# the current spl session, otherwise errors with 0xD21A. Previously engine
	# was hardcoded to 0.
	# 
	@undocumented
	[3] LoadAesKey(unknown<0x24>);
	# Takes a 16-byte KEK (**key\_x**) and a 16-byte encrypted key
	# (**enc\_key**).
	# 
	# Generates a new key by decrypting (AES-ECB) **enc\_key** with a key
	# generated from the supplied **key\_x** and a fixed **key\_y** set with
	# [LoadAesKey
	# SMC](http://switchbrew.org/index.php?title=SMC#LoadAesKey "wikilink").
	# 
	# \[2.0.0+\] Previously, it always used engine 0. Now it tries to allocate
	# an engine to be used and returns 0xD01A if they're all busy. When the
	# command is done, the engine is released.
	# 
	@undocumented
	[4] GenerateAesKey(unknown<0x20>) -> unknown<0x10>;
	# Wrapper for [SetConfig
	# SMC](http://switchbrew.org/index.php?title=SMC#SetConfig "wikilink").
	# 
	# Takes a u32 (**ConfigItem**) and a u64 (**ConfigVal**).
	# 
	# | ConfigItem | Name           |
	# | ---------- | -------------- |
	# | 13         | BatteryProfile |
	# 
	# Any other **ConfigItem**, besides 13, can't be set.
	# 
	@undocumented
	[5] SetConfig(unknown<0x10>);
	# Takes a type-6 buffer and fills it with random data from [GetRandomBytes
	# SMC](http://switchbrew.org/index.php?title=SMC#GetRandomBytes "wikilink").
	# Same command for "spl:" and "csrng" services.
	# 
	@undocumented
	[7] GetRandomBytes() -> buffer<unknown,0xa>;
	# Wrapper for [LoadSecureExpModKey
	# SMC](http://switchbrew.org/index.php?title=SMC#LoadSecureExpModKey "wikilink").
	# 
	# Takes one type-9 (X descriptor) buffer (**enc\_privk\_in\_buf**), a
	# 16-byte KEK (**key\_x**), a 16-byte key (**key\_y**) and a u32
	# (**version**). **version** is 0 for normal keys or 1 for extended keys.
	# 
	# Decrypts **enc\_privk\_in\_buf** with a key generated from **key\_x**
	# and **key\_y** and imports it for later usage.
	# 
	# \[5.0.0+\] This now calls [EncryptRsaKeyForImport
	# SMC](http://switchbrew.org/index.php?title=SMC#EncryptRsaKeyForImport "wikilink")
	# instead.
	# 
	@undocumented
	[9] LoadSecureExpModKey(unknown<0x24>, buffer<unknown,9>);
	# Takes 3 type-9 (X descriptor) buffers (**data\_in\_buf**,
	# **mod\_in\_buf** and **param0\_in\_buf**).
	# 
	# Uses [SecureExpMod
	# SMC](http://switchbrew.org/index.php?title=SMC#SecureExpMod "wikilink")
	# to decrypt **data\_in\_buf** using the private key imported with
	# [\#LoadSecureExpModKey](#nn::spl::detail::IGeneralInterface\(9\) "wikilink")
	# and the supplied **mod\_in\_buf** and **param0\_in\_buf**.
	# 
	# Generates and returns a 16-byte sealed titlekey.
	# 
	@undocumented
	[10] SecureExpMod(buffer<unknown,9>, buffer<unknown,9>, buffer<unknown,9>) -> (unknown<4>, buffer<unknown,0xa>);
	# No input params.
	# 
	# Uses [\#GetConfig](#nn::spl::detail::IGeneralInterface\(0\) "wikilink")
	# internally with id=6. Returns true if output from that is 0, or if the
	# SMC returned error 2.
	# 
	# Returns an u8 flag for whether the system is devunit. Output flag is 0
	# on retail.
	# 
	@undocumented
	[11] IsDevelopment() -> unknown<1>;
	# Wrapper for [GenerateSpecificAesKey
	# SMC](http://switchbrew.org/index.php?title=SMC#GenerateSpecificAesKey "wikilink").
	# 
	# Takes a 16-byte seed (**key\_seed**) and two words (**KeyGeneration**
	# and **option**) as input.
	# 
	# Returns a scrambled key (**key\_a**).
	# 
	@undocumented
	[12] GenerateSpecificAesKey(unknown<0x18>) -> unknown<0x10>;
	# Wrapper for [DecryptRsaPrivateKey
	# SMC](http://switchbrew.org/index.php?title=SMC#DecryptRsaPrivateKey "wikilink").
	# 
	# Takes one type-10 (C descriptor) buffer (**dec\_privk\_out\_buf**), one
	# type-9 (X descriptor) buffer (**enc\_privk\_in\_buf**), a 16-byte KEK
	# (**key\_x**), a 16-byte key (**key\_y**) and a u32 (**version**).
	# **version** is 0 for normal keys or 1 for extended keys.
	# 
	# Decrypts **enc\_privk\_in\_buf** into **dec\_privk\_out\_buf** with a
	# key generated from **key\_x** and **key\_y**.
	# 
	# Used by
	# [SSL](http://switchbrew.org/index.php?title=SSL_services "wikilink")-sysmodule
	# for TLS client-privk.
	# 
	# \[5.0.0+\] This now calls [DecryptOrImportRsaKey
	# SMC](http://switchbrew.org/index.php?title=SMC#DecryptOrImportRsaKey "wikilink")
	# instead.
	# 
	@undocumented
	[13] DecryptRsaPrivateKey(unknown<0x24>, buffer<unknown,9>) -> buffer<unknown,0xa>;
	# Takes a 16-byte encrypted key (**enc\_key**) and two words
	# (**KeyGeneration** and **option**) as input.
	# 
	# Decrypts (AES-ECB) **enc\_key** with a key generated from fixed
	# **key\_x** and **key\_y** set with [LoadAesKey
	# SMC](http://switchbrew.org/index.php?title=SMC#LoadAesKey "wikilink")
	# and returns a 16-byte decrypted key (**dec\_key**).
	# 
	# \[2.0.0+\] Introduced same engine allocation code as for
	# [\#GenerateAesKey](#nn::spl::detail::IGeneralInterface\(4\) "wikilink").
	# 
	@undocumented
	[14] DecryptAesKey(unknown<0x18>) -> unknown<0x10>;
	# Takes a type-0x46 (B descriptor) buffer (**data\_out\_buf**), a u32
	# (**keyslot**), a type-0x45 (A descriptor) buffer (**data\_in\_buf**) and
	# a 16-byte CTR (**aes\_ctr**).
	# 
	# Uses [CryptAes
	# SMC](http://switchbrew.org/index.php?title=SMC#CryptAes "wikilink") to
	# decrypt **data\_in\_buf** into **data\_out\_buf**, using the key set in
	# the specified **keyslot**.
	# 
	# \[2.0.0+\] Verifies the engine is locked by current session.
	# 
	@undocumented
	[15] DecryptAesCtr(unknown<0x14>, buffer<unknown,0x45>) -> buffer<unknown,0x46>;
	# Wrapper for [ComputeCmac
	# SMC](http://switchbrew.org/index.php?title=SMC#ComputeCmac "wikilink").
	# 
	# Takes one type-9 (X descriptor) buffer (**data\_in\_buf**) and a u32
	# (**type?**).
	# 
	# Returns a 16-byte CMAC calculated over **data\_in\_buf**.
	# 
	# \[2.0.0+\] Verifies the engine is locked by current session.
	# 
	@undocumented
	[16] ComputeCmac(unknown<4>, buffer<unknown,9>) -> unknown<0x10>;
	# Wrapper for [LoadRsaOaepKey
	# SMC](http://switchbrew.org/index.php?title=SMC#LoadRsaOaepKey "wikilink").
	# 
	# Takes one type-9 (X descriptor) buffer (enc\_privk\_in\_buf), a 16-byte
	# KEK (key\_x), a 16-byte key (key\_y) and a u32 (version). version is 0
	# for normal keys or 1 for extended keys.
	# 
	# Decrypts enc\_privk\_in\_buf with a key generated from key\_x and key\_y
	# and imports it for later usage.
	# 
	@undocumented
	[17] LoadRsaOaepKey(unknown<0x24>, buffer<unknown,9>);
	# Wrapper for [UnwrapRsaOaepWrappedTitleKey
	# SMC](http://switchbrew.org/index.php?title=SMC#UnwrapRsaOaepWrappedTitleKey "wikilink").
	# 
	# Takes one type-10 (C descriptor) buffer (**data\_out\_buf**) and 3
	# type-9 (X descriptor) buffers (**data\_in\_buf**, **mod\_in\_buf** and
	# **label\_hash\_in\_buf**).
	# 
	# Decrypts **data\_in\_buf** into **data\_out\_buf** using the private key
	# imported with
	# [\#LoadRsaOaepKey](#nn::spl::detail::IGeneralInterface\(17\) "wikilink")
	# and the supplied **mod\_in\_buf**. Afterwards, verifies RSA-OAEP
	# encoding using **label\_hash\_in\_buf**.
	# 
	# Returns an u32 (**dec\_data\_size**).
	# 
	@undocumented
	[18] UnwrapRsaOaepWrappedTitleKey(unknown<4>, buffer<unknown,9>, buffer<unknown,9>, buffer<unknown,9>) -> unknown<0x10>;
	# Wrapper for [LoadTitleKey
	# SMC](http://switchbrew.org/index.php?title=SMC#LoadTitleKey "wikilink").
	# 
	# Takes a u32 (**keyslot**) and a 16-byte sealed titlekey.
	# 
	# Sets the specified **keyslot** with the titlekey.
	# 
	# \[2.0.0+\] Verifies the engine is locked by current session.
	# 
	@undocumented
	[19] LoadTitleKey(unknown<0x14>);
	# Wrapper for [UnwrapAesWrappedTitleKey
	# SMC](http://switchbrew.org/index.php?title=SMC#UnwrapAesWrappedTitleKey "wikilink").
	# 
	# Takes a 16-byte EKS (**Encryption Key Source**).
	# 
	# Returns a sealed titlekey.
	# 
	@version(2.0.0+)
	@undocumented
	[20] UnwrapAesWrappedTitleKey(unknown<0x14>) -> unknown<0x10>;
	# Returns the id of the engine that was locked, or 0xD01A if all engines
	# are busy. You need to lock an engine before using AES functions.
	# 
	@version(2.0.0+)
	@undocumented
	[21] LockAesEngine() -> unknown<4>;
	# Takes a single u32 and unlocks the engine with that id. It must be owned
	# by current session otherwise 0xD21A will be returned.
	# 
	@version(2.0.0+)
	@undocumented
	[22] UnlockAesEngine(unknown<4>);
	# Returns an event handle for synchronizing with the locked AES engine.
	# 
	@version(2.0.0+)
	@undocumented
	[23] GetSplWaitEvent() -> handle<copy>;
	# Sets a static dword in spl .bss to the user input u32.
	# 
	# \[4.0.0+\] returns 0xD41A if a value has been previously set without
	# being [gotten](#nn::spl::detail::IGeneralInterface\(25\) "wikilink").
	# 
	@version(3.0.0+)
	@undocumented
	[24] SetSharedData(unknown<4>);
	# Returns the static dword in spl .bss that can be set via
	# [\#SetSharedData](#nn::spl::detail::IGeneralInterface\(24\) "wikilink").
	# 
	# \[4.0.0+\] returns 0xD61A if a value has not previously been set, and
	# unsets the value after getting
	# it.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(3.0.0+)
	@undocumented
	[25] GetSharedData() -> unknown<4>;
	@version(5.0.0+)
	@undocumented
	[26] ImportSslRsaKey(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[27] SecureExpModWithSslKey(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[28] ImportEsRsaKey(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[29] SecureExpModWithEsKey(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[30] EncryptManuRsaKeyForImport(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[31] GetPackage2Hash(unknown) -> unknown;
}

interface nn::spl::detail::IRandomInterface is csrng {
	# Takes a type-6 buffer and fills it with random data from [GetRandomBytes
	# SMC](http://switchbrew.org/index.php?title=SMC#GetRandomBytes "wikilink").
	# Same command for "spl:" and "csrng" services.
	# 
	[0] GetRandomBytes() -> buffer<unknown,6>;
}

interface nn::spsm::detail::IPowerStateInterface is spsm {
	@undocumented
	[0] GetState() -> unknown<4>;
	@undocumented
	[1] SleepSystemAndWaitAwake() -> handle<copy>;
	@undocumented
	[2] Unknown2() -> unknown<4>;
	@undocumented
	[3] Unknown3(unknown<1>);
	@undocumented
	[4] GetNotificationMessageEventHandle() -> handle<copy>;
	@undocumented
	[5] Unknown5() -> unknown<4>;
	@undocumented
	[6] Unknown6() -> unknown<0x50>;
	@undocumented
	[7] Unknown7();
	@undocumented
	[8] AnalyzePerformanceLogForLastSleepWakeSequence() -> buffer<unknown,6>;
	@undocumented
	[9] ChangeHomeButtonLongPressingTime(unknown<8>);
	@undocumented
	[10] Unknown10();
	@version(1.0.0-3.0.2)
	@undocumented
	[11] Unknown11(unknown<8>);
}

interface nn::srepo::detail::ipc::ISrepoService is srepo:u, srepo:a {
	@undocumented
	[0] Unknown0(unknown) -> unknown;
	@undocumented
	[1] Unknown1(unknown) -> unknown;
	@undocumented
	[2] Unknown2(unknown) -> unknown;
}

interface nn::ssl::sf::ISslConnection {
	[0] SetSocketDescriptor(u32) -> u32;
	[1] SetHostName(buffer<bytes,5>);
	[2] SetVerifyOption(nn::ssl::sf::VerifyOption);
	[3] SetIoMode(nn::ssl::sf::IoMode);
	[4] GetSocketDescriptor() -> u32;
	[5] GetHostName() -> (u32, buffer<bytes,6>);
	[6] GetVerifyOption() -> nn::ssl::sf::VerifyOption;
	[7] GetIoMode() -> nn::ssl::sf::IoMode;
	[8] DoHandshake();
	[9] DoHandshakeGetServerCert() -> (u32, u32, buffer<bytes,6>);
	[10] Read() -> (u32, buffer<bytes,6>);
	[11] Write(buffer<bytes,5>) -> u32;
	[12] Pending() -> u32;
	[13] Peek() -> (u32, buffer<bytes,6>);
	[14] Poll(nn::ssl::sf::PollEvent, u32) -> nn::ssl::sf::PollEvent;
	[15] GetVerifyCertError();
	[16] GetNeededServerCertBufferSize() -> u32;
	[17] SetSessionCacheMode(nn::ssl::sf::SessionCacheMode);
	[18] GetSessionCacheMode() -> nn::ssl::sf::SessionCacheMode;
	[19] FlushSessionCache();
	[20] SetRenegotiationMode(nn::ssl::sf::RenegotiationMode);
	[21] GetRenegotiationMode() -> nn::ssl::sf::RenegotiationMode;
	[22] SetOption(b8, nn::ssl::sf::OptionType);
	[23] GetOption(nn::ssl::sf::OptionType) -> b8;
	[24] GetVerifyCertErrors() -> (u32, u32, buffer<bytes,6>);
	@version(4.0.0+)
	[25] GetCipherInfo(u32) -> buffer<bytes,6>;
}

interface nn::ssl::sf::ISslContext {
	[0] SetOption(nn::ssl::sf::ContextOption, u32);
	[1] GetOption(nn::ssl::sf::ContextOption) -> u32;
	[2] CreateConnection() -> object<nn::ssl::sf::ISslConnection>;
	[3] GetConnectionCount() -> u32;
	[4] ImportServerPki(nn::ssl::sf::CertificateFormat, buffer<bytes,5>) -> u64;
	[5] ImportClientPki(buffer<bytes,5>, buffer<bytes,5>) -> u64;
	[6] RemoveServerPki(u64);
	[7] RemoveClientPki(u64);
	[8] RegisterInternalPki(nn::ssl::sf::InternalPki) -> u64;
	[9] AddPolicyOid(buffer<bytes,5>);
	[10] ImportCrl(buffer<bytes,5>) -> u64;
	[11] RemoveCrl(u64);
}

interface nn::ssl::sf::ISslService is ssl {
	[0] CreateContext(nn::ssl::sf::SslVersion, u64, pid) -> object<nn::ssl::sf::ISslContext>;
	[1] GetContextCount() -> u32;
	[2] GetCertificates(buffer<bytes,5>) -> (u32, buffer<bytes,6>);
	[3] GetCertificateBufSize(buffer<bytes,5>) -> u32;
	[4] DebugIoctl(u64, buffer<bytes,5>) -> buffer<bytes,6>;
	[5] SetInterfaceVersion(u32);
	@version(5.0.0+)
	@undocumented
	[6] FlushSessionCache(unknown) -> unknown;
}

interface nn::tc::IManager is tc {
	@undocumented
	[0] SetOperatingMode(unknown<4>);
	@undocumented
	[1] GetThermalEvent(unknown<4>) -> handle<copy>;
	@undocumented
	[2] Unknown2(unknown<4>) -> unknown<1>;
	@undocumented
	[3] Unknown3(unknown<4>);
	@undocumented
	[4] Unknown4(unknown<4>);
	@undocumented
	[5] Unknown5(unknown<8>);
	@undocumented
	[6] Unknown6();
	@undocumented
	[7] Unknown7();
	@undocumented
	[8] Unknown8() -> unknown<1>;
}

interface nn::timesrv::detail::service::IStaticService is time:u, time:a, time:s {
	[0] GetStandardUserSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	[1] GetStandardNetworkSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	[2] GetStandardSteadyClock() -> object<nn::timesrv::detail::service::ISteadyClock>;
	[3] GetTimeZoneService() -> object<nn::timesrv::detail::service::ITimeZoneService>;
	[4] GetStandardLocalSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	@version(4.0.0+)
	[5] GetEphemeralNetworkSystemClock() -> object<nn::timesrv::detail::service::ISystemClock>;
	@version(4.0.0+)
	[50] SetStandardSteadyClockInternalOffset(nn::TimeSpanType);
	[100] IsStandardUserSystemClockAutomaticCorrectionEnabled() -> b8;
	[101] SetStandardUserSystemClockAutomaticCorrectionEnabled(b8);
	@version(5.0.0+)
	@undocumented
	[102] GetStandardUserSystemClockInitialYear(unknown) -> unknown;
	@version(3.0.0+)
	[200] IsStandardNetworkSystemClockAccuracySufficient() -> b8;
	@version(4.0.0+)
	[300] CalculateMonotonicSystemClockBaseTimePoint(nn::time::SystemClockContext) -> u64;
	@version(4.0.0+)
	[400] GetClockSnapshot(u8) -> buffer<nn::time::sf::ClockSnapshot,0x1a>;
	@version(4.0.0+)
	[401] GetClockSnapshotFromSystemClockContext(u8, nn::time::SystemClockContext, nn::time::SystemClockContext) -> buffer<nn::time::sf::ClockSnapshot,0x1a>;
	@version(4.0.0+)
	[500] CalculateStandardUserSystemClockDifferenceByUser(buffer<nn::time::sf::ClockSnapshot,0x19>, buffer<nn::time::sf::ClockSnapshot,0x19>) -> nn::TimeSpanType;
	@version(4.0.0+)
	[501] CalculateSpanBetween(buffer<nn::time::sf::ClockSnapshot,0x19>, buffer<nn::time::sf::ClockSnapshot,0x19>) -> nn::TimeSpanType;
}

interface nn::timesrv::detail::service::ISteadyClock {
	[0] GetCurrentTimePoint() -> nn::time::SteadyClockTimePoint;
	[2] GetTestOffset() -> nn::TimeSpanType;
	[3] SetTestOffset(nn::TimeSpanType);
	@version(2.0.0+)
	[100] GetRtcValue() -> u64;
	@version(2.0.0+)
	[101] IsRtcResetDetected() -> b8;
	@version(2.0.0+)
	[102] GetSetupResultValue() -> u32;
	@version(3.0.0+)
	[200] GetInternalOffset() -> nn::TimeSpanType;
	@version(3.0.0-3.0.2)
	[201] SetInternalOffset(nn::TimeSpanType);
}

interface nn::timesrv::detail::service::ISystemClock {
	[0] GetCurrentTime() -> nn::time::PosixTime;
	[1] SetCurrentTime(nn::time::PosixTime);
	[2] GetSystemClockContext() -> nn::time::SystemClockContext;
	[3] SetSystemClockContext(nn::time::SystemClockContext);
}

interface nn::timesrv::detail::service::ITimeZoneService {
	[0] GetDeviceLocationName() -> nn::time::LocationName;
	[1] SetDeviceLocationName(nn::time::LocationName);
	[2] GetTotalLocationNameCount() -> u32;
	[3] LoadLocationNameList(u32) -> (u32, buffer<nn::time::LocationName,6>);
	[4] LoadTimeZoneRule(nn::time::LocationName) -> buffer<nn::time::TimeZoneRule,0x16>;
	@version(2.0.0+)
	[5] GetTimeZoneRuleVersion() -> nn::time::TimeZoneRuleVersion;
	[100] ToCalendarTime(nn::time::PosixTime, buffer<nn::time::TimeZoneRule,0x15>) -> (nn::time::CalendarTime, nn::time::sf::CalendarAdditionalInfo);
	[101] ToCalendarTimeWithMyRule(nn::time::PosixTime) -> (nn::time::CalendarTime, nn::time::sf::CalendarAdditionalInfo);
	[201] ToPosixTime(nn::time::CalendarTime, buffer<nn::time::TimeZoneRule,0x15>) -> (u32, buffer<nn::time::PosixTime,0xa>);
	[202] ToPosixTimeWithMyRule(nn::time::CalendarTime) -> (u32, buffer<nn::time::PosixTime,0xa>);
}

interface nn::tma::IHtcManager is htc {
	[0] GetEnvironmentVariable(buffer<unknown,5>) -> (u32, buffer<unknown,6>);
	[1] GetEnvironmentVariableLength(buffer<unknown,5>) -> u32;
	[2] BindHostConnectionEvent() -> handle<copy>;
	[3] BindHostDisconnectionEvent() -> handle<copy>;
	[4] BindHostConnectionEventForSystem() -> handle<copy>;
	[5] BindHostDisconnectionEventForSystem() -> handle<copy>;
	@version(3.0.0+)
	[6] GetBridgeIpAddress() -> buffer<unknown,6>;
	@version(3.0.0+)
	[7] GetBridgePort() -> buffer<unknown,6>;
	@version(3.0.0+)
	[8] SetUsbDetachedForDebug(u8);
	@version(4.0.0+)
	[9] GetBridgeSubnetMask() -> buffer<unknown,6>;
	@version(4.0.0+)
	[10] GetBridgeMacAddress() -> buffer<unknown,6>;
}

interface nn::tma::IHtcsManager is htcs {
	[0] Unknown0() -> (u32, u32);
	[1] Unknown1(u32) -> (u32, u32);
	[2] Unknown2(bytes<0x42,2>, u32) -> (u32, u32);
	[3] Unknown3(bytes<0x42,2>, u32) -> (u32, u32);
	[4] Unknown4(u32, u32) -> (u32, u32);
	[5] Unknown5(u32) -> (bytes<0x42,2>, u32, u32);
	[6] Unknown6(u32, u32) -> (u32, u64, buffer<unknown,6>);
	[7] Unknown7(u32, u32, buffer<unknown,5>) -> (u32, u64);
	[8] Unknown8(u32, u32) -> (u32, u32);
	[9] Unknown9(u32, u32, u32) -> (u32, u32);
	[10] GetPeerNameAny() -> bytes<0x20,1>;
	[11] GetDefaultHostName() -> bytes<0x20,1>;
	[12] CreateSocketOld() -> (u32, object<unknown>);
	[13] CreateSocket(u8) -> (u32, object<unknown>);
	[100] RegisterProcessId(u64, pid);
	[101] MonitorManager(u64, pid);
}

interface nn::tma::ISocket {
	[0] Close() -> (u32, u32);
	[1] Connect(bytes<0x42,2>) -> (u32, u32);
	[2] Bind(bytes<0x42,2>) -> (u32, u32);
	[3] Listen(u32) -> (u32, u32);
	[4] Accept() -> (bytes<0x42,2>, u32, object<unknown>);
	[5] Recv(u32) -> (u32, u64, buffer<unknown,0x22>);
	[6] Send(u32, buffer<unknown,0x21>) -> (u32, u64);
	[7] Shutdown(u32) -> (u32, u32);
	[8] Fcntl(u32, u32) -> (u32, u32);
}

interface nn::ts::server::IMeasurementServer is ts {
	@undocumented
	[0] Unknown0(unknown<1>) -> unknown<8>;
	@undocumented
	[1] Unknown1(unknown<1>) -> unknown<4>;
	@undocumented
	[2] Unknown2(unknown<2>);
	@undocumented
	[3] Unknown3(unknown<1>) -> unknown<4>;
}

interface nn::uart::IManager is uart {
	@undocumented
	[0] DoesUartExist(unknown<4>) -> unknown<1>;
	@undocumented
	[1] DoesUartExistForTest(unknown<4>) -> unknown<1>;
	@undocumented
	[2] SetUartBaudrate(unknown<8>) -> unknown<1>;
	@undocumented
	[3] SetUartBaudrateForTest(unknown<8>) -> unknown<1>;
	@undocumented
	[4] IsSomethingUartValid(unknown<8>) -> unknown<1>;
	@undocumented
	[5] IsSomethingUartValidForTest(unknown<8>) -> unknown<1>;
	@undocumented
	[6] GetSession() -> object<nn::uart::IPortSession>;
	@undocumented
	[7] IsSomethingUartValid2(unknown<8>) -> unknown<1>;
	@undocumented
	[8] IsSomethingUartValid2ForTest(unknown<8>) -> unknown<1>;
}

interface nn::uart::IPortSession {
	@undocumented
	[0] OpenSession(unknown<0x20>, handle<copy>, handle<copy>) -> unknown<1>;
	@undocumented
	[1] OpenSessionForTest(unknown<0x20>, handle<copy>, handle<copy>) -> unknown<1>;
	@undocumented
	[2] Unknown2() -> unknown<8>;
	@undocumented
	[3] Unknown3(buffer<unknown,0x21>) -> unknown<8>;
	@undocumented
	[4] Unknown4() -> unknown<8>;
	@undocumented
	[5] Unknown5() -> (unknown<8>, buffer<unknown,0x22>);
	@undocumented
	[6] Unknown6(unknown<0x10>) -> (unknown<1>, handle<copy>);
	@undocumented
	[7] Unknown7(unknown<4>) -> unknown<1>;
}

interface nn::usb::ds::IDsEndpoint {
	# Takes an u32 (**size**) and an u64 (**buffer**). Returns an output u32
	# (**urbId**). The output urbId can then be used while parsing the output
	# of [\#GetReportData](#nn::usb::ds::IDsEndpoint\(3\) "wikilink"), after
	# waiting for the CompletionEvent to be signalled.
	# 
	# The buffer address must be 0x1000-byte aligned. The input size doesn't
	# matter. It helps to use svcSetMemoryAttribute to turn off caching on the
	# buffer.
	# 
	# Used for data-transfer with input/output endpoints.
	# 
	# The user-process must flush dcache for the buffer before using this
	# command.
	# 
	# When sending data where size is larger than wMaxPacketSize, it will
	# automatically send multiple USB packets where last packet size =
	# {remaining size}. Every {wMaxPacketSize}-bytes is a different packet.
	# This only occurs in some cases. When **size** is \~0x1000000(exact size
	# unknown), Switch-side silently hangs, while host-side will timeout(no
	# traffic on USB bus indicating failure).
	# 
	# For receiving data, if size is less than {actual received USB packet
	# size} the rest of the packet will be discarded. Later PostBufferAsync
	# cmd(s) will only return data from new packets, not the remainder of the
	# earlier packet(s).
	# 
	@undocumented
	[0] PostBufferAsync(unknown<0x10>) -> unknown<4>;
	@undocumented
	[1] Unknown1();
	# No input. Returns an output event handle for polling the completion of
	# [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint\(0\) "wikilink"), even
	# when it finished via
	# [\#Stall](#nn::usb::ds::IDsEndpoint\(4\) "wikilink").
	# 
	@undocumented
	[2] GetCompletionEvent() -> handle<copy>;
	# No input. Returns 0x84 bytes of report data from the endpoint. Seems to
	# be eventually loaded from state, since this doesn't trigger any USB bus
	# activity. All-zero before PostBufferAsync was used at least
	# once.
	# 
	# | Offset | Size            | Description                                  |
	# | ------ | --------------- | -------------------------------------------- |
	# | 0x0    | 0x10\*0x8(0x80) | 0x8 entries 0x10-bytes each for each report. |
	# | 0x80   | 0x4             | u32 report count                             |
	# 
	# Entry
	# data:
	# 
	# | Offset | Size | Description                                                                                                        |
	# | ------ | ---- | ------------------------------------------------------------------------------------------------------------------ |
	# | 0x0    | 0x4  | u32 id (urbId from post-buffer commands)                                                                           |
	# | 0x4    | 0x4  | u32 requestedSize                                                                                                  |
	# | 0x8    | 0x4  | u32 transferredSize                                                                                                |
	# | 0xC    | 0x4  | u32 urb status, converted to error-codes. 0x3 = success, 0x4 = 0x828c, 0x5 = 0x748c. All other values are invalid. |
	# |        |      |                                                                                                                    |
	# 
	@undocumented
	[3] GetReportData() -> unknown<0x84>;
	# No input/output.
	# 
	# Calls the same function used by
	# [\#StallCtrl](#nn::usb::ds::IDsInterface\(11\) "wikilink"), except this
	# uses the endpoint associated with the current session.
	# 
	# Stops in-progress data-transfer done by
	# [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint\(0\) "wikilink").
	# 
	@undocumented
	[4] Stall();
	@undocumented
	[5] Unknown5(unknown<1>);
}

interface nn::usb::ds::IDsInterface {
	# Takes a type-5 buffer and returns an
	# [\#IDsEndpoint](#nn::usb::ds::IDsEndpoint "wikilink").
	# [Manu](http://switchbrew.org/index.php?title=Manu_Services "wikilink")
	# uses this twice for getting two endpoint sessions, with the following
	# 0x7-byte buffer data:
	# 
	#   - First endpoint: 0x07, 0x05, 0x80, 0x02, 0x00, 0x02, 0x00
	#       - bLength=0x7
	#       - bDescriptorType=LIBUSB\_DT\_ENDPOINT
	#       - bEndpointAddress=LIBUSB\_ENDPOINT\_IN
	#       - bmAttributes=LIBUSB\_TRANSFER\_TYPE\_BULK
	#       - wMaxPacketSize=0x200
	#       - bInterval=0
	#   - Second endpoint: Same as above except byte2 is
	#     0x00(bEndpointAddress=LIBUSB\_ENDPOINT\_OUT).
	# 
	# Each field is an u8, except for offset 0x4-0x5 which is an u16.
	# 
	# This structure matches
	# [libusb\_endpoint\_descriptor](http://switchbrew.org/index.php?title=http://libusb.sourceforge.net/api-1.0/structlibusb__endpoint__descriptor.html),
	# with audio-only-devices fields bRefresh and bSynchAddress removed.
	# 
	# The buffer size must be \>=0x7. Only the first 0x7-bytes from the buffer
	# are used.
	# 
	#   - Byte0(bLength) must match 0x7.
	#   - Byte1(bDescriptorType) must match 0x5.
	#   - Byte2(bEndpointAddress) is only compared with 0x80 to determine
	#     whether to use an input or output endpoint, the actual
	#     endpoint-number is allocated automatically by checking state. Hence,
	#     all input endpoints must use bEndpointAddress==0x80. Up to
	#     endpoint-number 0xF can be allocated for each endpoint-direction,
	#     for a total of 16 endpoints including control, and 15 for
	#     non-control
	#     endpoints([\#IDsEndpoint](#nn::usb::ds::IDsEndpoint "wikilink")
	#     sessions for each direction). This matches the Tegra maximum.
	# 
	# From the Tegra datasheet: "The maximum packet size supported on any
	# endpoint is 1024 bytes in high-speed mode, for both device and host
	# modes."
	# 
	@undocumented
	[0] GetDsEndpoint(buffer<unknown,5>) -> (unknown<1>, object<nn::usb::ds::IDsEndpoint>);
	# Returns an event handle. Unknown what triggers signalling, not signalled
	# during interface-enable / device\<\>host USB-comms init.
	# 
	@undocumented
	[1] GetSetupEvent() -> handle<copy>;
	@undocumented
	[2] Unknown2() -> buffer<unknown,6>;
	# Takes no arguments. Enables the current interface.
	# 
	# Only one interface can be enabled at a time per bInterfaceNumber. When
	# bInterfaceNumber is auto-allocate(0x4) for
	# [\#GetDsEndpoint](#nn::usb::ds::IDsInterface\(0\) "wikilink") this isn't
	# an issue since the final bInterfaceNumber will be unique.
	# 
	# Once enabled, the device/interface can then actually be used over USB.
	# 
	@undocumented
	[3] EnableInterface();
	# Takes no arguments. Disables the current interface.
	# 
	@undocumented
	[4] DisableInterface();
	# Same as
	# [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint\(0\) "wikilink")(with same
	# input/output), except this uses control input endpoint 0x80.
	# 
	@undocumented
	[5] CtrlInPostBufferAsync(unknown<0x10>) -> unknown<4>;
	# Same as
	# [\#PostBufferAsync](#nn::usb::ds::IDsEndpoint\(0\) "wikilink")(with same
	# input/output), except this uses control output endpoint 0x00.
	# 
	@undocumented
	[6] CtrlOutPostBufferAsync(unknown<0x10>) -> unknown<4>;
	# Returns an event handle for polling the completion of input control
	# commands. Same as
	# [\#GetCompletionEvent](#nn::usb::ds::IDsEndpoint\(2\) "wikilink"),
	# except this uses control input endpoint 0x80.
	# 
	@undocumented
	[7] GetCtrlInCompletionEvent() -> handle<copy>;
	# Same as
	# [\#GetReportData](#nn::usb::ds::IDsEndpoint\(3\) "wikilink")(with same
	# input/output), except this uses control input endpoint 0x80.
	# 
	@undocumented
	[8] GetCtrlInReportData() -> unknown<0x84>;
	# Returns an event handle for polling the completion of output control
	# commands. Same as
	# [\#GetCompletionEvent](#nn::usb::ds::IDsEndpoint\(2\) "wikilink"),
	# except this uses control output endpoint 0x00.
	# 
	@undocumented
	[9] GetCtrlOutCompletionEvent() -> handle<copy>;
	# Same as
	# [\#GetReportData](#nn::usb::ds::IDsEndpoint\(3\) "wikilink")(with same
	# input/output), except this uses control output endpoint 0x00.
	# 
	@undocumented
	[10] GetCtrlOutReportData() -> unknown<0x84>;
	# No input/output.
	# 
	# Calls a function with both control endpoints(0x80 and 0x00) with the
	# same function. From strings: "m\_pProtocol-\>Stall(0x80)"
	# "m\_pProtocol-\>Stall(0x00)".
	# 
	@undocumented
	[11] StallCtrl();
	@version(5.0.0+)
	@undocumented
	[12] AppendConfigurationData(unknown) -> unknown;
}

interface nn::usb::ds::IDsService is usb:ds {
	# Takes an u32 (**complexId**).
	# [Manu](http://switchbrew.org/index.php?title=Manu_Services "wikilink")
	# sends 0x02.
	# 
	# Binding more than once with the current session is not allowed. Once
	# this command is used, the USB device will not be listed with `lsusb`
	# until [\#EnableInterface](#nn::usb::ds::IDsInterface\(3\) "wikilink") is
	# used.
	# 
	# Returns a not-found error when complexId isn't 0x02, for values 0x0-0x4
	# at least.
	# 
	@undocumented
	[0] BindDevice(unknown<4>);
	# Takes 1 copy-handle for the current process (0xFFFF8001).
	# 
	@undocumented
	[1] BindClientProcess(handle<copy>);
	# Takes 2 type-5 buffers and returns an
	# [\#IDsInterface](#nn::usb::ds::IDsInterface "wikilink").
	# [Manu](http://switchbrew.org/index.php?title=Manu_Services "wikilink")
	# sends a 0x09-byte command (e.g.: 0x09, 0x04, 0x04, 0x00, 0x00, 0xFF,
	# 0xFF, 0xFF, 0x00) in the first buffer and a string ("usb") in the second
	# buffer.
	# 
	# When the strlen output for the second buffer is \>=0x40, size 0x40 is
	# used instead for copying the string. This is the interface name, it's
	# not sent over USB.
	# 
	# Returns an error when
	# [\#BindDevice](#nn::usb::ds::IDsService\(0\) "wikilink") wasn't used.
	# 
	# Up to 4 interfaces can be
	# used+[enabled](#nn::usb::ds::IDsInterface\(3\) "wikilink").
	# 
	# Structure of the first buffer(this is the same as
	# [libusb\_\_interface\_\_descriptor](http://switchbrew.org/index.php?title=http://libusb.sourceforge.net/api-1.0/structlibusb__interface__descriptor.html)):
	# 
	# | Offset | Size | Description                                                                                                                                                    |
	# | ------ | ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
	# | 0x0    | 0x1  | bLength. Must match 0x9.                                                                                                                                       |
	# | 0x1    | 0x1  | bDescriptorType. Must match 0x4.                                                                                                                               |
	# | 0x2    | 0x1  | bInterfaceNumber. When 0x4, the bInterfaceNumber is automatically allocated(error will be thrown if no space). Otherwise, it's used directly and must be \<=3. |
	# | 0x3    | 0x1  | bAlternateSetting. Must match 0x0.                                                                                                                             |
	# | 0x4    | 0x1  | bNumEndpoints. Ignored.                                                                                                                                        |
	# | 0x5    | 0x1  | bInterfaceClass                                                                                                                                                |
	# | 0x6    | 0x1  | bInterfaceSubClass                                                                                                                                             |
	# | 0x7    | 0x1  | bInterfaceProtocol                                                                                                                                             |
	# | 0x8    | 0x1  | iInterface. Ignored.                                                                                                                                           |
	# 
	# Only the first 0x9-bytes are used.
	# 
	@undocumented
	[2] GetDsInterface(buffer<unknown,5>, buffer<unknown,5>) -> (unknown<1>, object<nn::usb::ds::IDsInterface>);
	# Returns an event handle for when the state returned by
	# [\#GetState](#nn::usb::ds::IDsService\(4\) "wikilink") changes.
	# Signalled when Switch\<-\>host USB comms change between started/stopped.
	# USB cable connected/disconnected while at least 1 interface was enabled,
	# or interface enabled/disabled while the USB cable was connected which
	# then caused USB-comms state to change.
	# 
	@undocumented
	[3] GetStateChangeEvent() -> handle<copy>;
	# No input. Returns an output u32. Returns an error when
	# [\#BindDevice](#nn::usb::ds::IDsService\(0\) "wikilink") wasn't used.
	# 
	# Returns the current state. Values:
	# 
	#   - 0: Initial state.
	#   - 6: Device init starting.
	#   - 3: {Initialization}, previous state is 6.
	#   - 4: {Initialization}, previous state is 3.
	#   - 5: Initialization done, data-transfer is now available.
	# 
	@undocumented
	[4] GetState() -> unknown<4>;
	# Takes a type-5 buffer with 0x66 bytes of USB descriptor data (see
	# [manu](http://switchbrew.org/index.php?title=Manu_Services#manu "wikilink")).
	# 
	# | Offset | Size | Description     |
	# | ------ | ---- | --------------- |
	# | 0x0    | 0x2  | VID (idVendor)  |
	# | 0x2    | 0x2  | PID (idProduct) |
	# | 0x4    | 0x2  | bcdDevice       |
	# | 0x6    | 0x20 | Manufacturer    |
	# | 0x26   | 0x20 | Product         |
	# | 0x46   | 0x20 | SerialNumber    |
	# 
	# The last 3 blocks are ASCII strings. The data following each string is
	# all-zero, for padding to size 0x20.
	# 
	@version(2.0.0-4.1.0)
	@undocumented
	[5] SetVidPidBcd(buffer<unknown,5>);
	@version(5.0.0+)
	@undocumented
	[5] ClearDeviceData(buffer<unknown,5>);
	@version(5.0.0+)
	@undocumented
	[6] AddUsbStringDescriptor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[7] DeleteUsbStringDescriptor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[8] SetUsbDeviceDescriptor(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[9] SetBinaryObjectStore(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[10] Enable(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[11] Disable(unknown) -> unknown;
}

interface nn::usb::hs::IClientEpSession {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2() -> handle<copy>;
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] PostBufferAsync(unknown<0x18>) -> unknown<4>;
	@undocumented
	[5] Unknown5(unknown<4>) -> (unknown<4>, buffer<unknown,0x22>);
	@undocumented
	[6] Unknown6(unknown<0x20>, buffer<unknown,0x21>) -> unknown<4>;
	@version(4.0.0+)
	@undocumented
	[7] Unknown7(unknown<0x10>);
	@version(4.0.0+)
	@undocumented
	[8] Unknown8(unknown<4>, handle<copy>);
}

interface nn::usb::hs::IClientIfSession {
	@undocumented
	[0] Unknown0() -> handle<copy>;
	@undocumented
	[1] Unknown1(unknown<1>) -> buffer<unknown,6>;
	@undocumented
	[2] Unknown2() -> buffer<unknown,6>;
	@undocumented
	[3] Unknown3(unknown<1>) -> buffer<unknown,6>;
	@undocumented
	[4] Unknown4() -> unknown<4>;
	@undocumented
	[5] CtrlXferAsync(unknown<0x10>);
	@undocumented
	[6] Unknown6() -> handle<copy>;
	@undocumented
	[7] GetCtrlXferReport() -> buffer<unknown,6>;
	@undocumented
	[8] Unknown8();
	@undocumented
	[9] GetClientEpSession(unknown<0x14>) -> (unknown<7>, object<nn::usb::hs::IClientEpSession>);
}

interface nn::usb::hs::IClientRootSession is usb:hs {
	@undocumented
	[0] BindClientProcess(handle<copy>);
	@undocumented
	[1] Unknown1(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[2] Unknown2(unknown<0x10>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[3] Unknown3() -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[4] Unknown4(unknown<0x12>) -> handle<copy>;
	@undocumented
	[5] Unknown5(unknown<1>);
	@undocumented
	[6] GetInterfaceStateChangeEvent() -> handle<copy>;
	@undocumented
	[7] GetClientIfSession(unknown<4>) -> (buffer<unknown,6>, buffer<unknown,6>, object<nn::usb::hs::IClientIfSession>);
}

interface nn::usb::pd::detail::IPdCradleManager is usb:pd:c {
	@undocumented
	[0] GetPdCradleSession() -> object<nn::usb::pd::detail::IPdCradleSession>;
}

interface nn::usb::pd::detail::IPdCradleSession {
	@undocumented
	[0] VdmUserWrite(unknown<8>);
	@undocumented
	[1] VdmUserRead(unknown<4>) -> unknown<4>;
	@undocumented
	[2] Vdm20Init();
	@undocumented
	[3] GetFwType() -> unknown<2>;
	@undocumented
	[4] GetFwRevision() -> unknown<2>;
	@undocumented
	[5] GetManufacturerId() -> unknown<2>;
	@undocumented
	[6] GetDeviceId() -> unknown<2>;
	@version(3.0.0+)
	@undocumented
	[7] Unknown7() -> unknown<1>;
	@version(3.0.0+)
	@undocumented
	[8] Unknown8() -> unknown<1>;
}

interface nn::usb::pd::detail::IPdManager is usb:pd {
	@undocumented
	[0] GetPdSession() -> object<nn::usb::pd::detail::IPdSession>;
}

interface nn::usb::pd::detail::IPdSession {
	@undocumented
	[0] BindNoticeEvent() -> handle<copy>;
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] GetStatus() -> unknown<0x14>;
	@undocumented
	[3] GetNotice() -> unknown<4>;
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] ReplyPowerRequest(unknown<1>);
}

interface nn::usb::pm::IPmService is usb:pm {
	@undocumented
	[0] Unknown0() -> handle<copy>;
	@undocumented
	[1] Unknown1() -> buffer<unknown,6>;
	@undocumented
	[2] Unknown2() -> handle<copy>;
	@undocumented
	[3] Unknown3() -> unknown<4>;
	@undocumented
	[4] Unknown4(unknown<8>);
	@undocumented
	[5] Unknown5(unknown<4>) -> unknown<4>;
}

interface nn::visrv::sf::IApplicationDisplayService {
	# Returns an
	# [IHOSBinderDriver](http://switchbrew.org/index.php?title=Nvnflinger_services#dispdrv "wikilink")
	# interface which abstracts
	# "nn::visrv::[service::RelayServiceImpl](http://switchbrew.org/index.php?title=service::RelayServiceImpl)".
	# 
	[100] GetRelayService() -> object<nns::hosbinder::IHOSBinderDriver>;
	# Returns an
	# [\#ISystemDisplayService](#nn::visrv::sf::ISystemDisplayService "wikilink").
	# 
	[101] GetSystemDisplayService() -> object<nn::visrv::sf::ISystemDisplayService>;
	# Returns an
	# [\#IManagerDisplayService](#nn::visrv::sf::IManagerDisplayService "wikilink").
	# 
	[102] GetManagerDisplayService() -> object<nn::visrv::sf::IManagerDisplayService>;
	# Returns an
	# [IHOSBinderDriver](http://switchbrew.org/index.php?title=Nvnflinger_services#dispdrv "wikilink")
	# interface which abstracts
	# "nn::visrv::[service::IndirectDisplayTransactionServiceImpl](http://switchbrew.org/index.php?title=service::IndirectDisplayTransactionServiceImpl)".
	# 
	@version(2.0.0+)
	[103] GetIndirectDisplayTransactionService() -> object<nns::hosbinder::IHOSBinderDriver>;
	# Takes a type-0x6 output buffer containing the array of
	# [\#DisplayInfo](http://switchbrew.org/index.php?title=Display%20services#DisplayInfo "wikilink")
	# output entries. Returns an output u64: total number of output entries.
	# 
	# Normally(?) this only returns the "Default" display.
	# 
	[1000] ListDisplays() -> (u64, buffer<nn::vi::DisplayInfo,6>);
	# Takes a
	# [\#DisplayName](http://switchbrew.org/index.php?title=Display%20services#DisplayName "wikilink")
	# as input. Returns an output u64, the DisplayId.
	# 
	# To open the default display, input string "Default" can be used.
	# 
	[1010] OpenDisplay(nn::vi::DisplayName) -> u64;
	# Returns an output u64.
	# 
	# Probably not (?) used by newer official user-processes, since those use
	# OpenDisplay with the default string instead.
	# 
	[1011] OpenDefaultDisplay() -> u64;
	# Takes an input u64, DisplayId.
	# 
	[1020] CloseDisplay(u64);
	# Takes an input u32 boolean, and an u64(DisplayId?).
	# 
	[1101] SetDisplayEnabled(b8, u64);
	# Takes an input u64 DisplayId and returns two output u64s: width and
	# height.
	# 
	[1102] GetDisplayResolution(u64) -> (u64, u64);
	# Takes a PID-descriptor, a type-0x6 buffer for the output
	# [\#NativeWindow](http://switchbrew.org/index.php?title=Display%20services#NativeWindow "wikilink"),
	# a
	# [\#DisplayName](http://switchbrew.org/index.php?title=Display%20services#DisplayName "wikilink")(which
	# was previously used with
	# [\#OpenDisplay](#nn::visrv::sf::IApplicationDisplayService\(1010\) "wikilink")),
	# an u64 LayerId, and an u64
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns an output u64 NativeWindow\_Size.
	# 
	# Official user-processes use a LayerId stored in a global state
	# field("...ExternalLayerId") if non-zero, otherwise:
	# 
	#   - When AppletResourceUserId==0,
	#     [\#CreateStrayLayer](#nn::visrv::sf::IApplicationDisplayService\(2030\) "wikilink")
	#     is used instead of the OpenLayer cmd.
	#   - When AppletResourceUserId\!=0,
	#     [AM\_services\#CreateManagedDisplayLayer](http://switchbrew.org/index.php?title=AM_services#CreateManagedDisplayLayer "wikilink")
	#     is used and the output from that is used for LayerId with the
	#     OpenLayer cmd.
	# 
	# This OpenLayer command returns error 0x272 when the AppletResourceUserId
	# is invalid.
	# 
	[2020] OpenLayer(nn::vi::DisplayName, u64, nn::applet::AppletResourceUserId, pid) -> (u64, buffer<bytes,6>);
	# Takes an input u64: LayerId which was used with
	# [\#OpenLayer](#nn::visrv::sf::IApplicationDisplayService\(2020\) "wikilink").
	# 
	[2021] CloseLayer(u64);
	# Takes a type-0x6 buffer for the output
	# [\#NativeWindow](http://switchbrew.org/index.php?title=Display%20services#NativeWindow "wikilink"),
	# an u32(LayerFlags bitmask), and an u64 DisplayId. Returns two output
	# u64s: LayerId and NativeWindow\_Size.
	# 
	[2030] CreateStrayLayer(u32, u64) -> (u64, u64, buffer<bytes,6>);
	# Takes an input u64: LayerId from
	# [\#CreateStrayLayer](#nn::visrv::sf::IApplicationDisplayService\(2030\) "wikilink").
	# 
	[2031] DestroyStrayLayer(u64);
	# Takes an input u64("ScalingMode") and u64 ("LayerId").
	# 
	[2101] SetLayerScalingMode(u32, u64);
	@version(5.0.0+)
	@undocumented
	[2102] ConvertScalingMode(unknown) -> unknown;
	# Takes a PID-descriptor, an type-0x46 buffer, and four u64s: width(s32),
	# height(s32), \<output from
	# [AM](http://switchbrew.org/index.php?title=AM_services "wikilink")
	# GetIndirectLayerConsumerHandle\>, and
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink").
	# Returns two output u64s.
	# 
	[2450] GetIndirectLayerImageMap(u64, u64, u64, nn::applet::AppletResourceUserId, pid) -> (u64, u64, buffer<bytes,0x46>);
	# Takes a PID-descriptor, an type-0x46 buffer, four floats, four u64s(last
	# u64 is
	# [AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink")).
	# Returns two output u64s. The floats are stored immediately after each
	# other(32bits).
	# 
	[2451] GetIndirectLayerImageCropMap(f32, f32, f32, f32, u64, u64, u64, nn::applet::AppletResourceUserId, pid) -> (u64, u64, buffer<bytes,0x46>);
	# Takes two input u64s: with and height. Returns two output u64s. First
	# u64 is the buffer size to use with the ImageMap cmds.
	# 
	[2460] GetIndirectLayerImageRequiredMemoryInfo(u64, u64) -> (u64, u64);
	# Takes an input u64 DisplayId and returns a handle.
	# 
	[5202] GetDisplayVsyncEvent(u64) -> handle<copy>;
	# Takes an input u64 DisplayId and returns a handle.
	# 
	[5203] GetDisplayVsyncEventForDebug(u64) -> handle<copy>;
}

interface nn::visrv::sf::IApplicationRootService is vi:u {
	# Returns an
	# [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# Takes an input u32, user-processes use 0 or 1, with 0 for
	# regular-applications normally. 0 = user-service(vi:u), 1 =
	# non-user-service? Returns an error when using value 1 with vi:u(same
	# error listed below for IApplicationDisplayService for unavailable
	# commands).
	# 
	[0] GetDisplayService(u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
}

interface nn::visrv::sf::IManagerDisplayService {
	@version(4.0.0+)
	[200] AllocateProcessHeapBlock(u64) -> u64;
	@version(4.0.0+)
	[201] FreeProcessHeapBlock(u64);
	[1102] GetDisplayResolution(u64) -> (u64, u64);
	[2010] CreateManagedLayer(u32, u64, nn::applet::AppletResourceUserId) -> u64;
	[2011] DestroyManagedLayer(u64);
	[2050] CreateIndirectLayer() -> u64;
	[2051] DestroyIndirectLayer(u64);
	[2052] CreateIndirectProducerEndPoint(u64, nn::applet::AppletResourceUserId) -> u64;
	[2053] DestroyIndirectProducerEndPoint(u64);
	[2054] CreateIndirectConsumerEndPoint(u64, nn::applet::AppletResourceUserId) -> u64;
	[2055] DestroyIndirectConsumerEndPoint(u64);
	[2300] AcquireLayerTexturePresentingEvent(u64) -> handle<copy>;
	[2301] ReleaseLayerTexturePresentingEvent(u64);
	[2302] GetDisplayHotplugEvent(u64) -> handle<copy>;
	[2402] GetDisplayHotplugState(u64) -> u32;
	@version(4.0.0+)
	[2501] GetCompositorErrorInfo(u64, u64) -> (u32, buffer<nn::vi::CompositorError,0x16>);
	@version(4.0.0+)
	[2601] GetDisplayErrorEvent(u64) -> handle<copy>;
	[4201] SetDisplayAlpha(f32, u64);
	[4203] SetDisplayLayerStack(u32, u64);
	[4205] SetDisplayPowerState(u32, u64);
	@version(4.0.0+)
	[4206] SetDefaultDisplay(u64);
	[6000] AddToLayerStack(u32, u64);
	[6001] RemoveFromLayerStack(u32, u64);
	[6002] SetLayerVisibility(b8, u64);
	@version(5.0.0+)
	@undocumented
	[6003] SetLayerConfig(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6004] AttachLayerPresentationTracer(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6005] DetachLayerPresentationTracer(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6006] StartLayerPresentationRecording(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6007] StopLayerPresentationRecording(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6008] StartLayerPresentationFenceWait(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6009] StopLayerPresentationFenceWait(unknown) -> unknown;
	@version(5.0.0+)
	@undocumented
	[6010] GetLayerPresentationAllFencesExpiredEvent(unknown) -> unknown;
	[7000] SetContentVisibility(b8);
	[8000] SetConductorLayer(b8, u64);
	[8100] SetIndirectProducerFlipOffset(u64, u64, nn::TimeSpan);
	@version(4.0.0+)
	[8200] CreateSharedBufferStaticStorage(u64, buffer<nn::vi::fbshare::SharedMemoryPoolLayout,0x15>) -> nn::vi::fbshare::SharedBufferHandle;
	@version(4.0.0+)
	[8201] CreateSharedBufferTransferMemory(u64, handle<copy>, buffer<nn::vi::fbshare::SharedMemoryPoolLayout,0x15>) -> nn::vi::fbshare::SharedBufferHandle;
	@version(4.0.0+)
	[8202] DestroySharedBuffer(nn::vi::fbshare::SharedBufferHandle);
	@version(4.0.0+)
	[8203] BindSharedLowLevelLayerToManagedLayer(nn::vi::DisplayName, u64, nn::applet::AppletResourceUserId, pid);
	@version(4.0.0+)
	[8204] BindSharedLowLevelLayerToIndirectLayer(u64, nn::applet::AppletResourceUserId, pid);
	@version(4.0.0+)
	[8207] UnbindSharedLowLevelLayer(u64);
	@version(4.0.0+)
	[8208] ConnectSharedLowLevelLayerToSharedBuffer(u64, nn::vi::fbshare::SharedBufferHandle);
	@version(4.0.0+)
	[8209] DisconnectSharedLowLevelLayerFromSharedBuffer(u64);
	@version(4.0.0+)
	[8210] CreateSharedLayer(nn::applet::AppletResourceUserId) -> nn::vi::fbshare::SharedLayerHandle;
	@version(4.0.0+)
	[8211] DestroySharedLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8216] AttachSharedLayerToLowLevelLayer(nn::vi::fbshare::SharedLayerTextureIndexList, nn::vi::fbshare::SharedLayerHandle, u64);
	@version(4.0.0+)
	[8217] ForceDetachSharedLayerFromLowLevelLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8218] StartDetachSharedLayerFromLowLevelLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8219] FinishDetachSharedLayerFromLowLevelLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8220] GetSharedLayerDetachReadyEvent(nn::vi::fbshare::SharedLayerHandle) -> handle<copy>;
	@version(4.0.0+)
	[8221] GetSharedLowLevelLayerSynchronizedEvent(u64) -> handle<copy>;
	@version(4.0.0+)
	[8222] CheckSharedLowLevelLayerSynchronized(u64) -> u64;
	@version(4.0.0+)
	[8223] RegisterSharedBufferImporterAruid(nn::vi::fbshare::SharedBufferHandle, nn::applet::AppletResourceUserId);
	@version(4.0.0+)
	[8224] UnregisterSharedBufferImporterAruid(nn::vi::fbshare::SharedBufferHandle, nn::applet::AppletResourceUserId);
	@version(4.0.0+)
	[8227] CreateSharedBufferProcessHeap(u64, buffer<nn::vi::fbshare::SharedMemoryPoolLayout,0x15>) -> nn::vi::fbshare::SharedBufferHandle;
	@version(4.0.0+)
	[8228] GetSharedLayerLayerStacks(nn::vi::fbshare::SharedLayerHandle) -> u32;
	@version(4.0.0+)
	[8229] SetSharedLayerLayerStacks(u32, nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8291] PresentDetachedSharedFrameBufferToLowLevelLayer(nn::vi::fbshare::SharedBufferHandle, u64, u64);
	@version(4.0.0+)
	[8292] FillDetachedSharedFrameBufferColor(u32, u32, u32, u32, u32, nn::vi::fbshare::SharedBufferHandle, u64);
	@version(4.0.0+)
	[8293] GetDetachedSharedFrameBufferImage(nn::vi::fbshare::SharedBufferHandle, u64) -> (u64, buffer<bytes,6>);
	@version(4.0.0+)
	[8294] SetDetachedSharedFrameBufferImage(u32, nn::vi::fbshare::SharedBufferHandle, u64, buffer<bytes,5>);
	@version(4.0.0+)
	[8295] CopyDetachedSharedFrameBufferImage(u32, u32, nn::vi::fbshare::SharedBufferHandle, u64, u64);
	@version(4.0.0+)
	[8296] SetDetachedSharedFrameBufferSubImage(u32, u32, u32, u32, u32, u32, nn::vi::fbshare::SharedBufferHandle, u64, buffer<bytes,5>);
	@version(4.0.0+)
	[8297] GetSharedFrameBufferContentParameter(nn::vi::fbshare::SharedBufferHandle, u64) -> (u32, nn::vi::CropRegion, u32, u32, u32);
	@version(5.0.0+)
	@undocumented
	[8298] ExpandStartupLogoOnSharedFrameBuffer(unknown) -> unknown;
}

interface nn::visrv::sf::IManagerRootService is vi:m {
	# Returns an
	# [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# Takes an input u32, user-processes use 0 or 1, with 0 for
	# regular-applications normally. 0 = user-service(vi:u), 1 =
	# non-user-service? Returns an error when using value 1 with vi:u(same
	# error listed below for IApplicationDisplayService for unavailable
	# commands).
	# 
	[2] GetDisplayService(u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
	# Returns an
	# [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# 
	[3] GetDisplayServiceWithProxyNameExchange(nn::vi::ProxyName, u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
}

interface nn::visrv::sf::ISystemDisplayService {
	[1200] GetZOrderCountMin(u64) -> u64;
	[1202] GetZOrderCountMax(u64) -> u64;
	[1203] GetDisplayLogicalResolution(u64) -> (u32, u32);
	[1204] SetDisplayMagnification(u32, u32, u32, u32, u64);
	[2201] SetLayerPosition(f32, f32, u64);
	[2203] SetLayerSize(u64, u64, u64);
	[2204] GetLayerZ(u64) -> u64;
	[2205] SetLayerZ(u64, u64);
	[2207] SetLayerVisibility(b8, u64);
	[2209] SetLayerAlpha(f32, u64);
	[2312] CreateStrayLayer(u32, u64) -> (u64, u64, buffer<bytes,6>);
	[2400] OpenIndirectLayer(u64, nn::applet::AppletResourceUserId, pid) -> (u64, buffer<bytes,6>);
	[2401] CloseIndirectLayer(u64);
	[2402] FlipIndirectLayer(u64);
	[3000] ListDisplayModes(u64) -> (u64, buffer<nn::vi::DisplayModeInfo,6>);
	[3001] ListDisplayRgbRanges(u64) -> (u64, buffer<u32,6>);
	[3002] ListDisplayContentTypes(u64) -> (u64, buffer<u32,6>);
	[3200] GetDisplayMode(u64) -> nn::vi::DisplayModeInfo;
	[3201] SetDisplayMode(u64, nn::vi::DisplayModeInfo);
	[3202] GetDisplayUnderscan(u64) -> u64;
	[3203] SetDisplayUnderscan(u64, u64);
	[3204] GetDisplayContentType(u64) -> u32;
	[3205] SetDisplayContentType(u32, u64);
	[3206] GetDisplayRgbRange(u64) -> u32;
	[3207] SetDisplayRgbRange(u32, u64);
	[3208] GetDisplayCmuMode(u64) -> u32;
	[3209] SetDisplayCmuMode(u32, u64);
	[3210] GetDisplayContrastRatio(u64) -> f32;
	[3211] SetDisplayContrastRatio(f32, u64);
	[3214] GetDisplayGamma(u64) -> f32;
	[3215] SetDisplayGamma(f32, u64);
	[3216] GetDisplayCmuLuma(u64) -> f32;
	[3217] SetDisplayCmuLuma(f32, u64);
	@version(4.0.0+)
	[8225] GetSharedBufferMemoryHandleId(nn::vi::fbshare::SharedBufferHandle, nn::applet::AppletResourceUserId, pid) -> (nn::vi::native::NativeMemoryHandleId, u64, buffer<nn::vi::fbshare::SharedMemoryPoolLayout,0x16>);
	@version(4.0.0+)
	[8250] OpenSharedLayer(nn::vi::fbshare::SharedLayerHandle, nn::applet::AppletResourceUserId, pid);
	@version(4.0.0+)
	[8251] CloseSharedLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8252] ConnectSharedLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8253] DisconnectSharedLayer(nn::vi::fbshare::SharedLayerHandle);
	@version(4.0.0+)
	[8254] AcquireSharedFrameBuffer(nn::vi::fbshare::SharedLayerHandle) -> (nn::vi::native::NativeSync, nn::vi::fbshare::SharedLayerTextureIndexList, u64);
	@version(4.0.0+)
	[8255] PresentSharedFrameBuffer(nn::vi::native::NativeSync, nn::vi::CropRegion, u32, u32, nn::vi::fbshare::SharedLayerHandle, u64);
	@version(4.0.0+)
	[8256] GetSharedFrameBufferAcquirableEvent(nn::vi::fbshare::SharedLayerHandle) -> handle<copy>;
	@version(4.0.0+)
	[8257] FillSharedFrameBufferColor(u32, u32, u32, u32, nn::vi::fbshare::SharedLayerHandle, u64);
	@version(5.0.0+)
	@undocumented
	[8258] CancelSharedFrameBuffer(unknown) -> unknown;
}

interface nn::visrv::sf::ISystemRootService is vi:s {
	# Returns an
	# [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# Takes an input u32, user-processes use 0 or 1, with 0 for
	# regular-applications normally. 0 = user-service(vi:u), 1 =
	# non-user-service? Returns an error when using value 1 with vi:u(same
	# error listed below for IApplicationDisplayService for unavailable
	# commands).
	# 
	[1] GetDisplayService(u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
	# Returns an
	# [\#IApplicationDisplayService](#nn::visrv::sf::IApplicationDisplayService "wikilink").
	# 
	[3] GetDisplayServiceWithProxyNameExchange(nn::vi::ProxyName, u32) -> object<nn::visrv::sf::IApplicationDisplayService>;
}

interface nn::wlan::detail::IInfraManager is wlan:inf {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] GetMacAddress() -> unknown<6>;
	@undocumented
	[3] StartScan(buffer<unknown,0x15>);
	@undocumented
	[4] StopScan();
	@undocumented
	[5] Connect(unknown<0x80>);
	@undocumented
	[6] CancelConnect();
	@undocumented
	[7] Disconnect();
	@undocumented
	[8] Unknown8(unknown<4>) -> handle<copy>;
	@undocumented
	[9] Unknown9() -> unknown<0x3c>;
	@undocumented
	[10] GetState() -> unknown<4>;
	@undocumented
	[11] GetScanResult() -> buffer<unknown,6>;
	@undocumented
	[12] GetRssi() -> unknown<4>;
	@undocumented
	[13] ChangeRxAntenna(unknown<4>);
	@undocumented
	[14] Unknown14() -> buffer<unknown,0xa>;
	@undocumented
	[15] Unknown15();
	@undocumented
	[16] RequestWakeUp();
	@undocumented
	[17] RequestIfUpDown(unknown<8>, buffer<unknown,9>);
	@version(2.0.0+)
	@undocumented
	[18] Unknown18() -> unknown<4>;
	@version(2.0.0+)
	@undocumented
	[19] Unknown19(unknown<0x18>);
	@version(2.0.0+)
	@undocumented
	[20] Unknown20();
	@version(2.0.0+)
	@undocumented
	[21] Unknown21() -> unknown<4>;
	@version(2.0.0+)
	@undocumented
	[22] Unknown22(unknown<4>);
	@version(2.0.0+)
	@undocumented
	[23] Unknown23(unknown<4>);
	@version(2.0.0+)
	@undocumented
	[24] Unknown24() -> unknown<0x5c>;
	@version(2.0.0+)
	@undocumented
	[25] Unknown25(unknown<2>);
	@version(4.0.0+)
	@undocumented
	[26] Unknown26();
	@version(4.0.0+)
	@undocumented
	[27] Unknown27();
}

interface nn::wlan::detail::ILocalGetActionFrame is wlan:lga {
	@undocumented
	[0] Unknown0(unknown<4>) -> (unknown<0xc>, buffer<unknown,6>);
}

interface nn::wlan::detail::ILocalGetFrame is wlan:lg {
	@undocumented
	[0] Unknown0(unknown<4>) -> (unknown<4>, buffer<unknown,6>);
}

interface nn::wlan::detail::ILocalManager is wlan:lcl {
	@undocumented
	[0] Unknown0();
	@undocumented
	[1] Unknown1();
	@undocumented
	[2] Unknown2();
	@undocumented
	[3] Unknown3();
	@undocumented
	[4] Unknown4();
	@undocumented
	[5] Unknown5();
	@undocumented
	[6] GetMacAddress() -> unknown<6>;
	@undocumented
	[7] CreateBss(unknown<0x84>);
	@undocumented
	[8] DestroyBss();
	@undocumented
	[9] StartScan(buffer<unknown,0x15>);
	@undocumented
	[10] StopScan();
	@undocumented
	[11] Connect(unknown<0x84>);
	@undocumented
	[12] CancelConnect();
	@undocumented
	[13] Join(unknown<0x84>);
	@undocumented
	[14] CancelJoin();
	@undocumented
	[15] Disconnect(unknown<0x10>);
	@undocumented
	[16] SetBeaconLostCount(unknown<4>);
	@undocumented
	[17] Unknown17(unknown<4>) -> handle<copy>;
	@undocumented
	[18] Unknown18() -> unknown<0x3c>;
	@undocumented
	[19] Unknown19() -> buffer<unknown,0x16>;
	@undocumented
	[20] GetBssIndicationEvent() -> handle<copy>;
	@undocumented
	[21] GetBssIndicationInfo() -> buffer<unknown,0x16>;
	@undocumented
	[22] GetState() -> unknown<4>;
	@undocumented
	[23] GetAllowedChannels() -> unknown<0x50>;
	@undocumented
	[24] AddIe(unknown<4>, buffer<unknown,5>) -> unknown<4>;
	@undocumented
	[25] DeleteIe(unknown<4>);
	@undocumented
	[26] Unknown26(buffer<unknown,5>);
	@undocumented
	[27] Unknown27(unknown<4>);
	@undocumented
	[28] CreateRxEntry(unknown<4>, buffer<unknown,9>) -> unknown<4>;
	@undocumented
	[29] DeleteRxEntry(unknown<4>);
	@undocumented
	[30] Unknown30(unknown<8>);
	@undocumented
	[31] Unknown31(unknown<2>) -> unknown<4>;
	@undocumented
	[32] AddMatchingDataToRxEntry(unknown<4>, buffer<unknown,0x19>);
	@undocumented
	[33] RemoveMatchingDataFromRxEntry(unknown<4>, buffer<unknown,0x19>);
	@undocumented
	[34] GetScanResult(buffer<unknown,0x19>) -> buffer<unknown,6>;
	@undocumented
	[35] Unknown35(unknown<0x10>, buffer<unknown,5>);
	@undocumented
	[36] SetActionFrameWithBeacon(buffer<unknown,5>);
	@undocumented
	[37] CancelActionFrameWithBeacon();
	@undocumented
	[38] CreateRxEntryForActionFrame(unknown<4>, buffer<unknown,9>) -> unknown<4>;
	@undocumented
	[39] DeleteRxEntryForActionFrame(unknown<4>);
	@undocumented
	[40] Unknown40(unknown<8>);
	@undocumented
	[41] Unknown41(unknown<4>) -> unknown<4>;
	@undocumented
	[42] CancelGetActionFrame(unknown<4>);
	@undocumented
	[43] GetRssi() -> unknown<4>;
	@undocumented
	[44] Unknown44(unknown<4>);
	@version(4.0.0+)
	@undocumented
	[45] Unknown45();
	@version(4.0.0+)
	@undocumented
	[46] Unknown46();
	@version(4.0.0+)
	@undocumented
	[47] Unknown47();
	@version(4.0.0+)
	@undocumented
	[48] Unknown48();
}

interface nn::wlan::detail::ISocketGetFrame is wlan:sg {
	@undocumented
	[0] Unknown0(unknown<4>) -> (unknown<4>, buffer<unknown,6>);
}

interface nn::wlan::detail::ISocketManager is wlan:soc {
	@undocumented
	[0] Unknown0(buffer<unknown,5>);
	@undocumented
	[1] Unknown1(unknown<4>);
	@undocumented
	[2] Unknown2(unknown<4>, buffer<unknown,9>) -> unknown<4>;
	@undocumented
	[3] Unknown3(unknown<4>);
	@undocumented
	[4] Unknown4(unknown<8>);
	@undocumented
	[5] Unknown5(unknown<2>) -> unknown<4>;
	@undocumented
	[6] GetMacAddress() -> unknown<6>;
	@undocumented
	[7] SwitchTsfTimerFunction(unknown<1>);
	@undocumented
	[8] Unknown8() -> unknown<8>;
	@undocumented
	[9] Unknown9(unknown<4>, handle<copy>, handle<copy>, handle<copy>, handle<copy>, handle<copy>);
	@undocumented
	[10] Unknown10();
	@undocumented
	[11] Unknown11();
}

interface nn::xcd::detail::ISystemServer is xcd:sys {
	@undocumented
	[0] GetDataFormat(unknown<8>) -> unknown<1>;
	@undocumented
	[1] SetDataFormat(unknown<0x10>);
	@undocumented
	[2] GetMcuState(unknown<8>) -> unknown<1>;
	@undocumented
	[3] SetMcuState(unknown<0x10>);
	@undocumented
	[4] GetMcuVersionForNfc(unknown<8>) -> unknown<0x20>;
	@undocumented
	[5] CheckNfcDevicePower(unknown<8>);
	@undocumented
	[10] SetNfcEvent(unknown<8>) -> (handle<copy>, handle<copy>);
	@undocumented
	[11] GetNfcInfo(unknown<8>) -> buffer<unknown,0x1a>;
	@undocumented
	[12] StartNfcDiscovery(unknown<0x10>);
	@undocumented
	[13] StopNfcDiscovery(unknown<8>);
	@undocumented
	[14] StartNtagRead(unknown<0x30>);
	@undocumented
	[15] StartNtagWrite(unknown<8>, buffer<unknown,0x19>);
	@undocumented
	[16] SendNfcRawData(unknown<8>, buffer<unknown,0x19>);
	@undocumented
	[17] RegisterMifareKey(unknown<8>, buffer<unknown,0x19>);
	@undocumented
	[18] ClearMifareKey(unknown<0x10>);
	@undocumented
	[19] StartMifareRead(unknown<8>, buffer<unknown,0x19>);
	@undocumented
	[20] StartMifareWrite(unknown<8>, buffer<unknown,0x19>);
	@undocumented
	[101] GetAwakeTriggerReasonForLeftRail() -> unknown<8>;
	@undocumented
	[102] GetAwakeTriggerReasonForRightRail() -> unknown<8>;
}

interface nns::hosbinder::IHOSBinderDriver is dispdrv {
	# Takes a s32 (**ID**), an u32 (**code**), a type-0x5 input buffer
	# (**parcel\_data**), a type-0x6 output buffer (**parcel\_reply**) and an
	# input u32 (**flags**). Each word is placed immediately after the
	# previous word.
	# 
	# Analogous to "onTransact" from "android.os.IServiceManager".
	# 
	@undocumented
	[0] TransactParcel(unknown) -> unknown;
	# Takes 3 input s32s: **ID**, **addval**, and **type**. Each word
	# immediately follows the previous word. No additional output.
	# 
	# | Called by official function          | addval | type |
	# | ------------------------------------ | ------ | ---- |
	# | "android::BpBinder::onFirstRef"      | 1      | 1    |
	# | "android::BpBinder::onLastStrongRef" | \-1    | 1    |
	# | ?                                    | 1      | 0    |
	# | ?                                    | \-1    | 0    |
	# 
	# During init, {addval=1, type=0} is used then {addval=1, type=1} is used.
	# 
	@undocumented
	[1] AdjustRefcount(unknown) -> unknown;
	# Takes an input s32 (**ID**) and u32, with the latter immediately
	# following the previous word. Returns an output event handle.
	# 
	@undocumented
	[2] GetNativeHandle(unknown) -> unknown;
	# Takes a s32 (**ID**), an u32 (**code**), a type-0x21 input buffer
	# (**parcel\_data**), a type-0x22 output buffer (**parcel\_reply**) and an
	# input u32 (**flags**). Each word is placed immediately after the
	# previous
	# word.
	# 
	# [Category:Services](http://switchbrew.org/index.php?title=Category:Services "wikilink")
	# 
	@version(3.0.0+)
	@undocumented
	[3] TransactParcelAuto(unknown) -> unknown;
}

interface nns::nvdrv::INvDrvDebugFSServices is nvdrvdbg {
	# Takes process handle. Returns an fd.
	# 
	@undocumented
	[0] OpenLog(handle<copy>) -> unknown<4>;
	# Takes fd and closes it.
	# 
	@undocumented
	[1] CloseLog(unknown<4>);
	# Takes fd and reads log into a type-6 buffer.
	# 
	@undocumented
	[2] ReadLog(unknown<4>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[3] Unknown3(unknown<4>, buffer<unknown,5>) -> (unknown<4>, buffer<unknown,6>);
	@undocumented
	[4] Unknown4(unknown<4>, buffer<unknown,5>, buffer<unknown,5>) -> unknown<4>;
}

interface nns::nvdrv::INvDrvServices is nvdrv:a, nvdrv:s, nvdrv:t, nvdrv {
	# Takes a type-0x5 input buffer for the device-path. Returns the output
	# 32bit **fd** and the u32 **error\_code**.
	# 
	[0] Open(buffer<unknown,5>) -> unknown<8>;
	# Takes a 32bit **fd**, an u32 **ioctl\_cmd**, a type-0x21 input buffer,
	# and a type-0x22 output buffer. Returns an output u32 (**error\_code**).
	# 
	# The addr/size for send/recv buffers are only set when the associated
	# direction bit is set in the ioctl cmd (addr/size = 0 otherwise).
	# 
	[1] Ioctl(unknown<8>, buffer<unknown,0x21>) -> (unknown<4>, buffer<unknown,0x22>);
	# Takes a 32bit **fd**. Returns an output u32 (**error\_code**).
	# 
	[2] Close(unknown<4>) -> unknown<4>;
	# Takes two copy-handles (**current\_process** and **transfer\_memory**)
	# and an input u32 (**transfer\_memory\_size**). Returns an output u32
	# (**error\_code**).
	# 
	# Webkit applet creates the transfer-memory with perm = 0 and size
	# 0x300000.
	# 
	[3] Initialize(unknown<4>, handle<copy>, handle<copy>) -> unknown<4>;
	# Takes two input u32s (**fd** and **event\_id**), with the second word
	# immediately after the first one. Returns an output u32 (**error\_code**)
	# and a copy-handle (**event\_handle**).
	# 
	# QueryEvent is only supported on (and implemented differently on):
	# 
	#   - /dev/nvhost-gpu
	#       - 1: SmException\_BptIntReport
	#       - 2: SmException\_BptPauseReport
	#       - 3: ErrorNotifierEvent
	#   - /dev/nvhost-ctrl: Used to get events for SyncPts.
	#       - If bit31-28 is 1, then lower 16-bits contain event\_slot,
	#         bit27-16 contain syncpt\_number.
	#       - If bit31-28 is 0, then lower 4-bits contain event\_slot, bit31-4
	#         contains syncpt\_number.
	#   - /dev/nvhost-ctrl-gpu
	#       - 1: Returns error\_event\_handle.
	#       - 2: Returns unknown event.
	#   - /dev/nvhost-dbg-gpu
	#       - Ignores event\_id.
	# 
	[4] QueryEvent(unknown<8>) -> (unknown<4>, handle<copy>);
	# Takes a copy-handle (**transfer\_memory**) and two input u32s (**fd**
	# and **nvmap\_handle**). Returns an output u32 (**error\_code**).
	# 
	[5] MapSharedMem(unknown<8>, handle<copy>) -> unknown<4>;
	# Takes no input. Returns 0x10-bytes and an output u32 (**error\_code**).
	# 
	[6] GetStatus() -> unknown<0x24>;
	# Takes an input u64 which must
	# [match](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink")
	# the user-process PID
	# ([AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink")).
	# Returns an output u32 (**error\_code**).
	# 
	[7] ForceSetClientPID(unknown<8>) -> unknown<4>;
	# Takes a PID-descriptor and an u64 which must
	# [match](http://switchbrew.org/index.php?title=IPC_Marshalling "wikilink")
	# the user-process PID
	# ([AppletResourceUserId](http://switchbrew.org/index.php?title=AM_services "wikilink")).
	# Returns an output u32 (**error\_code**).
	# 
	[8] SetClientPID(unknown<8>, pid) -> unknown<4>;
	# No input or output. Does nothing.
	# 
	[9] DumpGraphicsMemoryInfo();
	# Takes a copy-handle and an input u32. Returns an output u32
	# (**error\_code**).
	# 
	@version(3.0.0+)
	[10] InitializeDevtools(unknown<4>, handle<copy>) -> unknown<4>;
	# Takes a type-0x21 buffer, a type-0x22 buffer, a type-0x21 buffer, and
	# two input u32s. Returns an output u32 (**error\_code**).
	# 
	@version(3.0.0+)
	[11] Ioctl2(unknown<8>, buffer<unknown,0x21>, buffer<unknown,0x21>) -> (unknown<4>, buffer<unknown,0x22>);
	# Takes a type-0x21 buffer, a type-0x22 buffer, another type-0x22 buffer,
	# and two input u32s. Returns an output u32 (error\_code). Cmdhdr\_word1
	# is 0x100B instead of 0xC0B.
	# 
	@version(3.0.0+)
	[12] Ioctl3(unknown<8>, buffer<unknown,0x21>) -> (unknown<4>, buffer<unknown,0x22>, buffer<unknown,0x22>);
	@version(3.0.0+)
	[13] FinishInitialize(unknown<8>);
}

interface nv::gemcontrol::INvGemControl is nvgem:c {
	@undocumented
	[0] Unknown0() -> unknown<4>;
	@undocumented
	[1] Unknown1() -> (unknown<4>, handle<copy>);
	@undocumented
	[2] Unknown2(unknown<1>) -> unknown<4>;
	@undocumented
	[3] Unknown3(unknown<0x10>) -> unknown<4>;
	@undocumented
	[4] Unknown4(unknown<0x10>) -> unknown<4>;
	@undocumented
	[5] Unknown5() -> unknown<0x10>;
	@undocumented
	[6] Unknown6() -> unknown<4>;
	@undocumented
	[7] Unknown7() -> unknown<0x10>;
}

interface nv::gemcoredump::INvGemCoreDump is nvgem:cd {
	@undocumented
	[0] Unknown0() -> unknown<4>;
	@undocumented
	[1] Unknown1() -> unknown<0x10>;
	@undocumented
	[2] Unknown2() -> (unknown<4>, buffer<unknown,0x22>);
}

